<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Anime Roguelike Shooter</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    body{
      background:#050509;
      color:#f5f5f5;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      display:flex;
      flex-direction:column;
      align-items:center;
      padding:10px;
      user-select:none;
    }
    h1{font-size:22px;margin-bottom:4px}
    p{font-size:12px;margin-bottom:6px;opacity:.85}

    #container{position:relative;display:inline-block}
    #game{
      display:block;
      border-radius:8px;
      border:2px solid #333;
      background:#000;
      image-rendering:pixelated;
    }
    #overlayMessage{
      position:absolute;
      top:8px;
      left:50%;
      transform:translateX(-50%);
      padding:4px 10px;
      background:rgba(0,0,0,.6);
      border-radius:999px;
      font-size:12px;
      pointer-events:none;
    }

    #hud{
      margin-top:6px;
      font-size:13px;
      display:flex;
      gap:12px;
      justify-content:center;
      flex-wrap:wrap;
    }
    #hudHP.low{
      color:#ff7070;
      text-shadow:0 0 8px rgba(255,90,90,.9);
    }
    #hudUlt.ult-ready{
      color:#ffe08a;
      text-shadow:0 0 8px rgba(255,210,120,.9);
    }
    #hudStyle.style-high{
      color:#87c7ff;
      text-shadow:0 0 8px rgba(120,180,255,.9);
    }

    #upgradePanel{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.75);
      z-index:10;
    }
    #upgradePanelInner{
      background:#101010;
      border-radius:10px;
      padding:14px;
      max-width:620px;
      width:92%;
      box-shadow:0 0 24px rgba(0,0,0,.9);
      font-size:13px;
    }
    #upgradePanelInner h2{margin-bottom:6px;font-size:18px}
    #upgradePanelInner p{margin-bottom:8px;font-size:11px;opacity:.9}
    #upgrades{
      display:flex;
      flex-direction:column;
      gap:6px;
      margin-bottom:6px;
    }
    .upgradeButton{
      background:#181818;
      border-radius:6px;
      padding:7px;
      text-align:left;
      cursor:pointer;
      font-size:12px;
      border:1px solid #555;
      color:#f5f5f5;
      transition:background .1s,transform .05s,box-shadow .1s,border-color .1s;
    }
    .upgradeButton:hover{
      background:#252525;
      transform:translateY(-1px);
      box-shadow:0 0 16px rgba(255,255,255,.16);
    }
    .upgradeTopRow{
      display:flex;
      justify-content:space-between;
      margin-bottom:2px;
    }
    .upgradeName{font-weight:600}
    .upgradeDesc{font-size:11px;opacity:.92;color:#f0f0f0}

    .rarityBadge{
      font-size:9px;
      padding:2px 6px;
      border-radius:999px;
      text-transform:uppercase;
      letter-spacing:.05em;
      font-weight:600;
      border:1px solid transparent;
    }
    .rarity-common{
      color:#b8f7b8;
      background:rgba(80,160,80,.18);
      border-color:rgba(120,220,120,.7);
    }
    .rarity-rare{
      color:#87c7ff;
      background:rgba(80,120,200,.18);
      border-color:rgba(120,180,255,.7);
    }
    .rarity-epic{
      color:#e3b3ff;
      background:rgba(150,80,200,.2);
      border-color:rgba(210,150,255,.8);
    }
    .rarity-legendary{
      color:#ffe08a;
      background:rgba(200,140,40,.25);
      border-color:rgba(255,206,120,.9);
    }

    .card-rarity-common{
      box-shadow:0 0 6px rgba(130,220,130,.5);
      border-color:rgba(130,220,130,.7);
    }
    .card-rarity-rare{
      box-shadow:0 0 9px rgba(120,180,255,.7);
      border-color:rgba(120,180,255,.9);
    }
    .card-rarity-epic{
      box-shadow:0 0 11px rgba(210,140,255,.8);
      border-color:rgba(210,140,255,1);
    }
    .card-rarity-legendary{
      box-shadow:0 0 14px rgba(255,210,100,1);
      border-color:rgba(255,210,100,1);
    }

    #skipButton{
      margin-top:2px;
      padding:5px 10px;
      border-radius:999px;
      border:1px solid #777;
      background:#222;
      color:#f5f5f5;
      cursor:pointer;
      font-size:11px;
      float:right;
    }
    #skipButton:hover{background:#333}

    #abilitiesBar{
      margin-top:8px;
      display:flex;
      gap:20px;
      justify-content:center;
      flex-wrap:wrap;
      max-width:960px;
      font-size:11px;
    }
    .abilitiesGroup{
      display:flex;
      flex-direction:column;
      gap:4px;
      align-items:flex-start;
    }
    .abilitiesTitle{opacity:.75;font-size:11px}
    .abilitiesList{
      display:flex;
      gap:4px;
      flex-wrap:wrap;
      max-width:460px;
    }
    .abilitySlot{
      border-radius:999px;
      padding:3px 7px;
      border:1px solid #666;
      background:#151515;
      font-size:10px;
      cursor:pointer;
      white-space:nowrap;
      display:inline-flex;
      align-items:center;
      transition:background .1s,transform .05s,box-shadow .1s,border-color .1s;
    }
    .abilitySlot:hover{
      background:#232323;
      transform:translateY(-1px);
    }
    .abilitySlot.card-rarity-common{
      box-shadow:0 0 4px rgba(130,220,130,.5);
      border-color:rgba(130,220,130,.7);
    }
    .abilitySlot.card-rarity-rare{
      box-shadow:0 0 6px rgba(120,180,255,.7);
      border-color:rgba(120,180,255,.9);
    }
    .abilitySlot.card-rarity-epic{
      box-shadow:0 0 7px rgba(210,140,255,.8);
      border-color:rgba(210,140,255,1);
    }
    .abilitySlot.card-rarity-legendary{
      box-shadow:0 0 9px rgba(255,210,100,1);
      border-color:rgba(255,210,100,1);
    }

    #mainMenu{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.9);
      z-index:20;
    }
    #mainMenuInner{
      background:#111;
      padding:16px 20px;
      border-radius:10px;
      max-width:620px;
      width:92%;
      box-shadow:0 0 24px rgba(0,0,0,.9);
      text-align:center;
      font-size:13px;
    }
    #mainMenuInner h2{margin-bottom:4px;font-size:20px}
    #mainMenuInner p{opacity:.85;margin-bottom:6px;font-size:11px}
    .menuButtons{
      display:flex;
      gap:8px;
      justify-content:center;
      flex-wrap:wrap;
      margin:6px 0;
    }
    .menuButton{
      padding:7px 12px;
      border-radius:999px;
      border:1px solid #666;
      background:#222;
      color:#f5f5f5;
      cursor:pointer;
      font-size:12px;
      transition:background .1s,transform .05s,box-shadow .1s;
    }
    .menuButton:hover{
      background:#333;
      transform:translateY(-1px);
      box-shadow:0 0 12px rgba(255,255,255,.15);
    }
    .menuButton.styleActive{
      background:#203040;
      border-color:#7bd0ff;
      box-shadow:0 0 12px rgba(123,208,255,.8);
    }
    .menuButton.cosmeticLocked{
      opacity:0.35;
      border-style:dashed;
      cursor:not-allowed;
      box-shadow:none;
    }
    .menuButton.cosmeticSelected{
      box-shadow:0 0 12px rgba(255,255,255,0.5);
    }
  </style>
</head>
<body>
  <h1>Anime Roguelike Shooter</h1>
  <p>WASD / Arrows move • Mouse aim • Left click shoot • Right click / E melee • Space dash • Q ultimate • R restart</p>

  <!-- MAIN MENU -->
  <div id="mainMenu">
    <div id="mainMenuInner">
      <h2>Anime Rogue Run</h2>
      <p>Pick your playstyle and archetype. Build busted Demon Slayer / One Piece / JJK / MHA / Cyberpunk / Solo Leveling combos.</p>

      <p style="margin-top:4px;font-weight:600">Combat Style</p>
      <div class="menuButtons">
        <button class="menuButton" data-style="melee">Melee Focus</button>
        <button class="menuButton" data-style="ranged">Ranged Focus</button>
      </div>

      <p style="margin-top:4px;font-weight:600">Archetype</p>
      <div class="menuButtons">
        <button class="menuButton archButton" data-arch="swordsman">Sharp Swordsman</button>
        <button class="menuButton archButton" data-arch="sorcerer">Cursed Sorcerer</button>
        <button class="menuButton archButton" data-arch="titan">Titan Slayer</button>
        <button class="menuButton archButton" data-arch="hero">Quirked Hero</button>
      </div>

      <p style="margin-top:4px;font-weight:600">Ultimate (Q to cast)</p>
      <div class="menuButtons" id="ultMenu">
        <button class="menuButton ultButton" data-ult="jjk_domain">JJK Domain</button>
        <button class="menuButton ultButton" data-ult="ofa_100">OFA 100%</button>
        <button class="menuButton ultButton" data-ult="demon_mark">Demon Mark</button>
        <button class="menuButton ultButton" data-ult="gear_fifth">Gear Fifth</button>
        <button class="menuButton ultButton" data-ult="susanoo_guardian">Susanoo Guardian</button>
        <button class="menuButton ultButton" data-ult="cyber_sandevistan">Cyber Sandevistan</button>
        <button class="menuButton ultButton" data-ult="ghoul_rampage">Ghoul Rampage</button>
        <button class="menuButton ultButton" data-ult="flame_domain">Flame Ring</button>
        <button class="menuButton ultButton" data-ult="bankai_field">Bankai Field</button>
        <button class="menuButton ultButton" data-ult="haki_burst">Haki Burst</button>
        <button class="menuButton ultButton" data-ult="chimera_shadow_garden">Chimera Shadow Garden</button>
        <button class="menuButton ultButton" data-ult="thunder_god_avatar">Thunder God Avatar</button>
        <button class="menuButton ultButton" data-ult="orbital_strike">Orbital Strike</button>
      </div>

      <p style="margin-top:4px;font-weight:600">Cosmetics – Player Skin</p>
      <div class="menuButtons" id="skinMenu">
        <button class="menuButton skinButton" data-skin="skin_default" title="Always unlocked.">Default Hunter</button>
        <button class="menuButton skinButton" data-skin="skin_hashira" title="Reach Wave 10 to unlock.">Hashira Cloak</button>
        <button class="menuButton skinButton" data-skin="skin_domain_freak" title="Use a Domain-style ult 3 times total to unlock.">Domain Freak</button>
        <button class="menuButton skinButton" data-skin="skin_shadow_monarch" title="Defeat a boss while using Shadow Army Commander to unlock.">Shadow Monarch</button>
      </div>

      <p style="margin-top:4px;font-weight:600">Cosmetics – Bullet Trail</p>
      <div class="menuButtons" id="trailMenu">
        <button class="menuButton trailButton" data-trail="trail_default" title="Always unlocked.">Default Trail</button>
        <button class="menuButton trailButton" data-trail="trail_flame" title="Beat any boss to unlock.">Flame Rounds</button>
        <button class="menuButton trailButton" data-trail="trail_cursed" title="Take any Curse to unlock.">Cursed Sparks</button>
        <button class="menuButton trailButton" data-trail="trail_lightning" title="Reach Style rank S to unlock.">Lightning Shots</button>
      </div>

      <p style="margin-top:4px;font-weight:600">Cosmetics – Dash Trail</p>
      <div class="menuButtons" id="dashMenu">
        <button class="menuButton dashButton" data-dash="dash_default" title="Always unlocked.">Default Dash</button>
        <button class="menuButton dashButton" data-dash="dash_afterimage" title="Dash 50 times total to unlock.">Afterimage Step</button>
        <button class="menuButton dashButton" data-dash="dash_void" title="Reach Wave 15 to unlock.">Void Step</button>
      </div>

      <p style="margin-top:4px;font-size:10px;opacity:.7">
        Locked cosmetics are greyed out – unlock them by hitting milestones in your runs.
      </p>

      <p style="margin-top:4px;font-size:11px;opacity:.75">
        Powers every wave with drawbacks. Boss &amp; curses every 5 waves, mini-bosses, event waves like Blood Moon &amp; Curse Storm.
      </p>
    </div>
  </div>

  <div id="container">
    <canvas id="game" width="960" height="540"></canvas>
    <div id="overlayMessage"></div>

    <div id="upgradePanel">
      <div id="upgradePanelInner">
        <h2>Choose a Power-Up</h2>
        <p>
          Every wave you get a power with a drawback. Max <b>5 normal</b> powers and <b>2 boss</b> powers (unless you break the limit).
          Boss waves can offer <b>Legendary</b> powers and <b>Curses</b> with extreme tradeoffs.
        </p>
        <div id="upgrades"></div>
        <button id="skipButton">Skip – no power this wave</button>
      </div>
    </div>
  </div>

  <div id="hud">
    <div id="hudWave"></div>
    <div id="hudHP"></div>
    <div id="hudStats"></div>
    <div id="hudUlt"></div>
    <div id="hudStyle"></div>
  </div>

  <div id="abilitiesBar">
    <div class="abilitiesGroup">
      <span class="abilitiesTitle">Normal Powers (cap 5, unless Broken Limit):</span>
      <div id="normalAbilitiesList" class="abilitiesList"></div>
    </div>
    <div class="abilitiesGroup">
      <span class="abilitiesTitle">Boss Powers (cap 2):</span>
      <div id="bossAbilitiesList" class="abilitiesList"></div>
    </div>
  </div>

  <script>
    const canvas=document.getElementById("game");
    const ctx=canvas.getContext("2d");
    const overlayMessageEl=document.getElementById("overlayMessage");
    const upgradePanel=document.getElementById("upgradePanel");
    const upgradesContainer=document.getElementById("upgrades");
    const skipButton=document.getElementById("skipButton");
    const hudWave=document.getElementById("hudWave");
    const hudHP=document.getElementById("hudHP");
    const hudStats=document.getElementById("hudStats");
    const hudUlt=document.getElementById("hudUlt");
    const hudStyle=document.getElementById("hudStyle");
    const mainMenu=document.getElementById("mainMenu");
    const normalAbilitiesListEl=document.getElementById("normalAbilitiesList");
    const bossAbilitiesListEl=document.getElementById("bossAbilitiesList");

    const keys={};
    let mousePos={x:canvas.width/2,y:canvas.height/2};
    let mouseDown=false;
    let combatStyle=null;
    let selectedUltId="jjk_domain";
    let selectedArchetype="sorcerer";
    let gameState="menu";
    let lastTime=0;
    let messageTimer=0;

    let bgTime=0;
    const particles=[];
    const fireBursts=[];
    const playerBombs=[];
    const slowFields=[];
    let summons=[];
    let titanSummon=null;

    let screenShakeTimer=0;
    let screenShakeDuration=0;
    let screenShakeIntensity=0;
    let whiteFlashAlpha=0;

    let domainField={
      active:false,
      x:0,y:0,
      radius:220,
      type:null,
      color:"rgba(90,60,200,0.18)",
      edgeColor:"rgba(210,180,255,0.9)",
      dpsMult:0
    };

    const GENJUTSU_DURATION=3.2;
    let bossGenjutsuTimer=0;

    let player=null;
    let bullets=[];
    let enemies=[];
    let enemyBullets=[];
    let enemyIdCounter=1;

    let wave=0;
    let normalAbilities=[];
    let bossAbilities=[];
    let curses=[];
    let activeCurses=[];
    let noLimitMode=false;
    let pendingAbility=null;
    let pendingCategory=null;

    let enemyScale={
      hpMult:1,
      speedMult:1,
      damageMult:1,
      countMult:1,
      bulletSpeedMult:1,
      bulletDamageMult:1
    };

    let currentWaveEvent=null;

    const BOSS_TEMPLATES=[
      {id:"mahito",name:"Mahito",color:"#b88cff"},
      {id:"itachi",name:"Itachi",color:"#ff6666"},
      {id:"gojo",name:"Gojo",color:"#7bd0ff"},
      {id:"luffy",name:"Gear Fifth Luffy",color:"#ffd480"}
    ];

    const MINI_BOSS_TEMPLATES=[
      {id:"upper_moon_demon",name:"Upper Moon Demon",color:"#ff9966",pattern:"cone"},
      {id:"high_end_nomu",name:"High-End Nomu",color:"#c84cff",pattern:"rush"},
      {id:"armored_titan",name:"Armored Titan",color:"#d8aa6a",pattern:"spin"}
    ];

    const ARCHETYPES={
      swordsman:{id:"swordsman",name:"Sharp Swordsman",startAbilities:["water_breathing","blood_edge"]},
      sorcerer:{id:"sorcerer",name:"Cursed Sorcerer",startAbilities:["shadow_garden","black_flash_rhythm"]},
      titan:{id:"titan",name:"Titan Slayer",startAbilities:["survey_maneuvers","shadow_army_commander"]},
      hero:{id:"hero",name:"Quirked Hero",startAbilities:["quirk_booster","fire_force_spark"]}
    };

    const COSMETICS={
      skins:[
        {id:"skin_default",name:"Default Hunter",unlockCheck:(s)=>true},
        {id:"skin_hashira",name:"Hashira Cloak",unlockCheck:(s)=>s.maxWaveEver>=10},
        {id:"skin_domain_freak",name:"Domain Freak",unlockCheck:(s)=>s.totalDomainsCast>=3},
        {id:"skin_shadow_monarch",name:"Shadow Monarch",unlockCheck:(s)=>s.defeatedBossWithShadowCommanderOnce}
      ],
      bulletTrails:[
        {id:"trail_default",name:"Default Trail",unlockCheck:(s)=>true},
        {id:"trail_flame",name:"Flame Rounds",unlockCheck:(s)=>s.bossesKilled>=1},
        {id:"trail_cursed",name:"Cursed Sparks",unlockCheck:(s)=>s.cursesTaken>=1},
        {id:"trail_lightning",name:"Lightning Shots",unlockCheck:(s)=>s.reachedStyleSOnce}
      ],
      dashTrails:[
        {id:"dash_default",name:"Default Dash",unlockCheck:(s)=>true},
        {id:"dash_afterimage",name:"Afterimage Step",unlockCheck:(s)=>s.totalDashes>=50},
        {id:"dash_void",name:"Void Step",unlockCheck:(s)=>s.maxWaveEver>=15}
      ]
    };

    let cosmeticUnlocks={};
    let cosmeticSelection={
      skin:"skin_default",
      bulletTrail:"trail_default",
      dashTrail:"dash_default"
    };
    let cosmeticStats={
      maxWaveEver:0,
      totalDashes:0,
      totalDomainsCast:0,
      bossesKilled:0,
      cursesTaken:0,
      reachedStyleSOnce:false,
      defeatedBossWithShadowCommanderOnce:false
    };
    /* INPUT */
    window.addEventListener("keydown",e=>{
      const k=e.key.toLowerCase();
      keys[k]=true;
      if(e.code==="Space"&&gameState==="playing")startDash();
      if(e.code==="KeyE"&&gameState==="playing")tryMeleeAttack();
      if(k==="q"&&gameState==="playing")tryUseUlt();
      if(k==="r"&&gameState==="gameover")resetGame();
    });
    window.addEventListener("keyup",e=>{keys[e.key.toLowerCase()]=false;});
    canvas.addEventListener("mousemove",e=>{
      const r=canvas.getBoundingClientRect();
      mousePos.x=e.clientX-r.left;
      mousePos.y=e.clientY-r.top;
    });
    canvas.addEventListener("mousedown",e=>{
      if(e.button===0)mouseDown=true;
      if(e.button===2&&gameState==="playing")tryMeleeAttack();
    });
    canvas.addEventListener("mouseup",e=>{if(e.button===0)mouseDown=false;});
    canvas.addEventListener("contextmenu",e=>e.preventDefault());

    /* UTILS */
    const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
    const distance=(x1,y1,x2,y2)=>Math.hypot(x2-x1,y2-y1);
    function shuffled(a){a=a.slice();for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}
    function angleDiff(a,b){let d=a-b;while(d>Math.PI)d-=Math.PI*2;while(d<-Math.PI)d+=Math.PI*2;return d;}
    function showMessage(msg,t=2){overlayMessageEl.textContent=msg;messageTimer=t;}
    function addScreenShake(intensity,duration){
      screenShakeIntensity=Math.max(screenShakeIntensity,intensity);
      screenShakeDuration=Math.max(screenShakeDuration,duration);
      screenShakeTimer=Math.max(screenShakeTimer,duration);
    }
    function addWhiteFlash(strength){whiteFlashAlpha=Math.min(1,whiteFlashAlpha+strength);}

    /* COSMETICS */
    function ensureBaseCosmeticsUnlocked(){
      ["skin_default","trail_default","dash_default"].forEach(id=>{cosmeticUnlocks[id]=true;});
    }
    function loadCosmeticsFromStorage(){
      try{
        const u=localStorage.getItem("animeRogue_cosmeticUnlocks");
        if(u)cosmeticUnlocks=JSON.parse(u)||{};
        const s=localStorage.getItem("animeRogue_cosmeticStats");
        if(s)cosmeticStats={...cosmeticStats,...JSON.parse(s)};
        const sel=localStorage.getItem("animeRogue_cosmeticSelection");
        if(sel)cosmeticSelection={...cosmeticSelection,...JSON.parse(sel)};
      }catch(e){cosmeticUnlocks={};}
      ensureBaseCosmeticsUnlocked();
    }
    function saveCosmeticUnlocks(){try{localStorage.setItem("animeRogue_cosmeticUnlocks",JSON.stringify(cosmeticUnlocks));}catch(e){}}
    function saveCosmeticStats(){try{localStorage.setItem("animeRogue_cosmeticStats",JSON.stringify(cosmeticStats));}catch(e){}}
    function saveCosmeticSelection(){try{localStorage.setItem("animeRogue_cosmeticSelection",JSON.stringify(cosmeticSelection));}catch(e){}}
    function checkCosmeticUnlocks(){
      ensureBaseCosmeticsUnlocked();
      const s=cosmeticStats;
      const checkGroup=(list)=>{
        for(const c of list){
          if(cosmeticUnlocks[c.id])continue;
          let unlocked=false;
          if(!c.unlockCheck)unlocked=true;
          else unlocked=!!c.unlockCheck(s);
          if(unlocked)cosmeticUnlocks[c.id]=true;
        }
      };
      checkGroup(COSMETICS.skins);
      checkGroup(COSMETICS.bulletTrails);
      checkGroup(COSMETICS.dashTrails);
      saveCosmeticUnlocks();
      refreshCosmeticButtons();
    }
    function refreshCosmeticButtons(){
      const skinButtons=document.querySelectorAll(".skinButton");
      skinButtons.forEach(btn=>{
        const id=btn.getAttribute("data-skin");
        const unlocked=!!cosmeticUnlocks[id];
        btn.classList.remove("cosmeticLocked","styleActive","cosmeticSelected");
        if(!unlocked && id!=="skin_default")btn.classList.add("cosmeticLocked");
        if(cosmeticSelection.skin===id && unlocked)btn.classList.add("styleActive","cosmeticSelected");
      });
      const trailButtons=document.querySelectorAll(".trailButton");
      trailButtons.forEach(btn=>{
        const id=btn.getAttribute("data-trail");
        const unlocked=!!cosmeticUnlocks[id];
        btn.classList.remove("cosmeticLocked","styleActive","cosmeticSelected");
        if(!unlocked && id!=="trail_default")btn.classList.add("cosmeticLocked");
        if(cosmeticSelection.bulletTrail===id && unlocked)btn.classList.add("styleActive","cosmeticSelected");
      });
      const dashButtons=document.querySelectorAll(".dashButton");
      dashButtons.forEach(btn=>{
        const id=btn.getAttribute("data-dash");
        const unlocked=!!cosmeticUnlocks[id];
        btn.classList.remove("cosmeticLocked","styleActive","cosmeticSelected");
        if(!unlocked && id!=="dash_default")btn.classList.add("cosmeticLocked");
        if(cosmeticSelection.dashTrail===id && unlocked)btn.classList.add("styleActive","cosmeticSelected");
      });
    }
    function initCosmeticsSystem(){
      loadCosmeticsFromStorage();
      checkCosmeticUnlocks();
      document.querySelectorAll(".skinButton").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const id=btn.getAttribute("data-skin");
          const unlocked=!!cosmeticUnlocks[id];
          if(!unlocked){showMessage("Skin locked – keep playing to unlock it!",2.2);return;}
          cosmeticSelection.skin=id;
          saveCosmeticSelection();
          refreshCosmeticButtons();
        });
      });
      document.querySelectorAll(".trailButton").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const id=btn.getAttribute("data-trail");
          const unlocked=!!cosmeticUnlocks[id];
          if(!unlocked){showMessage("Bullet trail locked – keep playing to unlock it!",2.2);return;}
          cosmeticSelection.bulletTrail=id;
          saveCosmeticSelection();
          refreshCosmeticButtons();
        });
      });
      document.querySelectorAll(".dashButton").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const id=btn.getAttribute("data-dash");
          const unlocked=!!cosmeticUnlocks[id];
          if(!unlocked){showMessage("Dash trail locked – keep playing to unlock it!",2.2);return;}
          cosmeticSelection.dashTrail=id;
          saveCosmeticSelection();
          refreshCosmeticButtons();
        });
      });
    }

    function getPlayerSkinTheme(){
      switch(cosmeticSelection.skin){
        case "skin_hashira":
          return {
            bodyColor:"#1c2733",
            outlineColor:"#7cf0c1",
            auraColor:"rgba(124,240,193,0.45)",
            dashGlowColor:"#7cf0c1",
            weaponColor:"#c8fff3"
          };
        case "skin_domain_freak":
          return {
            bodyColor:"#33204f",
            outlineColor:"#d2b3ff",
            auraColor:"rgba(164,118,255,0.5)",
            dashGlowColor:"#e6d2ff",
            weaponColor:"#f5e6ff"
          };
        case "skin_shadow_monarch":
          return {
            bodyColor:"#101018",
            outlineColor:"#b68bff",
            auraColor:"rgba(94,70,140,0.65)",
            dashGlowColor:"#b68bff",
            weaponColor:"#f0e6ff"
          };
        default:
          return {
            bodyColor:"#39c5ff",
            outlineColor:"#9ff6ff",
            auraColor:"rgba(120,200,255,0.55)",
            dashGlowColor:"#9ff6ff",
            weaponColor:"#ffffff"
          };
      }
    }
    function getBulletColor(){
      switch(cosmeticSelection.bulletTrail){
        case "trail_flame":return "#ffb35c";
        case "trail_cursed":return "#c68cff";
        case "trail_lightning":return "#e7f6ff";
        default:return "#f5f5f5";
      }
    }
    function getBulletTrailParticleColor(){
      switch(cosmeticSelection.bulletTrail){
        case "trail_flame":return "rgba(255,180,120,1)";
        case "trail_cursed":return "rgba(200,140,255,1)";
        case "trail_lightning":return "rgba(230,250,255,1)";
        default:return null;
      }
    }
    function getDashParticleColor(){
      switch(cosmeticSelection.dashTrail){
        case "dash_afterimage":return "rgba(255,255,255,0.9)";
        case "dash_void":return "rgba(110,90,180,1)";
        default:return "rgba(160,220,255,1)";
      }
    }
    function addBulletTrailFX(b){
      const color=getBulletTrailParticleColor();
      if(!color)return;
      if(Math.random()>0.5)return;
      spawnParticles(b.x,b.y,{
        count:1,speedMin:10,speedMax:40,lifeMin:0.2,lifeMax:0.5,sizeMin:1.2,sizeMax:2.4,color
      });
    }

    /* BACKGROUND – Neon Cursed + Retro Grid */

    function updateBackground(dt){
      bgTime+=dt;
    }

    function drawBackground(){
      const cx=canvas.width/2;
      const cy=canvas.height/2;

      // Big neon radial gradient
      const g=ctx.createRadialGradient(
        cx, cy, 0,
        cx, cy, canvas.width*0.9
      );
      g.addColorStop(0,"#14172a");
      g.addColorStop(0.4,"#090918");
      g.addColorStop(1,"#020208");
      ctx.fillStyle=g;
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // Retro neon grid floor
      const gridSize=32;
      const scroll=(bgTime*25)%gridSize;

      ctx.save();
      ctx.translate(0,canvas.height*0.15); // push "horizon" up
      ctx.globalAlpha=0.3;
      ctx.strokeStyle="#283757";
      ctx.lineWidth=1;

      for(let x=-gridSize;x<canvas.width+gridSize;x+=gridSize){
        ctx.beginPath();
        ctx.moveTo(Math.floor(x+scroll)+0.5,0);
        ctx.lineTo(Math.floor(x+scroll)+0.5,canvas.height);
        ctx.stroke();
      }
      for(let y=0;y<canvas.height;y+=gridSize){
        const yy=Math.floor(y+scroll)+0.5;
        ctx.beginPath();
        ctx.moveTo(0,yy);
        ctx.lineTo(canvas.width,yy);
        ctx.stroke();
      }
      ctx.restore();

      // Extra diagonal "laser" streaks (neon cursed vibe)
      ctx.save();
      ctx.globalAlpha=0.12;
      ctx.strokeStyle="#7e5bff";
      ctx.lineWidth=2;
      const t=bgTime*40;
      for(let i=0;i<4;i++){
        const offset=(t+i*120)% (canvas.width+200) -100;
        ctx.beginPath();
        ctx.moveTo(offset,-20);
        ctx.lineTo(offset+160,canvas.height+40);
        ctx.stroke();
      }
      ctx.restore();

      // Pixel-ish overlay (retro fuzz)
      const cell=8;
      ctx.save();
      ctx.globalAlpha=0.04;
      for(let y=0;y<canvas.height;y+=cell){
        for(let x=0;x<canvas.width;x+=cell){
          if(((x+y)>>3)&1){
            ctx.fillStyle="#000000";
            ctx.fillRect(x,y,cell,cell);
          }
        }
      }
      ctx.restore();

      // Vignette
      const vg=ctx.createRadialGradient(
        cx, cy, canvas.width*0.35,
        cx, cy, canvas.width*0.95
      );
      vg.addColorStop(0,"rgba(0,0,0,0)");
      vg.addColorStop(1,"rgba(0,0,0,0.8)");
      ctx.fillStyle=vg;
      ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    /* PARTICLES & FIELDS */

    function spawnParticles(x,y,opt={}){
      const {
        count=12,spread=Math.PI*2,
        speedMin=80,speedMax=260,
        lifeMin=.25,lifeMax=.6,
        sizeMin=2,sizeMax=4,
        color="rgba(255,255,255,1)"
      }=opt;
      for(let i=0;i<count;i++){
        const ang=Math.random()*spread;
        const s=speedMin+Math.random()*(speedMax-speedMin);
        const vx=Math.cos(ang)*s;
        const vy=Math.sin(ang)*s;
        const life=lifeMin+Math.random()*(lifeMax-lifeMin);
        const size=sizeMin+Math.random()*(sizeMax-sizeMin);
        particles.push({x,y,vx,vy,life,maxLife:life,size,color,renderColor:color});
      }
    }
    function updateParticles(dt){
      for(let i=particles.length-1;i>=0;i--){
        const p=particles[i];
        p.life-=dt;
        if(p.life<=0){particles.splice(i,1);continue;}
        const t=p.life/p.maxLife;
        p.x+=p.vx*dt;
        p.y+=p.vy*dt;
        p.vx*=.97;
        p.vy+=20*dt;
        const m=p.color.match(/rgba\((\d+),(\d+),(\d+),([\d.]+)\)/);
        if(m){
          const[r,g,b]=[m[1],m[2],m[3]];
          p.renderColor=`rgba(${r},${g},${b},${t})`;
        }else p.renderColor=p.color;
      }
    }
    function drawParticles(){
      for(const p of particles){
        ctx.beginPath();
        ctx.arc(p.x,p.y,p.size,0,Math.PI*2);
        ctx.fillStyle=p.renderColor||p.color;
        ctx.fill();
      }
    }
    function updateSlowFields(dt){
      for(let i=slowFields.length-1;i>=0;i--){
        const f=slowFields[i];
        f.life-=dt;
        if(f.life<=0)slowFields.splice(i,1);
      }
    }

    /* PLAYER & STATS */

    const BASE_STATS={
      maxHp:100,
      damage:16,
      fireRate:3,
      speed:230,
      bulletSpeed:550,
      bulletsPerShot:1,
      spread:0.18,
      pierce:0,
      onHitHeal:0,
      healAfterWave:10,
      dashCooldown:1.1,
      dashDuration:.22,
      meleeDamage:32,
      meleeRange:80,
      meleeArc:1.7,
      meleeCooldown:.75,
      meleeOnHitHeal:0
    };

    function createPlayer(){
      return{
        x:canvas.width/2,y:canvas.height/2,radius:10, // slightly smaller for pixel-y look
        hp:BASE_STATS.maxHp,maxHp:BASE_STATS.maxHp,
        damage:BASE_STATS.damage,
        fireRate:BASE_STATS.fireRate,
        speed:BASE_STATS.speed,
        bulletSpeed:BASE_STATS.bulletSpeed,
        bulletsPerShot:BASE_STATS.bulletsPerShot,
        spread:BASE_STATS.spread,
        pierce:BASE_STATS.pierce,
        onHitHeal:BASE_STATS.onHitHeal,
        healAfterWave:BASE_STATS.healAfterWave,
        shootTimer:0,
        dashCooldown:BASE_STATS.dashCooldown,
        dashDuration:BASE_STATS.dashDuration,
        dashCooldownTimer:0,
        dashActiveTimer:0,
        isDashing:false,
        dashVelX:0,dashVelY:0,
        dashMode:"normal",
        meleeDamage:BASE_STATS.meleeDamage,
        meleeRange:BASE_STATS.meleeRange,
        meleeArc:BASE_STATS.meleeArc,
        meleeCooldown:BASE_STATS.meleeCooldown,
        meleeCooldownTimer:0,
        meleeSwingTimer:0,
        meleeSwingDuration:.18,
        meleeAngle:0,
        meleeOnHitHeal:BASE_STATS.meleeOnHitHeal,
        incomingDamageMult:1,
        onHitHealMult:1,
        healAfterWaveMult:1,
        styleMeter:0,
        styleMax:100,
        styleDecayRate:6,
        styleGainMult:1,
        ultId:null,
        ultCooldownTimer:0,
        ultActiveTimer:0,
        ultDamageMult:1,
        ultFireRateMult:1,
        ultSpeedMult:1,
        ultMeleeDamageMult:1,
        ultMeleeRangeMult:1,
        ultPierceBonus:0,
        ultMeleeHealBonus:0,
        ultBulletSpeedMult:1,
        ultIncomingDamageMult:1,
        ultReady:false,
        lastStandActive:false,
        mahitoTouchStacks:0,
        summonDpsMult:1,
        normalAbilities:[],
        bossAbilities:[]
      };
    }

    const getAbilityById=id=>normalAbilities.find(a=>a.id===id)||bossAbilities.find(a=>a.id===id)||null;
    const getCurseById=id=>curses.find(c=>c.id===id)||null;
    const hasCurse=id=>activeCurses.includes(id);

    function hasBrokenLimit(){
      if(!player)return false;
      return player.normalAbilities.includes("broken_limit")||player.bossAbilities.includes("broken_limit");
    }

    function recomputeEnemyScale(){
      enemyScale={hpMult:1,speedMult:1,damageMult:1,countMult:1,bulletSpeedMult:1,bulletDamageMult:1};
      for(const id of activeCurses){
        const c=getCurseById(id);
        if(!c||!c.enemyMods)continue;
        const m=c.enemyMods;
        if(m.enemyHpMult)enemyScale.hpMult*=m.enemyHpMult;
        if(m.enemySpeedMult)enemyScale.speedMult*=m.enemySpeedMult;
        if(m.enemyDamageMult)enemyScale.damageMult*=m.enemyDamageMult;
        if(m.enemyCountMult)enemyScale.countMult*=m.enemyCountMult;
        if(m.enemyBulletSpeedMult)enemyScale.bulletSpeedMult*=m.enemyBulletSpeedMult;
        if(m.enemyBulletDamageMult)enemyScale.bulletDamageMult*=m.enemyBulletDamageMult;
      }
      if(player){
        for(const id of player.bossAbilities){
          const ab=getAbilityById(id);
          if(!ab||!ab.enemyMods)continue;
          const m=ab.enemyMods;
          if(m.enemyHpMult)enemyScale.hpMult*=m.enemyHpMult;
          if(m.enemySpeedMult)enemyScale.speedMult*=m.enemySpeedMult;
          if(m.enemyDamageMult)enemyScale.damageMult*=m.enemyDamageMult;
          if(m.enemyCountMult)enemyScale.countMult*=m.enemyCountMult;
          if(m.enemyBulletSpeedMult)enemyScale.bulletSpeedMult*=m.enemyBulletSpeedMult;
          if(m.enemyBulletDamageMult)enemyScale.bulletDamageMult*=m.enemyBulletDamageMult;
        }
      }
    }

    function recomputePlayerStats(keepHpRatio=true){
      if(!player)return;
      noLimitMode=hasBrokenLimit();
      const oldMax=player.maxHp||BASE_STATS.maxHp;
      const oldRatio=oldMax>0?player.hp/oldMax:1;

      const stats={...BASE_STATS};
      let incomingDamageMult=1;
      let styleGainMult=1;
      let summonDpsMult=1;
      const allIds=[...player.normalAbilities,...player.bossAbilities];
      const abilityFactor=noLimitMode?0.5:1;

      function applyMods(m,factor){
        if(!m)return;
        const f=factor;
        const mul=(v,k)=>{if(m[k])stats[v]*=1+(m[k]-1)*f;};
        const add=(v,k)=>{if(m[k])stats[v]+=m[k]*f;};

        mul("maxHp","maxHpMult");add("maxHp","maxHpAdd");
        mul("damage","damageMult");add("damage","damageAdd");
        mul("fireRate","fireRateMult");add("fireRate","fireRateAdd");
        mul("speed","speedMult");add("speed","speedAdd");
        mul("bulletSpeed","bulletSpeedMult");add("bulletSpeed","bulletSpeedAdd");
        add("bulletsPerShot","bulletsPerShotAdd");
        mul("spread","spreadMult");add("spread","spreadAdd");
        add("pierce","pierceAdd");
        add("onHitHeal","onHitHealAdd");
        add("healAfterWave","healAfterWaveAdd");
        mul("dashCooldown","dashCooldownMult");add("dashCooldown","dashCooldownAdd");
        mul("dashDuration","dashDurationMult");add("dashDuration","dashDurationAdd");
        mul("meleeDamage","meleeDamageMult");add("meleeDamage","meleeDamageAdd");
        mul("meleeRange","meleeRangeMult");add("meleeRange","meleeRangeAdd");
        mul("meleeArc","meleeArcMult");add("meleeArc","meleeArcAdd");
        mul("meleeCooldown","meleeCooldownMult");add("meleeCooldown","meleeCooldownAdd");
        add("meleeOnHitHeal","meleeOnHitHealAdd");

        if(m.incomingDamageMult)incomingDamageMult*=1+(m.incomingDamageMult-1)*f;
        if(m.styleGainMult)styleGainMult*=1+(m.styleGainMult-1)*f;
        if(m.summonDpsMult)summonDpsMult*=1+(m.summonDpsMult-1)*f;
      }

      for(const id of allIds){
        const ab=getAbilityById(id);
        if(!ab)continue;
        applyMods(ab.mods,abilityFactor);
      }
      for(const id of activeCurses){
        const c=getCurseById(id);
        if(!c)continue;
        applyMods(c.mods,1);
      }

      stats.maxHp=Math.max(20,stats.maxHp);
      stats.damage=Math.max(1,stats.damage);
      stats.fireRate=Math.max(.4,stats.fireRate);
      stats.speed=Math.max(60,stats.speed);
      stats.bulletSpeed=Math.max(200,stats.bulletSpeed);
      stats.bulletsPerShot=Math.max(1,Math.round(stats.bulletsPerShot));
      stats.spread=clamp(stats.spread,0.02,.7);
      stats.pierce=Math.max(0,Math.round(stats.pierce));
      stats.onHitHeal=Math.max(0,stats.onHitHeal);
      stats.healAfterWave=Math.max(0,stats.healAfterWave);
      stats.dashCooldown=clamp(stats.dashCooldown,.25,3);
      stats.dashDuration=clamp(stats.dashDuration,.1,.6);
      stats.meleeDamage=Math.max(4,stats.meleeDamage);
      stats.meleeRange=Math.max(30,stats.meleeRange);
      stats.meleeArc=clamp(stats.meleeArc,.6,Math.PI*1.4);
      stats.meleeCooldown=clamp(stats.meleeCooldown,.15,2);
      stats.meleeOnHitHeal=Math.max(0,stats.meleeOnHitHeal);

      const newMax=stats.maxHp;
      if(keepHpRatio)player.hp=clamp(oldRatio*newMax,1,newMax);
      else player.hp=newMax;

      Object.assign(player,{
        maxHp:stats.maxHp,
        damage:stats.damage,
        fireRate:stats.fireRate,
        speed:stats.speed,
        bulletSpeed:stats.bulletSpeed,
        bulletsPerShot:stats.bulletsPerShot,
        spread:stats.spread,
        pierce:stats.pierce,
        onHitHeal:stats.onHitHeal,
        healAfterWave:stats.healAfterWave,
        dashCooldown:stats.dashCooldown,
        dashDuration:stats.dashDuration,
        meleeDamage:stats.meleeDamage,
        meleeRange:stats.meleeRange,
        meleeArc:stats.meleeArc,
        meleeCooldown:stats.meleeCooldown,
        meleeOnHitHeal:stats.meleeOnHitHeal,
        incomingDamageMult,
        styleGainMult,
        summonDpsMult
      });

      const allAbilityIds=[...player.normalAbilities,...player.bossAbilities];
      let dashMode="normal";
      if(allAbilityIds.includes("cursed_dash_bomb"))dashMode="bomb";
      if(allAbilityIds.includes("flame_step"))dashMode="flame";
      if(allAbilityIds.includes("blink_step"))dashMode="blink";
      player.dashMode=dashMode;
      player.lastStandActive=false;

      rebuildSummons();
    }
    /* ULT & STYLE */

    const ULT_DEFS={
      jjk_domain:{
        id:"jjk_domain",
        name:"Domain Expansion",
        cooldown:24,
        duration:6,
        damageMult:1.8,
        fireRateMult:1.1,
        pierceBonus:2,
        bulletSpeedMult:1.25,
        spawnsDomain:true,
        domainRadius:240,
        domainDpsMult:1.4,
        domainColor:"rgba(90,60,200,0.22)",
        domainEdgeColor:"rgba(210,180,255,0.95)"
      },
      ofa_100:{
        id:"ofa_100",
        name:"OFA 100%",
        cooldown:22,
        duration:5.5,
        damageMult:1.2,
        fireRateMult:1.5,
        speedMult:1.6
      },
      demon_mark:{
        id:"demon_mark",
        name:"Demon Mark",
        cooldown:26,
        duration:7,
        meleeDamageMult:2.3,
        meleeRangeMult:1.3,
        meleeHealBonus:1.2
      },
      gear_fifth:{
        id:"gear_fifth",
        name:"Gear Fifth",
        cooldown:28,
        duration:6,
        damageMult:1.5,
        fireRateMult:1.2,
        speedMult:1.3,
        bulletSpeedMult:1.2
      },
      susanoo_guardian:{
        id:"susanoo_guardian",
        name:"Susanoo Guardian",
        cooldown:28,
        duration:7,
        damageMult:1.25,
        speedMult:0.8,
        incomingDamageMult:0.5
      },
      cyber_sandevistan:{
        id:"cyber_sandevistan",
        name:"Cyber Sandevistan",
        cooldown:24,
        duration:5,
        speedMult:1.8,
        fireRateMult:1.3,
        incomingDamageMult:1.25
      },
      ghoul_rampage:{
        id:"ghoul_rampage",
        name:"Ghoul Rampage",
        cooldown:27,
        duration:6,
        meleeDamageMult:2.2,
        meleeRangeMult:1.3,
        meleeHealBonus:3
      },
      flame_domain:{
        id:"flame_domain",
        name:"Blazing Flame Ring",
        cooldown:26,
        duration:6,
        damageMult:1.2,
        fireRateMult:1.1,
        speedMult:1.05,
        spawnsDomain:true,
        domainRadius:230,
        domainDpsMult:1.3,
        domainColor:"rgba(255,140,80,0.24)",
        domainEdgeColor:"rgba(255,230,170,0.96)"
      },
      bankai_field:{
        id:"bankai_field",
        name:"Bankai Field",
        cooldown:28,
        duration:7,
        meleeDamageMult:1.8,
        meleeRangeMult:1.3,
        damageMult:1.15,
        fireRateMult:0.85,
        spawnsDomain:true,
        domainRadius:220,
        domainDpsMult:0,
        domainColor:"rgba(150,180,255,0.2)",
        domainEdgeColor:"rgba(220,230,255,0.96)"
      },
      haki_burst:{
        id:"haki_burst",
        name:"Conqueror's Haki Burst",
        cooldown:24,
        duration:4.5,
        damageMult:1.35,
        fireRateMult:1.15,
        spawnsDomain:true,
        domainRadius:260,
        domainDpsMult:0,
        domainColor:"rgba(255,245,180,0.24)",
        domainEdgeColor:"rgba(255,240,200,0.96)"
      },
      chimera_shadow_garden:{
        id:"chimera_shadow_garden",
        name:"Chimera Shadow Garden",
        cooldown:26,
        duration:6,
        damageMult:1.2,
        fireRateMult:1.1,
        speedMult:1.05,
        spawnsDomain:true,
        domainRadius:240,
        domainDpsMult:1.3,
        domainColor:"rgba(40,50,80,0.40)",
        domainEdgeColor:"rgba(190,220,255,0.96)"
      },
      thunder_god_avatar:{
        id:"thunder_god_avatar",
        name:"Thunder God Avatar",
        cooldown:26,
        duration:6,
        damageMult:1.3,
        fireRateMult:1.1,
        speedMult:1.35,
        bulletSpeedMult:1.15,
        incomingDamageMult:1.2
      },
      orbital_strike:{
        id:"orbital_strike",
        name:"Orbital Strike",
        cooldown:26,
        duration:5,
        damageMult:1.2,
        fireRateMult:1.05,
        spawnsDomain:true,
        domainRadius:260,
        domainDpsMult:1.6,
        domainColor:"rgba(255,200,140,0.22)",
        domainEdgeColor:"rgba(255,240,210,0.95)"
      }
    };

    /* ABILITIES & CURSES */

    const rarityOrder={common:0,rare:1,epic:2,legendary:3};

    function addNormalAbility(a){a.type="normal";normalAbilities.push(a);}
    function addBossAbility(a){a.type="boss";bossAbilities.push(a);}
    function addCurseAbility(c){c.type="curse";c.isCurse=true;curses.push(c);}

    function initAbilities(){
      normalAbilities.length=0;
      bossAbilities.length=0;
      curses.length=0;

      /* Normal abilities – Demon Slayer / JJK / One Piece / MHA / Cyberpunk / Solo Leveling */
      addNormalAbility({
        id:"water_breathing",
        name:"Water Breathing",
        rarity:"rare",
        description:"+ melee damage & range, - fire rate.",
        drawback:"Slower gun fire rate.",
        mods:{meleeDamageMult:1.4,meleeRangeMult:1.25,fireRateMult:0.88}
      });

      addNormalAbility({
        id:"thunder_breathing",
        name:"Thunder Breathing",
        rarity:"rare",
        description:"+ speed & fire rate, - max HP.",
        drawback:"Lose some max HP.",
        mods:{speedMult:1.25,fireRateMult:1.25,maxHpMult:0.8}
      });

      addNormalAbility({
        id:"sun_breathing",
        name:"Sun Breathing",
        rarity:"epic",
        description:"Huge damage, but you take more damage.",
        drawback:"Enemies hurt you more.",
        requires:["water_breathing","thunder_breathing"],
        mods:{damageMult:1.6,incomingDamageMult:1.25}
      });

      addNormalAbility({
        id:"gear_second",
        name:"Gear Second",
        rarity:"epic",
        description:"+ move & fire rate, - HP and dash cooldown up.",
        drawback:"More fragile & dash less often.",
        mods:{speedMult:1.35,fireRateMult:1.25,maxHpMult:0.8,dashCooldownMult:1.2}
      });

      addNormalAbility({
        id:"blood_edge",
        name:"Blood Edge",
        rarity:"rare",
        description:"Big melee damage boost, but you take more damage.",
        drawback:"You’re easier to kill.",
        mods:{meleeDamageMult:1.7,incomingDamageMult:1.25}
      });

      addNormalAbility({
        id:"black_flash_rhythm",
        name:"Black Flash Rhythm",
        rarity:"epic",
        description:"+ damage & Style gain, - bullet spread control.",
        drawback:"Less accurate.",
        mods:{damageMult:1.4,styleGainMult:1.8,spreadMult:1.3}
      });

      addNormalAbility({
        id:"quirk_booster",
        name:"Quirk Booster",
        rarity:"rare",
        description:"+ fire rate & bullets per shot, - damage.",
        drawback:"Weaker individual hits.",
        mods:{fireRateMult:1.35,bulletsPerShotAdd:1,damageMult:0.85}
      });

      addNormalAbility({
        id:"fire_force_spark",
        name:"Ignition Core",
        rarity:"rare",
        description:"+ bullet speed & Style gain, - heal after wave.",
        drawback:"Less healing after waves.",
        mods:{bulletSpeedMult:1.25,styleGainMult:1.4,healAfterWaveMult:0.6}
      });

      addNormalAbility({
        id:"shadow_garden",
        name:"Shadow Technique",
        rarity:"rare",
        description:"Summons a weak shadow that attacks nearby foes.",
        drawback:"Slightly less base damage.",
        mods:{damageMult:0.9,summonDpsMult:1.35},
        summonId:"shadow_wolf"
      });

      addNormalAbility({
        id:"survey_maneuvers",
        name:"ODM Maneuvers",
        rarity:"rare",
        description:"+ dash duration & move speed, - max HP.",
        drawback:"Lose some max HP.",
        mods:{dashDurationMult:1.3,speedMult:1.2,maxHpMult:0.9}
      });

      addNormalAbility({
        id:"spirit_chain",
        name:"Spirit Chain Shots",
        rarity:"rare",
        description:"+ bullets per shot, + spread.",
        drawback:"Less accurate.",
        mods:{bulletsPerShotAdd:1,spreadMult:1.4}
      });

      addNormalAbility({
        id:"gear_sniper",
        name:"Gear Sniper",
        rarity:"epic",
        description:"Sniper bullets – huge bullet speed & damage, - fire rate.",
        drawback:"Slower rate of fire.",
        requires:["spirit_chain"],
        mods:{bulletSpeedMult:1.6,damageMult:1.3,fireRateMult:0.7}
      });

      /* Dash mutations */
      addNormalAbility({
        id:"cursed_dash_bomb",
        name:"Cursed Dash Bomb",
        rarity:"rare",
        description:"Dash drops a cursed bomb that explodes.",
        drawback:"Dash cooldown slightly longer.",
        mods:{dashCooldownMult:1.15}
      });

      addNormalAbility({
        id:"flame_step",
        name:"Flame Step",
        rarity:"epic",
        description:"Dash leaves a burning trail that damages foes.",
        drawback:"You take a little more damage.",
        mods:{incomingDamageMult:1.1}
      });

      addNormalAbility({
        id:"blink_step",
        name:"Blink Step",
        rarity:"epic",
        description:"Very short cooldown dash, with shorter distance.",
        drawback:"Shorter dash duration.",
        mods:{dashCooldownMult:0.6,dashDurationMult:0.7,maxHpMult:0.95}
      });

      /* Toji / Nanami-flavoured normals */
      addNormalAbility({
        id:"nanami_ratio_strikes",
        name:"Ratio Strikes",
        rarity:"epic",
        description:"Melee damage + big, melee cooldown up.",
        drawback:"Slower melee swings.",
        mods:{meleeDamageMult:1.9,meleeCooldownMult:1.25}
      });

      addNormalAbility({
        id:"toji_anti_sorcerer",
        name:"Anti-Sorcerer Instincts",
        rarity:"epic",
        description:"General damage up, move speed up, - Style gain.",
        drawback:"Style builds slower.",
        mods:{damageMult:1.3,speedMult:1.2,styleGainMult:0.7}
      });

      addNormalAbility({
        id:"melee_guard_break",
        name:"Guard Breaker",
        rarity:"rare",
        description:"+ melee range & arc, - bullet damage.",
        drawback:"Bullets hit softer.",
        mods:{meleeRangeMult:1.2,meleeArcMult:1.15,damageMult:0.9}
      });

      addNormalAbility({
        id:"shadow_blade",
        name:"Shadow Blade",
        rarity:"epic",
        description:"Melee damage +, summons a small shadow slash.",
        drawback:"On-hit heal reduced.",
        requires:["shadow_garden"],
        mods:{meleeDamageMult:1.5,meleeOnHitHealAdd:-2,summonDpsMult:1.3},
        summonId:"shadow_blade_spirit"
      });

      /* Boss power-style legendaries */
      addBossAbility({
        id:"shadow_army_commander",
        name:"Shadow Army Commander",
        rarity:"legendary",
        description:"Summon a rotating squad of shadows. Big DPS, - base damage.",
        drawback:"Your own hits are weaker.",
        mods:{damageMult:0.8,summonDpsMult:1.8},
        summonId:"shadow_legion"
      });

      addBossAbility({
        id:"limitless_guard",
        name:"Limitless Guard",
        rarity:"legendary",
        description:"Massive damage reduction, - speed & fire rate.",
        drawback:"Sluggish & slower shooting.",
        mods:{incomingDamageMult:0.5,speedMult:0.8,fireRateMult:0.85}
      });

      addBossAbility({
        id:"king_of_curses",
        name:"King of Curses",
        rarity:"legendary",
        description:"+ huge damage & Style gain. Enemies tougher & more numerous.",
        drawback:"Enemies scale harder.",
        mods:{damageMult:1.5,styleGainMult:1.7},
        enemyMods:{enemyHpMult:1.25,enemyCountMult:1.25}
      });

      addBossAbility({
        id:"broken_limit",
        name:"Broken Limit",
        rarity:"legendary",
        description:"Remove cap on powers, but all future powers are weaker.",
        drawback:"Every ability has reduced effect.",
        mods:{maxHpMult:0.85,damageMult:0.85,fireRateMult:0.9,speedMult:0.9}
      });

      addBossAbility({
        id:"domain_specialist",
        name:"Domain Specialist",
        rarity:"epic",
        description:"+ Style gain, ult recharges faster but hits weaker.",
        drawback:"Weaker ult damage.",
        mods:{styleGainMult:1.4},
        ultMods:{damageMult:0.9}
      });

      /* CURSES – enemy scaling + hard penalties */
      addCurseAbility({
        id:"glass_cannon",
        name:"Glass Cannon",
        rarity:"epic",
        description:"+ big damage, enemies hurt more & shoot faster.",
        drawback:"Brutal punishment if hit.",
        mods:{damageMult:1.45,incomingDamageMult:1.4},
        enemyMods:{enemyBulletSpeedMult:1.2,enemyBulletDamageMult:1.2}
      });

      addCurseAbility({
        id:"curse_swarm",
        name:"Curse Swarm",
        rarity:"epic",
        description:"+ fire rate, enemies spawn more & move faster.",
        drawback:"More enemies, faster.",
        mods:{fireRateMult:1.25},
        enemyMods:{enemyCountMult:1.35,enemySpeedMult:1.2}
      });

      addCurseAbility({
        id:"swift_doom",
        name:"Swift Doom",
        rarity:"epic",
        description:"+ move speed, - max HP, enemies gain HP.",
        drawback:"Very fragile, tanky enemies.",
        mods:{speedMult:1.35,maxHpMult:0.7},
        enemyMods:{enemyHpMult:1.25}
      });

      addCurseAbility({
        id:"blood_pact",
        name:"Blood Pact",
        rarity:"epic",
        description:"+ on-hit heal & Style, enemies gain damage.",
        drawback:"Enemies hit much harder.",
        mods:{onHitHealAdd:2,meleeOnHitHealAdd:1,styleGainMult:1.4},
        enemyMods:{enemyDamageMult:1.4}
      });
    }

    /* SUMMONS */

    const SUMMON_DEFS={
      shadow_wolf:{
        orbitRadius:70,
        baseDps:18,
        color:"rgba(120,160,255,0.9)",
        radius:6
      },
      shadow_blade_spirit:{
        orbitRadius:60,
        baseDps:24,
        color:"rgba(200,160,255,0.95)",
        radius:5
      },
      shadow_legion:{
        orbitRadius:90,
        baseDps:36,
        color:"rgba(110,130,230,0.98)",
        radius:7,
        count:3
      }
    };

    function rebuildSummons(){
      summons=[];
      titanSummon=null;
      if(!player)return;

      const allIds=[...player.normalAbilities,...player.bossAbilities];
      let idx=0;
      for(const id of allIds){
        const ab=getAbilityById(id);
        if(!ab||!ab.summonId)continue;
        const def=SUMMON_DEFS[ab.summonId];
        if(!def)continue;
        const count=def.count||1;
        for(let i=0;i<count;i++){
          summons.push({
            id:ab.summonId,
            angle:(idx+i)*((Math.PI*2)/Math.max(1,count+2)),
            orbitRadius:def.orbitRadius||70,
            radius:def.radius||6,
            baseDps:def.baseDps||16,
            dps:def.baseDps||16,
            cooldown:0.3,
            cooldownTimer:Math.random()*0.3
          });
        }
        idx++;
      }
    }

    function updateSummons(dt){
      if(!player)return;
      const enemiesAlive=enemies.filter(e=>!e.dead);
      for(const s of summons){
        s.angle+=dt*1.6;
        const targetDist=s.orbitRadius;
        s.x=player.x+Math.cos(s.angle)*targetDist;
        s.y=player.y+Math.sin(s.angle)*targetDist;
        s.dps=s.baseDps*(player.summonDpsMult||1);

        s.cooldownTimer-=dt;
        if(s.cooldownTimer<=0 && enemiesAlive.length>0){
          s.cooldownTimer+=s.cooldown;
          let nearest=null,nd=99999;
          for(const e of enemiesAlive){
            const d=distance(s.x,s.y,e.x,e.y);
            if(d<nd){nd=d;nearest=e;}
          }
          if(nearest){
            const dmg=s.dps*dt*3;
            damageEnemy(nearest,dmg,s.x,s.y,true);
            spawnParticles(nearest.x,nearest.y,{
              count:4,speedMin:60,speedMax:160,
              color:s.color||"rgba(180,180,255,1)",
              sizeMin:1.4,sizeMax:2.6
            });
          }
        }
      }
    }

    function drawSummons(){
      for(const s of summons){
        ctx.save();
        ctx.shadowBlur=10;
        ctx.shadowColor=s.color||"rgba(150,180,255,0.9)";
        ctx.beginPath();
        ctx.arc(Math.round(s.x)+0.5,Math.round(s.y)+0.5,s.radius,0,Math.PI*2);
        ctx.fillStyle=s.color||"rgba(150,180,255,0.9)";
        ctx.fill();
        ctx.restore();
      }
    }

    /* UPGRADE / POWER-UP PANEL */

    let replaceTarget=null; // {category:"normal"|"boss", index:number}

    function abilityRarityClass(r){
      switch(r){
        case "rare":return "rarity-rare card-rarity-rare";
        case "epic":return "rarity-epic card-rarity-epic";
        case "legendary":return "rarity-legendary card-rarity-legendary";
        default:return "rarity-common card-rarity-common";
      }
    }

    function abilityRarityBadgeClass(r){
      switch(r){
        case "rare":return "rarityBadge rarity-rare";
        case "epic":return "rarityBadge rarity-epic";
        case "legendary":return "rarityBadge rarity-legendary";
        default:return "rarityBadge rarity-common";
      }
    }

    function playerHasAbility(id){
      if(!player)return false;
      return player.normalAbilities.includes(id)||player.bossAbilities.includes(id);
    }

    function canTakeAbility(def){
      if(!def)return false;
      if(def.type==="curse"){
        return !activeCurses.includes(def.id);
      }
      if(playerHasAbility(def.id))return false;
      if(def.requires){
        for(const req of def.requires){
          if(!playerHasAbility(req))return false;
        }
      }
      if(def.type==="normal"){
        const max=hasBrokenLimit()?99:5;
        if(player.normalAbilities.length>=max && !(replaceTarget && replaceTarget.category==="normal"))return false;
      }
      if(def.type==="boss"){
        const max=hasBrokenLimit()?99:2;
        if(player.bossAbilities.length>=max && !(replaceTarget && replaceTarget.category==="boss"))return false;
      }
      return true;
    }

    function shuffleInPlace(arr){
      for(let i=arr.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [arr[i],arr[j]]=[arr[j],arr[i]];
      }
    }

    function rollUpgradeOptions(isBossWave){
      const options=[];
      const poolNormal=normalAbilities.filter(a=>canTakeAbility(a));
      const poolBoss=bossAbilities.filter(a=>canTakeAbility(a));
      const poolCurses=curses.filter(a=>canTakeAbility(a));

      shuffleInPlace(poolNormal);
      shuffleInPlace(poolBoss);
      shuffleInPlace(poolCurses);

      function pickByRarity(pool,desiredCount){
        const picked=[];
        for(const r of ["legendary","epic","rare","common"]){
          for(const a of pool){
            if(picked.length>=desiredCount)break;
            if(a.rarity===r)picked.push(a);
          }
        }
        return picked;
      }

      if(!isBossWave){
        const normals=pickByRarity(poolNormal,3);
        options.push(...normals);
        if(options.length===0){
          const any=poolNormal[0]||poolBoss[0]||poolCurses[0]||null;
          if(any)options.push(any);
        }
        if(Math.random()<0.35 && poolCurses.length>0){
          options[Math.floor(Math.random()*options.length)]=poolCurses[0];
        }
      }else{
        if(poolBoss.length>0)options.push(poolBoss[0]);
        const normals=pickByRarity(poolNormal,2);
        options.push(...normals);
        if(poolCurses.length>0){
          options[Math.floor(Math.random()*options.length)]=poolCurses[0];
        }
      }

      while(options.length>3)options.pop();
      return options;
    }

    function openUpgradePanel(isBossWave){
      if(!player)return;
      gameState="upgrade";
      upgradePanel.style.display="flex";
      upgradesContainer.innerHTML="";
      const options=rollUpgradeOptions(isBossWave);
      if(options.length===0){
        closeUpgradePanel();
        return;
      }

      options.forEach(opt=>{
        const btn=document.createElement("button");
        btn.className="upgradeButton "+abilityRarityClass(opt.rarity);
        const rarityText=(opt.type==="curse")?"Curse":(opt.rarity||"Common");
        const top=document.createElement("div");
        top.className="upgradeTopRow";

        const nameSpan=document.createElement("span");
        nameSpan.className="upgradeName";
        nameSpan.textContent=opt.name;

        const rarSpan=document.createElement("span");
        rarSpan.className=abilityRarityBadgeClass(opt.rarity);
        rarSpan.textContent=rarityText;

        top.appendChild(nameSpan);
        top.appendChild(rarSpan);

        const desc=document.createElement("div");
        desc.className="upgradeDesc";
        const drawbackText=opt.drawback?(" Drawback: "+opt.drawback):"";
        desc.textContent=(opt.description||"")+drawbackText;

        btn.appendChild(top);
        btn.appendChild(desc);

        btn.addEventListener("click",()=>{
          applyAbilityPick(opt);
          closeUpgradePanel();
        });

        upgradesContainer.appendChild(btn);
      });

      skipButton.onclick=()=>{
        closeUpgradePanel();
      };
    }

    // closeUpgradePanel uses awaitingWaveStart / startNextWave defined later
    function closeUpgradePanel(){
      upgradePanel.style.display="none";
      replaceTarget=null;
      if(gameState!=="gameover" && gameState!=="menu"){
        gameState="playing";
        if(awaitingWaveStart){
          startNextWave();
        }
      }
    }

    function applyAbilityPick(def){
      if(!def||!player)return;
      if(def.type==="curse"){
        if(!activeCurses.includes(def.id)){
          activeCurses.push(def.id);
          cosmeticStats.cursesTaken++;
          saveCosmeticStats();
        }
      }else if(def.type==="boss"){
        const max=hasBrokenLimit()?99:2;
        if(replaceTarget && replaceTarget.category==="boss" && player.bossAbilities[replaceTarget.index]!=null){
          player.bossAbilities[replaceTarget.index]=def.id;
        }else if(player.bossAbilities.length<max){
          player.bossAbilities.push(def.id);
        }else if(player.bossAbilities.length>0){
          player.bossAbilities[player.bossAbilities.length-1]=def.id;
        }
      }else{
        const max=hasBrokenLimit()?99:5;
        if(replaceTarget && replaceTarget.category==="normal" && player.normalAbilities[replaceTarget.index]!=null){
          player.normalAbilities[replaceTarget.index]=def.id;
        }else if(player.normalAbilities.length<max){
          player.normalAbilities.push(def.id);
        }else if(player.normalAbilities.length>0){
          player.normalAbilities[player.normalAbilities.length-1]=def.id;
        }
      }

      if(def.type!=="curse")showMessage(def.name+" chosen!",1.6);
      else showMessage("Curse taken: "+def.name,1.8);

      recomputePlayerStats(true);
      recomputeEnemyScale();
      rebuildSummons();
      refreshAbilityBar();
      checkCosmeticUnlocks();
    }

    function refreshAbilityBar(){
      normalAbilitiesListEl.innerHTML="";
      bossAbilitiesListEl.innerHTML="";
      if(!player)return;

      player.normalAbilities.forEach((id,idx)=>{
        const def=getAbilityById(id);
        const slot=document.createElement("div");
        slot.className="abilitySlot "+abilityRarityClass(def?.rarity||"common").replace("rarity-","").replace("card-","");
        slot.textContent=def?def.name:id;
        slot.title="Click to mark this normal power for replacement next pick.";
        slot.addEventListener("click",()=>{
          replaceTarget={category:"normal",index:idx};
          showMessage("Marked '"+(def?def.name:id)+"' to be replaced.",1.7);
        });
        normalAbilitiesListEl.appendChild(slot);
      });

      player.bossAbilities.forEach((id,idx)=>{
        const def=getAbilityById(id);
        const slot=document.createElement("div");
        slot.className="abilitySlot "+abilityRarityClass(def?.rarity||"epic").replace("rarity-","").replace("card-","");
        slot.textContent=def?def.name:id;
        slot.title="Click to mark this boss power for replacement next pick.";
        slot.addEventListener("click",()=>{
          replaceTarget={category:"boss",index:idx};
          showMessage("Marked '"+(def?def.name:id)+"' to be replaced.",1.7);
        });
        bossAbilitiesListEl.appendChild(slot);
      });
    }
    /* ENEMIES, WAVES, BOSSES */

    let awaitingWaveStart=false;

    function isBossWave(w){return w>0 && w%5===0;}

    function chooseWaveEvent(w){
      if(w>0 && w%7===0)return "blood_moon";
      if(w>0 && w%6===0)return "curse_storm";
      return null;
    }

    function spawnEnemyOfType(type){
      const margin=40;
      const side=Math.floor(Math.random()*4);
      let x,y;
      if(side===0){x=-margin;y=Math.random()*canvas.height;}
      else if(side===1){x=canvas.width+margin;y=Math.random()*canvas.height;}
      else if(side===2){x=Math.random()*canvas.width;y=-margin;}
      else{x=Math.random()*canvas.width;y=canvas.height+margin;}

      let radius=10,hpBase=40,speedBase=80,contactBase=12,color="#ff5e8a";
      let shooter=false;

      if(type==="shooter"){
        radius=9;hpBase=46;speedBase=70;contactBase=10;color="#ffcf73";shooter=true;
      }else if(type==="brute"){
        radius=13;hpBase=115;speedBase=55;contactBase=20;color="#ff8e4a";
      }

      const wv=Math.max(1,wave);
      const waveHpMult=1+(wv-1)*0.18;
      const waveSpeedMult=1+(wv-1)*0.045;
      const waveDamageMult=1+(wv-1)*0.06;

      const hp=hpBase*waveHpMult*enemyScale.hpMult;
      const speed=speedBase*waveSpeedMult*enemyScale.speedMult;
      const contactDamage=contactBase*waveDamageMult*enemyScale.damageMult;

      const e={
        id:enemyIdCounter++,
        x,y,radius,
        vx:0,vy:0,
        hp:hp,
        maxHp:hp,
        speed:speed,
        contactDamage,
        color,
        dead:false,
        type,
        miniBoss:false,
        shootCooldown:shooter?(1.4-Math.min(0.7,(wv-1)*0.03)):0,
        shootTimer:shooter?Math.random()*0.6:0,
        bulletSpeed:shooter?260*enemyScale.bulletSpeedMult:0,
        bulletDamage:shooter?(10*enemyScale.bulletDamageMult):0
      };
      enemies.push(e);
    }

    function spawnMiniBoss(w){
      if(MINI_BOSS_TEMPLATES.length===0)return;
      const t=MINI_BOSS_TEMPLATES[Math.floor(Math.random()*MINI_BOSS_TEMPLATES.length)];
      const baseHp=260+w*45;
      const hp=baseHp*enemyScale.hpMult;
      const e={
        id:enemyIdCounter++,
        x:canvas.width*Math.random(),
        y:canvas.height*0.25,
        radius:16,
        vx:0,vy:0,
        hp:hp,
        maxHp:hp,
        speed:(90+w*3)*enemyScale.speedMult,
        contactDamage:18*enemyScale.damageMult,
        color:t.color,
        dead:false,
        type:"miniBoss",
        miniBoss:true,
        bossId:t.id,
        name:t.name,
        shootCooldown:1.8,
        shootTimer:1,
        bulletSpeed:260*enemyScale.bulletSpeedMult,
        bulletDamage:12*enemyScale.bulletDamageMult,
        pattern:t.pattern||"cone",
        patternTimer:0
      };
      enemies.push(e);
      showMessage(t.name+" joins the battle!",2.3);
    }

    function spawnBossForWave(w){
      if(BOSS_TEMPLATES.length===0)return;
      const idx=(Math.floor((w-1)/5))%BOSS_TEMPLATES.length;
      const t=BOSS_TEMPLATES[idx];
      const baseHp=650+Math.floor(w/5)*160;
      const hp=baseHp*enemyScale.hpMult;
      const boss={
        id:enemyIdCounter++,
        x:canvas.width/2,
        y:canvas.height*0.25,
        radius:22,
        vx:0,vy:0,
        hp:hp,
        maxHp:hp,
        speed:(80+w*2)*enemyScale.speedMult,
        contactDamage:25*enemyScale.damageMult,
        color:t.color,
        dead:false,
        type:"boss",
        isBoss:true,
        bossId:t.id,
        name:t.name,
        shootTimer:1.5,
        bossTimer:0,
        state:null
      };
      enemies.push(boss);
      showMessage(t.name+" appears!",3);
    }

    function spawnWaveEnemiesForCurrent(){
      const wv=Math.max(1,wave);
      const boss=isBossWave(wv);
      const event=currentWaveEvent;

      let baseCount=boss?Math.max(3,5+Math.floor((wv-1)*0.8)):5+Math.floor((wv-1)*1.25);
      let enemyCount=Math.floor(baseCount*enemyScale.countMult);
      if(event==="blood_moon")enemyCount=Math.floor(enemyCount*1.4);
      if(event==="curse_storm")enemyCount=Math.floor(enemyCount*1.2);

      if(boss){
        spawnBossForWave(wv);
        enemyCount=Math.floor(enemyCount*0.6);
      }else if(wv>=3 && wv%5===3){
        spawnMiniBoss(wv);
        enemyCount=Math.floor(enemyCount*0.8);
      }

      for(let i=0;i<enemyCount;i++){
        let type="grunt";
        if(wv>=3 && Math.random()<0.35)type="shooter";
        if(wv>=7 && Math.random()<0.25)type="brute";
        spawnEnemyOfType(type);
      }

      let label="Wave "+wv;
      if(boss)label+=" – Boss";
      if(event==="blood_moon")label+=" (Blood Moon)";
      else if(event==="curse_storm")label+=" (Curse Storm)";
      showMessage(label,2.5);
    }

    function startNextWave(){
      if(!player)return;
      wave++;
      cosmeticStats.maxWaveEver=Math.max(cosmeticStats.maxWaveEver,wave);
      saveCosmeticStats();
      checkCosmeticUnlocks();

      currentWaveEvent=chooseWaveEvent(wave);
      awaitingWaveStart=false;

      bullets.length=0;
      enemyBullets.length=0;
      enemies.length=0;

      spawnWaveEnemiesForCurrent();
    }

    function onWaveCleared(){
      if(!player)return;
      if(gameState!=="playing")return;
      awaitingWaveStart=true;

      let heal=player.healAfterWave*(player.healAfterWaveMult||1);
      player.hp=clamp(player.hp+heal,0,player.maxHp);

      const upcomingWave=wave+1;
      const isBoss=isBossWave(upcomingWave);
      openUpgradePanel(isBoss);
    }

    function tryEndWave(){
      if(gameState!=="playing")return;
      if(enemies.length===0 && enemyBullets.length===0){
        onWaveCleared();
      }
    }

    /* ENEMY BULLETS & DAMAGE */

    function spawnEnemyBullet(x,y,angle,speed,damage){
      const b={
        x,y,
        vx:Math.cos(angle)*speed,
        vy:Math.sin(angle)*speed,
        radius:4,
        damage,
        life:3.2
      };
      enemyBullets.push(b);
    }

    function spawnEnemyShotAtPlayer(e){
      if(!player)return;
      const angle=Math.atan2(player.y-e.y,player.x-e.x);
      const speed=e.bulletSpeed||260*enemyScale.bulletSpeedMult;
      const dmg=e.bulletDamage||10*enemyScale.bulletDamageMult;
      spawnEnemyBullet(e.x,e.y,angle,speed,dmg);
    }

    function applyPlayerDamage(amount){
      if(!player)return;
      if(gameState!=="playing")return;
      if(player.isDashing)return;
      let dmg=amount*(player.incomingDamageMult||1);
      if(player.ultActiveTimer>0){
        const def=ULT_DEFS[player.ultId];
        if(def && def.incomingDamageMult)dmg*=def.incomingDamageMult;
      }
      if(dmg<=0)return;
      player.hp-=dmg;
      addScreenShake(3,0.12);
      spawnParticles(player.x,player.y,{
        count:10,speedMin:50,speedMax:160,
        color:"rgba(255,120,120,0.95)"
      });
      if(player.hp<=0){
        player.hp=0;
        handlePlayerDeath();
      }
    }

    function handlePlayerDeath(){
      gameState="gameover";
      domainField.active=false;
      showMessage("You fell. Press R to try again.",4);
    }

    function damageEnemy(e,amount,hitX,hitY,fromSummon=false){
      if(!e || e.dead)return;
      let dmg=amount;
      if(e.isBoss && e.bossId==="gojo"){
        dmg*=0.8;
      }
      e.hp-=dmg;
      spawnParticles(hitX,hitY,{
        count:6,speedMin:80,speedMax:180,
        sizeMin:1.6,sizeMax:3,
        color:"rgba(255,235,255,0.95)"
      });
      if(e.hp<=0){
        e.dead=true;
        onEnemyKilled(e);
      }
    }

    function onEnemyKilled(e){
      spawnParticles(e.x,e.y,{
        count:e.isBoss?28:14,
        speedMin:80,speedMax:260,
        sizeMin:2.2,sizeMax:4,
        color:e.color||"rgba(255,200,200,1)"
      });
      addScreenShake(e.isBoss?6:3,e.isBoss?0.25:0.12);
      const styleGain=(e.isBoss?18:6)*(player.styleGainMult||1);
      player.styleMeter=clamp(player.styleMeter+styleGain,0,player.styleMax);

      if(e.isBoss){
        cosmeticStats.bossesKilled++;
        if(playerHasAbility("shadow_army_commander")){
          cosmeticStats.defeatedBossWithShadowCommanderOnce=true;
        }
        saveCosmeticStats();
        checkCosmeticUnlocks();
      }
    }

    function updateEnemyBullets(dt){
      for(let i=enemyBullets.length-1;i>=0;i--){
        const b=enemyBullets[i];
        b.life-=dt;
        b.x+=b.vx*dt;
        b.y+=b.vy*dt;
        if(b.life<=0 || b.x<-40 || b.x>canvas.width+40 || b.y<-40 || b.y>canvas.height+40){
          enemyBullets.splice(i,1);
          continue;
        }
        if(player){
          const d=distance(b.x,b.y,player.x,player.y);
          if(d<b.radius+player.radius){
            applyPlayerDamage(b.damage);
            enemyBullets.splice(i,1);
            continue;
          }
        }
      }
    }

    function updateNormalEnemy(e,dt){
      if(!player)return;
      const dx=player.x-e.x,dy=player.y-e.y;
      const dist=Math.hypot(dx,dy)||1;
      let speed=e.speed;

      let slowFactor=1;
      for(const f of slowFields){
        const d2=distance(e.x,e.y,f.x,f.y);
        if(d2<f.radius){slowFactor=0.6;break;}
      }
      speed*=slowFactor;

      if(e.miniBoss){
        e.patternTimer+=dt;
        if(e.pattern==="cone"){
          if(dist>220)e.x+=dx/dist*speed*dt;
          else if(dist<160)e.x-=dx/dist*speed*dt;
          e.shootTimer-=dt;
          if(e.shootTimer<=0){
            e.shootTimer=e.shootCooldown;
            const baseAngle=Math.atan2(dy,dx);
            const spread=0.7;
            for(let i=-2;i<=2;i++){
              const ang=baseAngle+i*(spread/4);
              spawnEnemyBullet(e.x,e.y,ang,e.bulletSpeed,e.bulletDamage);
            }
          }
        }else if(e.pattern==="rush"){
          if(dist>140){e.x+=dx/dist*speed*dt;e.y+=dy/dist*speed*dt;}
          e.shootTimer-=dt;
          if(e.shootTimer<=0){
            e.shootTimer=e.shootCooldown;
            const shots=8;
            for(let i=0;i<shots;i++){
              const ang=Math.random()*Math.PI*2;
              spawnEnemyBullet(e.x,e.y,ang,e.bulletSpeed*1.1,e.bulletDamage);
            }
          }
        }else if(e.pattern==="spin"){
          if(dist>220){e.x+=dx/dist*speed*dt;e.y+=dy/dist*speed*dt;}
          e.patternTimer+=dt;
          if(e.patternTimer>1.6){
            e.patternTimer=0;
            const shots=14;
            for(let i=0;i<shots;i++){
              const ang=(Math.PI*2)*(i/shots);
              spawnEnemyBullet(e.x,e.y,ang,e.bulletSpeed,e.bulletDamage);
            }
          }
        }
      }else{
        if(e.type==="grunt" || e.type==="brute"){
          if(dist>5){
            e.x+=dx/dist*speed*dt;
            e.y+=dy/dist*speed*dt;
          }
        }else if(e.type==="shooter"){
          const desired=260;
          if(dist>desired+10){
            e.x+=dx/dist*speed*dt;
            e.y+=dy/dist*speed*dt;
          }else if(dist<desired-10){
            e.x-=dx/dist*speed*dt;
            e.y-=dy/dist*speed*dt;
          }
          e.shootTimer-=dt;
          if(e.shootTimer<=0){
            e.shootTimer=e.shootCooldown;
            spawnEnemyShotAtPlayer(e);
          }
        }
      }

      e.x=clamp(e.x,e.radius,canvas.width-e.radius);
      e.y=clamp(e.y,e.radius,canvas.height-e.radius);
    }

    function updateBoss(e,dt){
      if(!player)return;
      const dx=player.x-e.x,dy=player.y-e.y;
      const dist=Math.hypot(dx,dy)||1;
      const baseSpeed=e.speed;
      e.bossTimer+=dt;
      e.shootTimer-=dt;

      switch(e.bossId){
        case "mahito":{
          const targetRange=200;
          if(dist>targetRange+20){
            e.x+=dx/dist*baseSpeed*dt;
            e.y+=dy/dist*baseSpeed*dt;
          }else if(dist<targetRange-20){
            e.x-=dx/dist*baseSpeed*dt;
            e.y-=dy/dist*baseSpeed*dt;
          }
          if(e.shootTimer<=0){
            e.shootTimer=2.4;
            const shots=12;
            for(let i=0;i<shots;i++){
              const ang=(Math.PI*2)*(i/shots);
              spawnEnemyBullet(e.x,e.y,ang,230*enemyScale.bulletSpeedMult,12*enemyScale.bulletDamageMult);
            }
          }
          break;
        }
        case "itachi":{
          const targetRange=240;
          if(dist>targetRange){
            e.x+=dx/dist*baseSpeed*dt;
            e.y+=dy/dist*baseSpeed*dt;
          }
          if(e.shootTimer<=0){
            e.shootTimer=1.7;
            const baseAngle=Math.atan2(dy,dx);
            const spread=0.5;
            for(let i=-2;i<=2;i++){
              const ang=baseAngle+i*(spread/4);
              spawnEnemyBullet(e.x,e.y,ang,260*enemyScale.bulletSpeedMult,11*enemyScale.bulletDamageMult);
            }
          }
          if(bossGenjutsuTimer<=0 && e.bossTimer>7){
            bossGenjutsuTimer=GENJUTSU_DURATION;
            e.bossTimer=0;
            showMessage("Itachi cast Tsukuyomi – senses distorted!",3);
          }
          break;
        }
        case "gojo":{
          const targetX=canvas.width/2,targetY=canvas.height/2;
          const dxg=targetX-e.x,dyg=targetY-e.y;
          const distg=Math.hypot(dxg,dyg)||1;
          if(distg>15){
            e.x+=dxg/distg*baseSpeed*dt;
            e.y+=dyg/distg*baseSpeed*dt;
          }
          if(e.shootTimer<=0){
            e.shootTimer=2.8;
            const shots=20;
            for(let i=0;i<shots;i++){
              const ang=(Math.PI*2)*(i/shots);
              spawnEnemyBullet(e.x,e.y,ang,260*enemyScale.bulletSpeedMult,10*enemyScale.bulletDamageMult);
            }
          }
          break;
        }
        case "luffy":{
          if(!e.chargeTimer)e.chargeTimer=0;
          e.chargeTimer+=dt;
          if(e.chargeTimer>4){
            e.chargeTimer=0;
            e.state="charge";
            e.stateTimer=0.7;
            e.chargeAngle=Math.atan2(dy,dx);
          }
          if(e.state==="charge"){
            e.stateTimer-=dt;
            const chargeSpeed=baseSpeed*2.5;
            e.x+=Math.cos(e.chargeAngle)*chargeSpeed*dt;
            e.y+=Math.sin(e.chargeAngle)*chargeSpeed*dt;
            if(e.stateTimer<=0)e.state=null;
          }else{
            if(dist>160){
              e.x+=dx/dist*baseSpeed*dt;
              e.y+=dy/dist*baseSpeed*dt;
            }
          }
          if(e.shootTimer<=0){
            e.shootTimer=2.2;
            const baseAngleL=Math.atan2(dy,dx);
            for(let i=-1;i<=1;i++){
              const ang=baseAngleL+i*0.18;
              spawnEnemyBullet(e.x,e.y,ang,240*enemyScale.bulletSpeedMult,12*enemyScale.bulletDamageMult);
            }
          }
          break;
        }
      }

      e.x=clamp(e.x,e.radius,canvas.width-e.radius);
      e.y=clamp(e.y,e.radius,canvas.height-e.radius);
    }

    function updateEnemies(dt){
      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        if(e.dead){enemies.splice(i,1);continue;}
        if(e.isBoss)updateBoss(e,dt);
        else updateNormalEnemy(e,dt);

        if(!player)continue;
        const d=distance(e.x,e.y,player.x,player.y);
        if(d<e.radius+player.radius){
          if(e.isBoss && e.bossId==="mahito"){
            if(player.mahitoTouchStacks>=1){
              player.mahitoTouchStacks=2;
              showMessage("Mahito reshaped your soul – instant death.",3.2);
              applyPlayerDamage(9999);
            }else{
              player.mahitoTouchStacks=1;
              showMessage("Mahito touched your soul (1/2).",2.3);
              applyPlayerDamage(e.contactDamage*0.4);
            }
          }else{
            applyPlayerDamage(e.contactDamage);
          }
          const ang=Math.atan2(player.y-e.y,player.x-e.x);
          e.x-=Math.cos(ang)*6;
          e.y-=Math.sin(ang)*6;
        }
      }
    }

    /* PLAYER SHOOT, MELEE, DASH, ULT, DOMAIN */

    function getEffectiveGunStats(){
      if(!player)return null;
      let dmg=player.damage;
      let fireRate=player.fireRate;
      let bulletSpeed=player.bulletSpeed;
      let pierce=player.pierce;
      let spread=player.spread;

      if(player.ultActiveTimer>0){
        const def=ULT_DEFS[player.ultId];
        if(def){
          if(def.damageMult)dmg*=def.damageMult;
          if(def.fireRateMult)fireRate*=def.fireRateMult;
          if(def.bulletSpeedMult)bulletSpeed*=def.bulletSpeedMult;
          if(def.pierceBonus)pierce+=def.pierceBonus;
        }
      }
      if(bossGenjutsuTimer>0){
        dmg*=0.9;
        fireRate*=0.9;
        bulletSpeed*=0.85;
        spread*=1.3;
      }
      return{dmg,fireRate,bulletSpeed,pierce,spread};
    }

    function getEffectiveMeleeStats(){
      if(!player)return null;
      let dmg=player.meleeDamage;
      let range=player.meleeRange;
      let arc=player.meleeArc;
      if(player.ultActiveTimer>0){
        const def=ULT_DEFS[player.ultId];
        if(def){
          if(def.meleeDamageMult)dmg*=def.meleeDamageMult;
          if(def.meleeRangeMult)range*=def.meleeRangeMult;
          if(def.damageMult)dmg*=def.damageMult;
        }
      }
      if(bossGenjutsuTimer>0){
        dmg*=0.9;
        range*=0.9;
      }
      return{dmg,range,arc};
    }

    function spawnPlayerBullet(angle,eStats){
      const bSpeed=eStats.bulletSpeed;
      const dmg=eStats.dmg;
      const radius=3.5;
      const b={
        x:player.x,
        y:player.y,
        vx:Math.cos(angle)*bSpeed,
        vy:Math.sin(angle)*bSpeed,
        radius,
        damage:dmg,
        pierce:player.pierce,
        life:2.1
      };
      bullets.push(b);
    }

    function handleShooting(dt){
      if(!player)return;
      const gun=getEffectiveGunStats();
      if(!gun)return;
      player.shootTimer-=dt;
      if(mouseDown){
        const fireRate=Math.max(0.3,gun.fireRate);
        const interval=1/fireRate;
        while(player.shootTimer<=0){
          player.shootTimer+=interval;
          const baseAngle=Math.atan2(mousePos.y-player.y,mousePos.x-player.x);
          const count=Math.max(1,player.bulletsPerShot);
          for(let i=0;i<count;i++){
            const t=(count===1)?0:(i/(count-1)-0.5);
            const spreadAmount=gun.spread;
            const angle=baseAngle+t*spreadAmount+(Math.random()-0.5)*spreadAmount*0.3;
            spawnPlayerBullet(angle,gun);
          }
        }
      }else{
        if(player.shootTimer>0)player.shootTimer=Math.min(player.shootTimer,0.1);
      }
    }

    function updateBullets(dt){
      for(let i=bullets.length-1;i>=0;i--){
        const b=bullets[i];
        b.life-=dt;
        b.x+=b.vx*dt;
        b.y+=b.vy*dt;
        if(b.life<=0 || b.x<-40 || b.x>canvas.width+40 || b.y<-40 || b.y>canvas.height+40){
          bullets.splice(i,1);
          continue;
        }
        addBulletTrailFX(b);
        for(let j=enemies.length-1;j>=0;j--){
          const e=enemies[j];
          if(e.dead)continue;
          const d=distance(b.x,b.y,e.x,e.y);
          if(d<b.radius+e.radius){
            damageEnemy(e,b.damage,b.x,b.y,false);
            if(player.onHitHeal>0){
              player.hp=clamp(player.hp+player.onHitHeal,0,player.maxHp);
            }
            b.pierce--;
            if(b.pierce<0){
              bullets.splice(i,1);
              break;
            }
          }
        }
      }
    }

    function tryMeleeAttack(){
      if(!player)return;
      if(player.meleeCooldownTimer>0)return;
      const m=getEffectiveMeleeStats();
      if(!m)return;
      player.meleeCooldownTimer=player.meleeCooldown;
      player.meleeSwingTimer=player.meleeSwingDuration;
      const dx=mousePos.x-player.x;
      const dy=mousePos.y-player.y;
      player.meleeAngle=Math.atan2(dy,dx);
      addScreenShake(3,0.12);

      let hits=0;
      for(const e of enemies){
        if(e.dead)continue;
        const dist=distance(player.x,player.y,e.x,e.y);
        if(dist>m.range+e.radius)continue;
        const angToEnemy=Math.atan2(e.y-player.y,e.x-player.x);
        const diff=angleDiff(angToEnemy,player.meleeAngle);
        if(Math.abs(diff)<=m.arc*0.5){
          damageEnemy(e,m.dmg,e.x,e.y,false);
          hits++;
        }
      }
      if(hits>0){
        const healAmount=player.meleeOnHitHeal*hits;
        if(healAmount>0){
          player.hp=clamp(player.hp+healAmount,0,player.maxHp);
        }
      }
    }

    function spawnDashTrailParticles(x,y,blink){
      const color=getDashParticleColor();
      spawnParticles(x,y,{
        count:blink?16:10,
        speedMin:80,speedMax:200,
        lifeMin:.2,lifeMax:.5,
        sizeMin:2,sizeMax:4,
        color
      });
    }

    function startDash(){
      if(!player)return;
      if(player.dashCooldownTimer>0 || player.isDashing)return;

      let dx=0,dy=0;
      if(keys["w"]||keys["arrowup"])dy-=1;
      if(keys["s"]||keys["arrowdown"])dy+=1;
      if(keys["a"]||keys["arrowleft"])dx-=1;
      if(keys["d"]||keys["arrowright"])dx+=1;
      let mag=Math.hypot(dx,dy);
      if(mag===0){
        dx=mousePos.x-player.x;
        dy=mousePos.y-player.y;
        mag=Math.hypot(dx,dy)||1;
      }
      dx/=mag;dy/=mag;

      cosmeticStats.totalDashes++;
      saveCosmeticStats();
      checkCosmeticUnlocks();

      if(player.dashMode==="blink"){
        const distanceDash=player.speed*player.dashDuration*2.3;
        player.x=clamp(player.x+dx*distanceDash,player.radius,canvas.width-player.radius);
        player.y=clamp(player.y+dy*distanceDash,player.radius,canvas.height-player.radius);
        player.dashCooldownTimer=player.dashCooldown;
        spawnDashTrailParticles(player.x,player.y,true);
        addScreenShake(2,0.15);
        addWhiteFlash(0.3);
        slowFields.push({x:player.x,y:player.y,radius:120,life:2});
        return;
      }

      const dashSpeed=player.speed*3.3;
      player.isDashing=true;
      player.dashActiveTimer=player.dashDuration;
      player.dashCooldownTimer=player.dashCooldown;
      player.dashVelX=dx*dashSpeed;
      player.dashVelY=dy*dashSpeed;
      spawnDashTrailParticles(player.x,player.y,false);

      if(player.dashMode==="bomb"){
        playerBombs.push({x:player.x,y:player.y,radius:0,maxRadius:90,life:0.4,exploded:false});
      }else if(player.dashMode==="flame"){
        fireBursts.push({x:player.x,y:player.y,radius:70,life:1.4});
      }
    }

    function tryUseUlt(){
      if(!player)return;
      const def=ULT_DEFS[player.ultId];
      if(!def)return;
      if(!player.ultReady)return;
      if(player.ultActiveTimer>0)return;

      player.ultReady=false;
      player.ultActiveTimer=def.duration;
      player.ultCooldownTimer=def.cooldown;
      addWhiteFlash(0.45);
      addScreenShake(4.5,0.3);
      showMessage(def.name+" activated!",2);

      spawnParticles(player.x,player.y,{
        count:40,
        speedMin:150,speedMax:320,
        sizeMin:2,sizeMax:5,
        color:"rgba(255,255,255,1)"
      });

      if(def.spawnsDomain){
        domainField.active=true;
        domainField.x=player.x;
        domainField.y=player.y;
        domainField.radius=def.domainRadius||220;
        domainField.type=def.id;
        domainField.color=def.domainColor||"rgba(90,60,200,0.25)";
        domainField.edgeColor=def.domainEdgeColor||"rgba(210,180,255,0.95)";
        domainField.dpsMult=def.domainDpsMult||0;
        cosmeticStats.totalDomainsCast++;
        saveCosmeticStats();
        checkCosmeticUnlocks();
      }
    }

    function updateUltState(dt){
      if(!player)return;
      const def=ULT_DEFS[player.ultId];
      if(player.ultActiveTimer>0){
        player.ultActiveTimer-=dt;
        if(player.ultActiveTimer<=0){
          player.ultActiveTimer=0;
          domainField.active=false;
        }
      }else{
        if(player.ultCooldownTimer>0){
          player.ultCooldownTimer-=dt;
          if(player.ultCooldownTimer<=0){
            player.ultCooldownTimer=0;
            player.ultReady=true;
            if(def)showMessage(def.name+" ready!",1.6);
          }
        }
      }
    }

    function updateDomainField(dt){
      if(!domainField.active)return;
      if(player){
        domainField.x+=(player.x-domainField.x)*0.08;
        domainField.y+=(player.y-domainField.y)*0.08;
      }
      if(domainField.dpsMult>0 && player){
        const dps=player.damage*domainField.dpsMult;
        for(const e of enemies){
          if(e.dead)continue;
          const d=distance(e.x,e.y,domainField.x,domainField.y);
          if(d<domainField.radius+e.radius){
            damageEnemy(e,dps*dt,e.x,e.y,false);
          }
        }
      }
    }

    function updateBombs(dt){
      for(let i=playerBombs.length-1;i>=0;i--){
        const b=playerBombs[i];
        b.life-=dt;
        if(!b.exploded && b.life<=0){
          b.exploded=true;
          addScreenShake(5,0.2);
          addWhiteFlash(0.35);
          for(const e of enemies){
            if(e.dead)continue;
            const d=distance(e.x,e.y,b.x,b.y);
            if(d<b.maxRadius+e.radius){
              damageEnemy(e,player.damage*2.2,b.x,b.y,false);
            }
          }
        }
        if(b.exploded){
          b.radius=Math.min(b.maxRadius,b.radius+dt*260);
        }
        if(b.life<-0.3){
          playerBombs.splice(i,1);
        }
      }
    }

    function updateFireBursts(dt){
      for(let i=fireBursts.length-1;i>=0;i--){
        const f=fireBursts[i];
        f.life-=dt;
        if(f.life<=0){fireBursts.splice(i,1);continue;}
        for(const e of enemies){
          if(e.dead)continue;
          const d=distance(e.x,e.y,f.x,f.y);
          if(d<f.radius+e.radius){
            damageEnemy(e,player.damage*3*dt,f.x,f.y,false);
          }
        }
      }
    }
    function drawDomainField(){
      if(!domainField.active)return;
      const r=domainField.radius;
      const t=bgTime*0.7;
      const pulsate=1+Math.sin(t*2)*0.04;
      const pr=r*pulsate;

      const g=ctx.createRadialGradient(
        domainField.x,domainField.y,pr*0.2,
        domainField.x,domainField.y,pr
      );
      g.addColorStop(0,domainField.color||"rgba(90,60,200,0.25)");
      g.addColorStop(1,"rgba(0,0,0,0)");
      ctx.save();
      ctx.shadowBlur=18;
      ctx.shadowColor=domainField.edgeColor||"rgba(210,180,255,0.9)";
      ctx.beginPath();
      ctx.arc(domainField.x,domainField.y,pr,0,Math.PI*2);
      ctx.fillStyle=g;
      ctx.fill();

      ctx.beginPath();
      ctx.arc(domainField.x,domainField.y,pr,0,Math.PI*2);
      ctx.strokeStyle=domainField.edgeColor||"rgba(210,180,255,0.95)";
      ctx.lineWidth=2.5;
      ctx.stroke();

      // rotating "rune" lines
      ctx.translate(domainField.x,domainField.y);
      ctx.rotate(bgTime*0.8);
      ctx.strokeStyle="rgba(255,255,255,0.28)";
      ctx.lineWidth=1;
      const r2=pr*0.7;
      for(let i=0;i<8;i++){
        const a=(Math.PI*2*i)/8;
        ctx.beginPath();
        ctx.moveTo(Math.cos(a)*(r2-8),Math.sin(a)*(r2-8));
        ctx.lineTo(Math.cos(a)*r2,Math.sin(a)*r2);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawSlowFields(){
      for(const f of slowFields){
        const t=clamp(f.life/2,0,1);
        ctx.beginPath();
        ctx.arc(f.x,f.y,f.radius,0,Math.PI*2);
        ctx.strokeStyle=`rgba(150,210,255,${0.45*t})`;
        ctx.lineWidth=2;
        ctx.stroke();
      }
    }

    function drawBombs(){
      for(const b of playerBombs){
        const baseLife=0.4;
        const t=clamp((b.life+baseLife)/baseLife,0,1);
        const r=b.exploded?b.radius:18+32*(1-t);
        const g=ctx.createRadialGradient(b.x,b.y,0,b.x,b.y,r);
        g.addColorStop(0,"rgba(230,210,255,0.9)");
        g.addColorStop(0.4,"rgba(230,210,255,0.3)");
        g.addColorStop(1,"rgba(230,210,255,0)");
        ctx.beginPath();
        ctx.arc(b.x,b.y,r,0,Math.PI*2);
        ctx.fillStyle=g;
        ctx.fill();
      }
    }

    function drawFireBursts(){
      for(const f of fireBursts){
        const t=clamp(f.life/1.4,0,1);
        const r=f.radius;
        const g=ctx.createRadialGradient(f.x,f.y,0,f.x,f.y,r);
        g.addColorStop(0,`rgba(255,230,180,${0.6*t})`);
        g.addColorStop(0.6,`rgba(255,160,80,${0.4*t})`);
        g.addColorStop(1,"rgba(255,100,40,0)");
        ctx.beginPath();
        ctx.arc(f.x,f.y,r,0,Math.PI*2);
        ctx.fillStyle=g;
        ctx.fill();
      }
    }

    function drawEnemyBullets(){
      for(const b of enemyBullets){
        ctx.save();
        ctx.shadowBlur=8;
        ctx.shadowColor="rgba(255,140,120,0.9)";
        const len=8;
        const speed=Math.hypot(b.vx,b.vy)||1;
        const tx=b.x-(b.vx/speed)*len;
        const ty=b.y-(b.vy/speed)*len;

        ctx.beginPath();
        ctx.moveTo(tx,ty);
        ctx.lineTo(b.x,b.y);
        ctx.lineWidth=3;
        ctx.strokeStyle="rgba(255,160,140,0.95)";
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(b.x,b.y,b.radius+1,0,Math.PI*2);
        ctx.fillStyle="#ffede0";
        ctx.fill();
        ctx.restore();
      }
    }

    function drawBullets(){
      const coreColor=getBulletColor();
      for(const b of bullets){
        ctx.save();
        ctx.shadowBlur=12;
        ctx.shadowColor=coreColor;

        const len=10;
        const speed=Math.hypot(b.vx,b.vy)||1;
        const tx=b.x-(b.vx/speed)*len;
        const ty=b.y-(b.vy/speed)*len;

        ctx.beginPath();
        ctx.moveTo(Math.round(tx)+0.5,Math.round(ty)+0.5);
        ctx.lineTo(Math.round(b.x)+0.5,Math.round(b.y)+0.5);
        ctx.lineWidth=3;
        ctx.strokeStyle=coreColor;
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(Math.round(b.x)+0.5,Math.round(b.y)+0.5,b.radius+1.2,0,Math.PI*2);
        ctx.fillStyle="#ffffff";
        ctx.fill();

        ctx.restore();
      }
    }

    function drawEnemies(){
      for(const e of enemies){
        // body gradient – neon blob, but small radius for pixel vibe
        const bodyGrad=ctx.createRadialGradient(
          e.x-e.radius*0.3,e.y-e.radius*0.3,e.radius*0.2,
          e.x,e.y,e.radius
        );
        bodyGrad.addColorStop(0,"#ffffff");
        bodyGrad.addColorStop(0.3,e.color||"#ff8899");
        bodyGrad.addColorStop(1,"#2a1018");

        ctx.save();
        ctx.shadowBlur=e.isBoss?16:10;
        ctx.shadowColor=e.isBoss?"#ffe08a":(e.color||"#ff8899");

        ctx.beginPath();
        ctx.arc(Math.round(e.x)+0.5,Math.round(e.y)+0.5,e.radius,0,Math.PI*2);
        ctx.fillStyle=bodyGrad;
        ctx.fill();

        // inner pixel-ish core
        ctx.beginPath();
        ctx.arc(Math.round(e.x)+0.5,Math.round(e.y)+0.5,Math.max(3,e.radius*0.45),0,Math.PI*2);
        ctx.fillStyle="rgba(10,10,15,0.85)";
        ctx.fill();

        ctx.restore();

        // HP bar
        const hpRatio=clamp(e.hp/e.maxHp,0,1);
        const barW=e.radius*2;
        const bx=e.x-e.radius;
        const by=e.y-e.radius-5;
        ctx.fillStyle="rgba(0,0,0,0.6)";
        ctx.fillRect(bx,by,barW,3);
        ctx.fillStyle=e.isBoss?"#ffe08a":(e.miniBoss?"#ffd0a0":"#ff8899");
        ctx.fillRect(bx,by,barW*hpRatio,3);

        if(e.isBoss||e.miniBoss){
          ctx.font="10px system-ui";
          ctx.textAlign="center";
          ctx.fillStyle="rgba(255,255,255,0.9)";
          ctx.fillText(e.name||"",e.x,by-5);
        }

        // Simple visual features per boss
        if(e.isBoss){
          ctx.save();
          ctx.translate(e.x,e.y);
          ctx.rotate(bgTime*0.7);
          ctx.strokeStyle="rgba(0,0,0,0.6)";
          ctx.lineWidth=1.3;
          if(e.bossId==="mahito"){
            // stitched mouth line
            ctx.beginPath();
            ctx.moveTo(-e.radius*0.7,0);
            ctx.lineTo(e.radius*0.7,0);
            ctx.stroke();
            for(let i=-2;i<=2;i++){
              ctx.beginPath();
              const ix=(i/2)*e.radius*0.7;
              ctx.moveTo(ix,-3);
              ctx.lineTo(ix,3);
              ctx.stroke();
            }
          }else if(e.bossId==="itachi"){
            // sharingan ring
            ctx.beginPath();
            ctx.arc(0,0,e.radius*0.6,0,Math.PI*2);
            ctx.stroke();
          }else if(e.bossId==="gojo"){
            // blindfold
            ctx.beginPath();
            ctx.moveTo(-e.radius*0.9,0);
            ctx.lineTo(e.radius*0.9,0);
            ctx.stroke();
          }else if(e.bossId==="luffy"){
            // gear 5 halo arcs
            ctx.beginPath();
            ctx.arc(0,0,e.radius*0.95,Math.PI*0.1,Math.PI*0.9);
            ctx.stroke();
          }
          ctx.restore();
        }
      }
    }

    function drawPlayer(){
      if(!player)return;
      const theme=getPlayerSkinTheme();

      ctx.save();

      // Outer aura
      ctx.shadowBlur=18;
      ctx.shadowColor=theme.outlineColor||"#9ff6ff";
      const auraR=player.radius+8+(player.ultActiveTimer>0?4:0);
      ctx.beginPath();
      ctx.arc(Math.round(player.x)+0.5,Math.round(player.y)+0.5,auraR,0,Math.PI*2);
      ctx.fillStyle=theme.auraColor||"rgba(120,200,255,0.45)";
      ctx.fill();

      // Core
      ctx.beginPath();
      ctx.arc(Math.round(player.x)+0.5,Math.round(player.y)+0.5,player.radius,0,Math.PI*2);
      ctx.fillStyle=theme.bodyColor||"#39c5ff";
      ctx.fill();

      ctx.shadowBlur=0;
      ctx.lineWidth=2;
      ctx.strokeStyle=theme.outlineColor||"#9ff6ff";
      ctx.stroke();

      // Direction "weapon" arrow
      const dx=mousePos.x-player.x;
      const dy=mousePos.y-player.y;
      const ang=Math.atan2(dy,dx);
      const len=player.radius+12;

      ctx.translate(player.x,player.y);
      ctx.rotate(ang);
      ctx.beginPath();
      ctx.moveTo(player.radius*0.2,-4);
      ctx.lineTo(len,0);
      ctx.lineTo(player.radius*0.2,4);
      ctx.closePath();
      ctx.fillStyle=theme.weaponColor||"#ffffff";
      ctx.fill();

      ctx.restore();

      // Melee swing arc
      if(player.meleeSwingTimer>0){
        const t=1-player.meleeSwingTimer/player.meleeSwingDuration;
        const m=getEffectiveMeleeStats();
        const swingArc=m.arc;
        const swingR=m.range;
        ctx.beginPath();
        ctx.arc(
          player.x,player.y,swingR,
          player.meleeAngle-swingArc*0.5,
          player.meleeAngle+swingArc*0.5
        );
        ctx.strokeStyle="rgba(255,240,200,"+(0.7*(1-t)+0.2)+")";
        ctx.lineWidth=4*(1-t)+1;
        ctx.stroke();
      }

      // Mahito touch indicator
      if(player.mahitoTouchStacks>0){
        ctx.beginPath();
        ctx.arc(player.x,player.y,player.radius+3,0,Math.PI*2);
        ctx.strokeStyle="rgba(255,105,105,0.9)";
        ctx.lineWidth=2;
        ctx.stroke();
      }
    }

    function updateStyleMeter(dt){
      if(!player)return;
      let decay=player.styleDecayRate||6;
      if(player.ultActiveTimer>0)decay*=0.7;
      player.styleMeter=Math.max(0,player.styleMeter-decay*dt);
      if(player.styleMeter>=player.styleMax && !cosmeticStats.reachedStyleSOnce){
        cosmeticStats.reachedStyleSOnce=true;
        saveCosmeticStats();
        checkCosmeticUnlocks();
      }
    }

    function getStyleRankInfo(){
      if(!player)return{rank:"-",color:"#aaaaaa",ratio:0};
      const ratio=player.styleMeter/player.styleMax;
      let rank="D",color="#888";
      if(ratio>=0.9){rank="S";color="#ffe08a";}
      else if(ratio>=0.65){rank="A";color="#e3b3ff";}
      else if(ratio>=0.4){rank="B";color="#87c7ff";}
      else if(ratio>=0.2){rank="C";color="#b8f7b8";}
      return{rank,color,ratio};
    }

    function updatePlayer(dt){
      if(!player)return;

      let speed=player.speed;
      if(player.ultActiveTimer>0){
        const def=ULT_DEFS[player.ultId];
        if(def && def.speedMult)speed*=def.speedMult;
      }
      if(bossGenjutsuTimer>0)speed*=0.88;

      let dx=0,dy=0;
      if(keys["w"]||keys["arrowup"])dy-=1;
      if(keys["s"]||keys["arrowdown"])dy+=1;
      if(keys["a"]||keys["arrowleft"])dx-=1;
      if(keys["d"]||keys["arrowright"])dx+=1;
      let mag=Math.hypot(dx,dy);
      if(mag>0){dx/=mag;dy/=mag;}

      if(player.isDashing){
        player.dashActiveTimer-=dt;
        player.x+=player.dashVelX*dt;
        player.y+=player.dashVelY*dt;
        if(player.dashActiveTimer<=0){
          player.isDashing=false;
          player.dashVelX=0;
          player.dashVelY=0;
        }else{
          if(Math.random()<0.4){
            spawnDashTrailParticles(player.x,player.y,false);
          }
        }
      }else{
        player.x+=dx*speed*dt;
        player.y+=dy*speed*dt;
      }

      player.x=clamp(player.x,player.radius,canvas.width-player.radius);
      player.y=clamp(player.y,player.radius,canvas.height-player.radius);

      if(player.dashCooldownTimer>0)player.dashCooldownTimer-=dt;
      if(player.meleeCooldownTimer>0)player.meleeCooldownTimer-=dt;
      if(player.meleeSwingTimer>0)player.meleeSwingTimer-=dt;

      handleShooting(dt);
    }

    function updateBossGenjutsu(dt){
      if(bossGenjutsuTimer>0){
        bossGenjutsuTimer-=dt;
        if(bossGenjutsuTimer<0)bossGenjutsuTimer=0;
      }
    }

    function updateHUD(){
      if(!player){
        hudWave.textContent="Wave: 0";
        hudHP.textContent="";
        hudStats.textContent="";
        hudUlt.textContent="";
        hudStyle.textContent="";
        return;
      }
      const hpRatio=player.hp/player.maxHp;
      let waveLabel="Wave: "+(wave||0);
      if(currentWaveEvent==="blood_moon")waveLabel+=" (Blood Moon)";
      else if(currentWaveEvent==="curse_storm")waveLabel+=" (Curse Storm)";
      hudWave.textContent=waveLabel;

      hudHP.textContent=`HP: ${Math.round(player.hp)}/${Math.round(player.maxHp)}`;
      hudHP.classList.toggle("low",hpRatio<0.35);

      const gun=getEffectiveGunStats();
      const fr=gun?gun.fireRate.toFixed(1):"?";
      hudStats.textContent=`DMG ${Math.round(player.damage)} | Fire ${fr}/s | SPD ${Math.round(player.speed)}`;

      const def=ULT_DEFS[player.ultId];
      if(def){
        if(player.ultActiveTimer>0){
          hudUlt.textContent=`Ult: ${def.name} – ACTIVE ${player.ultActiveTimer.toFixed(1)}s`;
        }else if(player.ultReady){
          hudUlt.textContent=`Ult: ${def.name} – READY (Q)`;
        }else{
          hudUlt.textContent=`Ult: ${def.name} – CD ${player.ultCooldownTimer.toFixed(1)}s`;
        }
      }else{
        hudUlt.textContent="Ult: None";
      }
      hudUlt.classList.toggle("ult-ready",player.ultReady);

      const styleInfo=getStyleRankInfo();
      const percent=Math.round(styleInfo.ratio*100);
      hudStyle.textContent=`Style: Rank ${styleInfo.rank} (${percent}/${player.styleMax})`;
      hudStyle.style.color=styleInfo.color;
      hudStyle.classList.toggle("style-high",["A","S"].includes(styleInfo.rank));
    }

    function draw(){
      ctx.save();
      let ox=0,oy=0;
      if(screenShakeTimer>0 && screenShakeDuration>0){
        const t=screenShakeTimer/screenShakeDuration;
        const mag=screenShakeIntensity*t;
        ox=(Math.random()*2-1)*mag;
        oy=(Math.random()*2-1)*mag;
      }
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.translate(ox,oy);

      drawBackground();
      if(domainField.active)drawDomainField();
      drawSlowFields();
      drawBombs();
      drawFireBursts();
      drawEnemies();
      drawEnemyBullets();
      drawBullets();
      drawSummons();
      drawPlayer();
      drawParticles();

      ctx.restore();

      if(currentWaveEvent==="blood_moon"){
        ctx.fillStyle="rgba(255,60,80,0.08)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
      }else if(currentWaveEvent==="curse_storm"){
        ctx.fillStyle="rgba(120,160,255,0.08)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
      }

      if(bossGenjutsuTimer>0){
        const t=bossGenjutsuTimer/GENJUTSU_DURATION;
        ctx.fillStyle=`rgba(140,0,140,${0.18*t})`;
        ctx.fillRect(0,0,canvas.width,canvas.height);
      }

      if(whiteFlashAlpha>0){
        ctx.fillStyle=`rgba(255,255,255,${whiteFlashAlpha})`;
        ctx.fillRect(0,0,canvas.width,canvas.height);
      }
    }

    /* MAIN MENU & GAME FLOW */

    function giveArchetypeStartingPowers(){
      if(!player)return;
      const arch=ARCHETYPES[selectedArchetype]||ARCHETYPES.sorcerer;
      if(!arch||!arch.startAbilities)return;
      for(const id of arch.startAbilities){
        const def=getAbilityById(id);
        if(!def)continue;
        if(def.type==="boss"){
          if(!player.bossAbilities.includes(id))player.bossAbilities.push(id);
        }else{
          if(!player.normalAbilities.includes(id))player.normalAbilities.push(id);
        }
      }
    }

    function resetRunState(){
      bullets.length=0;
      enemies.length=0;
      enemyBullets.length=0;
      particles.length=0;
      playerBombs.length=0;
      fireBursts.length=0;
      slowFields.length=0;
      summons=[];
      titanSummon=null;
      activeCurses=[];
      awaitingWaveStart=false;
      currentWaveEvent=null;
      wave=0;
      enemyIdCounter=1;
      domainField.active=false;
      bossGenjutsuTimer=0;
      screenShakeTimer=0;
      screenShakeDuration=0.2;
      screenShakeIntensity=3;
      whiteFlashAlpha=0;

      player=createPlayer();
      player.normalAbilities=[];
      player.bossAbilities=[];
      player.ultId=selectedUltId;
      player.ultCooldownTimer=5;
      player.ultReady=false;
      player.styleMeter=0;
      player.mahitoTouchStacks=0;

      giveArchetypeStartingPowers();
      recomputePlayerStats(false);
      recomputeEnemyScale();
      rebuildSummons();
      refreshAbilityBar();
    }

    function startGameFromMenu(){
      if(!combatStyle){
        showMessage("Pick a combat style first!",2);
        return;
      }
      if(!selectedArchetype){
        showMessage("Pick an archetype too!",2);
        return;
      }
      mainMenu.style.display="none";
      gameState="playing";
      resetRunState();
      startNextWave();
    }

    function resetGame(){
      if(gameState==="menu")return;
      gameState="playing";
      resetRunState();
      startNextWave();
      showMessage("New run!",1.5);
    }

    function setupMainMenu(){
      const styleButtons=document.querySelectorAll('.menuButton[data-style]');
      styleButtons.forEach(btn=>{
        btn.addEventListener("click",()=>{
          combatStyle=btn.getAttribute("data-style");
          styleButtons.forEach(b=>b.classList.remove("styleActive"));
          btn.classList.add("styleActive");
        });
      });

      const archButtons=document.querySelectorAll(".archButton");
      archButtons.forEach(btn=>{
        btn.addEventListener("click",()=>{
          selectedArchetype=btn.getAttribute("data-arch");
          archButtons.forEach(b=>b.classList.remove("styleActive"));
          btn.classList.add("styleActive");
        });
      });

      const ultButtons=document.querySelectorAll(".ultButton");
      ultButtons.forEach(btn=>{
        btn.addEventListener("click",()=>{
          selectedUltId=btn.getAttribute("data-ult");
          ultButtons.forEach(b=>b.classList.remove("styleActive"));
          btn.classList.add("styleActive");
        });
      });

      const inner=document.getElementById("mainMenuInner");
      if(inner){
        const row=document.createElement("div");
        row.style.marginTop="8px";
        row.style.display="flex";
        row.style.justifyContent="center";
        const startBtn=document.createElement("button");
        startBtn.textContent="Start Run";
        startBtn.className="menuButton";
        startBtn.addEventListener("click",startGameFromMenu);
        row.appendChild(startBtn);
        inner.appendChild(row);
      }
    }

    /* GAME LOOP */

    function gameLoop(timestamp){
      if(!lastTime)lastTime=timestamp;
      const dt=Math.min(0.033,(timestamp-lastTime)/1000);
      lastTime=timestamp;

      updateBackground(dt);

      if(gameState==="playing"){
        updateStyleMeter(dt);
        updateUltState(dt);
        updateDomainField(dt);
        updateBombs(dt);
        updateFireBursts(dt);
        updateSlowFields(dt);
        updatePlayer(dt);
        updateEnemies(dt);
        updateEnemyBullets(dt);
        updateBullets(dt);
        updateSummons(dt);
        updateParticles(dt);
        updateBossGenjutsu(dt);
        tryEndWave();
      }else if(gameState==="upgrade"){
        updateUltState(dt);
        updateDomainField(dt);
        updateBombs(dt);
        updateFireBursts(dt);
        updateSlowFields(dt);
        updateParticles(dt);
        updateBossGenjutsu(dt);
      }else{
        updateUltState(dt);
        updateDomainField(dt);
        updateBombs(dt);
        updateFireBursts(dt);
        updateSlowFields(dt);
        updateParticles(dt);
        updateBossGenjutsu(dt);
      }

      if(messageTimer>0){
        messageTimer-=dt;
        if(messageTimer<=0){
          overlayMessageEl.textContent="";
        }
      }

      if(screenShakeTimer>0)screenShakeTimer-=dt;
      if(screenShakeTimer<0)screenShakeTimer=0;
      whiteFlashAlpha=Math.max(0,whiteFlashAlpha-dt*1.8);

      draw();
      updateHUD();

      requestAnimationFrame(gameLoop);
    }

    function init(){
      initAbilities();
      initCosmeticsSystem();
      setupMainMenu();
      checkCosmeticUnlocks();
      updateHUD();
      gameState="menu";
      ensureBaseCosmeticsUnlocked();
      requestAnimationFrame(gameLoop);
    }

    init();
  </script>
</body>
</html>
