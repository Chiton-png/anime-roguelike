<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Anime Roguelike Shooter</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    body{
      background:#050509;
      color:#f5f5f5;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      display:flex;
      flex-direction:column;
      align-items:center;
      padding:10px;
      user-select:none;
    }
    h1{font-size:22px;margin-bottom:4px}
    p{font-size:12px;margin-bottom:6px;opacity:.85}

    #container{position:relative;display:inline-block}
    #game{
      display:block;
      border-radius:8px;
      border:2px solid #333;
      background:#000;
    }
    #overlayMessage{
      position:absolute;
      top:8px;
      left:50%;
      transform:translateX(-50%);
      padding:4px 10px;
      background:rgba(0,0,0,.6);
      border-radius:999px;
      font-size:12px;
      pointer-events:none;
    }

    #hud{
      margin-top:6px;
      font-size:13px;
      display:flex;
      gap:12px;
      justify-content:center;
      flex-wrap:wrap;
    }
    #hudHP.low{
      color:#ff7070;
      text-shadow:0 0 8px rgba(255,90,90,.9);
    }
    #hudUlt.ult-ready{
      color:#ffe08a;
      text-shadow:0 0 8px rgba(255,210,120,.9);
    }
    #hudStyle.style-high{
      color:#87c7ff;
      text-shadow:0 0 8px rgba(120,180,255,.9);
    }

    #upgradePanel{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.75);
      z-index:10;
    }
    #upgradePanelInner{
      background:#101010;
      border-radius:10px;
      padding:14px;
      max-width:620px;
      width:92%;
      box-shadow:0 0 24px rgba(0,0,0,.9);
      font-size:13px;
    }
    #upgradePanelInner h2{margin-bottom:6px;font-size:18px}
    #upgradePanelInner p{margin-bottom:8px;font-size:11px;opacity:.9}
    #upgrades{
      display:flex;
      flex-direction:column;
      gap:6px;
      margin-bottom:6px;
    }
    .upgradeButton{
      background:#181818;
      border-radius:6px;
      padding:7px;
      text-align:left;
      cursor:pointer;
      font-size:12px;
      border:1px solid #555;
      color:#f5f5f5;
      transition:background .1s,transform .05s,box-shadow .1s,border-color .1s;
    }
    .upgradeButton:hover{
      background:#252525;
      transform:translateY(-1px);
      box-shadow:0 0 16px rgba(255,255,255,.16);
    }
    .upgradeTopRow{
      display:flex;
      justify-content:space-between;
      margin-bottom:2px;
    }
    .upgradeName{font-weight:600}
    .upgradeDesc{font-size:11px;opacity:.92;color:#f0f0f0}

    .rarityBadge{
      font-size:9px;
      padding:2px 6px;
      border-radius:999px;
      text-transform:uppercase;
      letter-spacing:.05em;
      font-weight:600;
      border:1px solid transparent;
    }
    .rarity-common{
      color:#b8f7b8;
      background:rgba(80,160,80,.18);
      border-color:rgba(120,220,120,.7);
    }
    .rarity-rare{
      color:#87c7ff;
      background:rgba(80,120,200,.18);
      border-color:rgba(120,180,255,.7);
    }
    .rarity-epic{
      color:#e3b3ff;
      background:rgba(150,80,200,.2);
      border-color:rgba(210,150,255,.8);
    }
    .rarity-legendary{
      color:#ffe08a;
      background:rgba(200,140,40,.25);
      border-color:rgba(255,206,120,.9);
    }

    .card-rarity-common{
      box-shadow:0 0 6px rgba(130,220,130,.5);
      border-color:rgba(130,220,130,.7);
    }
    .card-rarity-rare{
      box-shadow:0 0 9px rgba(120,180,255,.7);
      border-color:rgba(120,180,255,.9);
    }
    .card-rarity-epic{
      box-shadow:0 0 11px rgba(210,140,255,.8);
      border-color:rgba(210,140,255,1);
    }
    .card-rarity-legendary{
      box-shadow:0 0 14px rgba(255,210,100,1);
      border-color:rgba(255,210,100,1);
    }

    #skipButton{
      margin-top:2px;
      padding:5px 10px;
      border-radius:999px;
      border:1px solid #777;
      background:#222;
      color:#f5f5f5;
      cursor:pointer;
      font-size:11px;
      float:right;
    }
    #skipButton:hover{background:#333}

    #abilitiesBar{
      margin-top:8px;
      display:flex;
      gap:20px;
      justify-content:center;
      flex-wrap:wrap;
      max-width:960px;
      font-size:11px;
    }
    .abilitiesGroup{
      display:flex;
      flex-direction:column;
      gap:4px;
      align-items:flex-start;
    }
    .abilitiesTitle{opacity:.75;font-size:11px}
    .abilitiesList{
      display:flex;
      gap:4px;
      flex-wrap:wrap;
      max-width:460px;
    }
    .abilitySlot{
      border-radius:999px;
      padding:3px 7px;
      border:1px solid #666;
      background:#151515;
      font-size:10px;
      cursor:pointer;
      white-space:nowrap;
      display:inline-flex;
      align-items:center;
      transition:background .1s,transform .05s,box-shadow .1s,border-color .1s;
    }
    .abilitySlot:hover{
      background:#232323;
      transform:translateY(-1px);
    }
    .abilitySlot.card-rarity-common{
      box-shadow:0 0 4px rgba(130,220,130,.5);
      border-color:rgba(130,220,130,.7);
    }
    .abilitySlot.card-rarity-rare{
      box-shadow:0 0 6px rgba(120,180,255,.7);
      border-color:rgba(120,180,255,.9);
    }
    .abilitySlot.card-rarity-epic{
      box-shadow:0 0 7px rgba(210,140,255,.8);
      border-color:rgba(210,140,255,1);
    }
    .abilitySlot.card-rarity-legendary{
      box-shadow:0 0 9px rgba(255,210,100,1);
      border-color:rgba(255,210,100,1);
    }

    #mainMenu{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.9);
      z-index:20;
    }
    #mainMenuInner{
      background:#111;
      padding:16px 20px;
      border-radius:10px;
      max-width:620px;
      width:92%;
      box-shadow:0 0 24px rgba(0,0,0,.9);
      text-align:center;
      font-size:13px;
    }
    #mainMenuInner h2{margin-bottom:4px;font-size:20px}
    #mainMenuInner p{opacity:.85;margin-bottom:6px;font-size:11px}
    .menuButtons{
      display:flex;
      gap:8px;
      justify-content:center;
      flex-wrap:wrap;
      margin:6px 0;
    }
    .menuButton{
      padding:7px 12px;
      border-radius:999px;
      border:1px solid #666;
      background:#222;
      color:#f5f5f5;
      cursor:pointer;
      font-size:12px;
      transition:background .1s,transform .05s,box-shadow .1s;
    }
    .menuButton:hover{
      background:#333;
      transform:translateY(-1px);
      box-shadow:0 0 12px rgba(255,255,255,.15);
    }
    .menuButton.styleActive{
      background:#203040;
      border-color:#7bd0ff;
      box-shadow:0 0 12px rgba(123,208,255,.8);
    }
  </style>
</head>
<body>
  <h1>Anime Roguelike Shooter</h1>
  <p>WASD / Arrows move • Mouse aim • Left click shoot • Right click / E melee • Space dash • Q ultimate • R restart</p>

  <!-- MAIN MENU -->
  <div id="mainMenu">
    <div id="mainMenuInner">
      <h2>Anime Rogue Run</h2>
      <p>Pick your playstyle and archetype. Build busted Demon Slayer / One Piece / JJK / MHA / Cyberpunk / Solo Leveling combos.</p>

      <p style="margin-top:4px;font-weight:600">Combat Style</p>
      <div class="menuButtons">
        <button class="menuButton" data-style="melee">Melee Focus</button>
        <button class="menuButton" data-style="ranged">Ranged Focus</button>
      </div>

      <p style="margin-top:4px;font-weight:600">Archetype</p>
      <div class="menuButtons">
        <button class="menuButton archButton" data-arch="swordsman">Sharp Swordsman</button>
        <button class="menuButton archButton" data-arch="sorcerer">Cursed Sorcerer</button>
        <button class="menuButton archButton" data-arch="titan">Titan Slayer</button>
        <button class="menuButton archButton" data-arch="hero">Quirked Hero</button>
      </div>

      <p style="margin-top:4px;font-weight:600">Ultimate (Q to cast)</p>
      <div class="menuButtons" id="ultMenu">
        <button class="menuButton ultButton" data-ult="jjk_domain">JJK Domain</button>
        <button class="menuButton ultButton" data-ult="ofa_100">OFA 100%</button>
        <button class="menuButton ultButton" data-ult="demon_mark">Demon Mark</button>
        <button class="menuButton ultButton" data-ult="gear_fifth">Gear Fifth</button>
        <button class="menuButton ultButton" data-ult="susanoo_guardian">Susanoo Guardian</button>
        <button class="menuButton ultButton" data-ult="cyber_sandevistan">Cyber Sandevistan</button>
        <button class="menuButton ultButton" data-ult="ghoul_rampage">Ghoul Rampage</button>
        <button class="menuButton ultButton" data-ult="flame_domain">Flame Ring</button>
        <button class="menuButton ultButton" data-ult="bankai_field">Bankai Field</button>
        <button class="menuButton ultButton" data-ult="haki_burst">Haki Burst</button>
      </div>

      <p style="margin-top:4px;font-size:11px;opacity:.75">
        Powers every wave with drawbacks. Boss &amp; curses every 5 waves, mini-bosses in between, event waves like Blood Moon &amp; Curse Storm.
      </p>
    </div>
  </div>

  <div id="container">
    <canvas id="game" width="960" height="540"></canvas>
    <div id="overlayMessage"></div>

    <div id="upgradePanel">
      <div id="upgradePanelInner">
        <h2>Choose a Power-Up</h2>
        <p>
          Every wave you get a power with a drawback. Max <b>5 normal</b> powers and <b>2 boss</b> powers (unless you break the limit).
          Boss waves can offer <b>Legendary</b> powers and <b>Curses</b> with extreme tradeoffs.
        </p>
        <div id="upgrades"></div>
        <button id="skipButton">Skip – no power this wave</button>
      </div>
    </div>
  </div>

  <div id="hud">
    <div id="hudWave"></div>
    <div id="hudHP"></div>
    <div id="hudStats"></div>
    <div id="hudUlt"></div>
    <div id="hudStyle"></div>
  </div>

  <div id="abilitiesBar">
    <div class="abilitiesGroup">
      <span class="abilitiesTitle">Normal Powers (cap 5, unless Broken Limit):</span>
      <div id="normalAbilitiesList" class="abilitiesList"></div>
    </div>
    <div class="abilitiesGroup">
      <span class="abilitiesTitle">Boss Powers (cap 2):</span>
      <div id="bossAbilitiesList" class="abilitiesList"></div>
    </div>
  </div>

  <script>
    const canvas=document.getElementById("game");
    const ctx=canvas.getContext("2d");
    const overlayMessageEl=document.getElementById("overlayMessage");
    const upgradePanel=document.getElementById("upgradePanel");
    const upgradesContainer=document.getElementById("upgrades");
    const skipButton=document.getElementById("skipButton");
    const hudWave=document.getElementById("hudWave");
    const hudHP=document.getElementById("hudHP");
    const hudStats=document.getElementById("hudStats");
    const hudUlt=document.getElementById("hudUlt");
    const hudStyle=document.getElementById("hudStyle");
    const mainMenu=document.getElementById("mainMenu");
    const normalAbilitiesListEl=document.getElementById("normalAbilitiesList");
    const bossAbilitiesListEl=document.getElementById("bossAbilitiesList");

    const keys={};
    let mousePos={x:canvas.width/2,y:canvas.height/2};
    let mouseDown=false;
    let combatStyle=null; // "melee" or "ranged"
    let selectedUltId="jjk_domain";
    let selectedArchetype="sorcerer"; // default if player doesn't pick
    let gameState="menu"; // "menu","playing","upgrade","chooseReplace","gameover"
    let lastTime=0;
    let messageTimer=0;

    // Background orbs
    const bgOrbs=[];
    const MAX_BG_ORBS=40;
    let bgTime=0;

    // Particles / FX
    const particles=[];
    const fireBursts=[];
    const playerBombs=[];
    const slowFields=[];

    // Screen shake / flash
    let screenShakeTimer=0;
    let screenShakeDuration=0;
    let screenShakeIntensity=0;
    let whiteFlashAlpha=0;

    // Domain field (for domain-style ults)
    let domainField={
      active:false,
      x:0,y:0,
      radius:220,
      type:null,
      color:"rgba(90,60,200,0.18)",
      edgeColor:"rgba(210,180,255,0.9)",
      dpsMult:0
    };

    // Itachi genjutsu (Tsukuyomi) status
    const GENJUTSU_DURATION=3.2;
    let bossGenjutsuTimer=0;

    // Entities
    let player=null;
    let bullets=[];
    let enemies=[];
    let enemyBullets=[];

    // Abilities / curses / waves
    let wave=0;
    let normalAbilities=[];
    let bossAbilities=[];
    let curses=[];
    let activeCurses=[];
    let noLimitMode=false;
    let pendingAbility=null;
    let pendingCategory=null;

    // Enemy modifiers from curses / boss powers
    let enemyScale={
      hpMult:1,
      speedMult:1,
      damageMult:1,
      countMult:1,
      bulletSpeedMult:1,
      bulletDamageMult:1
    };

    // Wave event: null | "curse_storm" | "blood_moon" | "hunt_night"
    let currentWaveEvent=null;

    // Named bosses
    const BOSS_TEMPLATES=[
      {id:"mahito",name:"Mahito",color:"#b88cff"},
      {id:"itachi",name:"Itachi",color:"#ff6666"},
      {id:"gojo",name:"Gojo",color:"#7bd0ff"},
      {id:"luffy",name:"Gear Fifth Luffy",color:"#ffd480"}
    ];

    // Mini-boss templates
    const MINI_BOSS_TEMPLATES=[
      {id:"upper_moon_demon",name:"Upper Moon Demon",color:"#ff9966",pattern:"cone"},
      {id:"high_end_nomu",name:"High-End Nomu",color:"#c84cff",pattern:"rush"},
      {id:"armored_titan",name:"Armored Titan",color:"#d8aa6a",pattern:"spin"}
    ];

    // Archetypes
    const ARCHETYPES={
      swordsman:{
        id:"swordsman",
        name:"Sharp Swordsman",
        startAbilities:["water_breathing","blood_edge"]
      },
      sorcerer:{
        id:"sorcerer",
        name:"Cursed Sorcerer",
        startAbilities:["shadow_garden","black_flash_rhythm"]
      },
      titan:{
        id:"titan",
        name:"Titan Slayer",
        startAbilities:["survey_maneuvers","shadow_army_commander"]
      },
      hero:{
        id:"hero",
        name:"Quirked Hero",
        startAbilities:["quirk_booster","fire_force_spark"]
      }
    };

    /* ================= INPUT ================= */
    window.addEventListener("keydown",e=>{
      const k=e.key.toLowerCase();
      keys[k]=true;
      if(e.code==="Space"&&gameState==="playing")startDash();
      if(k==="e"&&gameState==="playing")tryMeleeAttack();
      if(k==="q"&&gameState==="playing")tryUseUlt();
      if(k==="r"&&gameState==="gameover")resetGame();
    });
    window.addEventListener("keyup",e=>{keys[e.key.toLowerCase()]=false;});
    canvas.addEventListener("mousemove",e=>{
      const r=canvas.getBoundingClientRect();
      mousePos.x=e.clientX-r.left;
      mousePos.y=e.clientY-r.top;
    });
    canvas.addEventListener("mousedown",e=>{
      if(e.button===0)mouseDown=true;
      if(e.button===2&&gameState==="playing")tryMeleeAttack();
    });
    canvas.addEventListener("mouseup",e=>{if(e.button===0)mouseDown=false;});
    canvas.addEventListener("contextmenu",e=>e.preventDefault());

    /* ============== UTILS ============== */
    const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
    const distance=(x1,y1,x2,y2)=>Math.hypot(x2-x1,y2-y1);
    function shuffled(a){a=a.slice();for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}
    function angleDiff(a,b){let d=a-b;while(d>Math.PI)d-=Math.PI*2;while(d<-Math.PI)d+=Math.PI*2;return d;}
    function showMessage(msg,t=2){overlayMessageEl.textContent=msg;messageTimer=t;}

    function addScreenShake(intensity,duration){
      screenShakeIntensity=Math.max(screenShakeIntensity,intensity);
      screenShakeDuration=Math.max(screenShakeDuration,duration);
      screenShakeTimer=Math.max(screenShakeTimer,duration);
    }
    function addWhiteFlash(strength){whiteFlashAlpha=Math.min(1,whiteFlashAlpha+strength);}

    /* ============== BACKGROUND & PARTICLES ============== */
    function initBackground(){
      bgOrbs.length=0;
      for(let i=0;i<MAX_BG_ORBS;i++){
        bgOrbs.push({
          x:Math.random()*canvas.width,
          y:Math.random()*canvas.height,
          r:20+Math.random()*60,
          speed:5+Math.random()*15,
          drift:(Math.random()*0.4+0.2)*(Math.random()<0.5?-1:1),
          alpha:0.06+Math.random()*0.10
        });
      }
    }
    function updateBackground(dt){
      bgTime+=dt;
      for(const o of bgOrbs){
        o.y+=o.speed*dt;
        o.x+=o.drift*dt;
        if(o.y-o.r>canvas.height)o.y=-o.r;
        if(o.y+o.r<0)o.y=canvas.height+o.r;
        if(o.x-o.r>canvas.width)o.x=-o.r;
        if(o.x+o.r<0)o.x=canvas.width+o.r;
      }
    }
    function drawBackground(){
      const g=ctx.createRadialGradient(
        canvas.width*.5,canvas.height*.35,0,
        canvas.width*.5,canvas.height*.5,canvas.width*.9
      );
      g.addColorStop(0,"#22263a");
      g.addColorStop(1,"#050509");
      ctx.fillStyle=g;
      ctx.fillRect(0,0,canvas.width,canvas.height);

      for(const o of bgOrbs){
        ctx.beginPath();
        ctx.arc(o.x,o.y,o.r,0,Math.PI*2);
        ctx.fillStyle=`rgba(150,170,255,${o.alpha})`;
        ctx.fill();
      }

      ctx.save();
      ctx.globalAlpha=.15;
      ctx.strokeStyle="#444";
      const step=40;
      ctx.beginPath();
      for(let x=0;x<canvas.width;x+=step){ctx.moveTo(x,0);ctx.lineTo(x,canvas.height);}
      for(let y=0;y<canvas.height;y+=step){ctx.moveTo(0,y);ctx.lineTo(canvas.width,y);}
      ctx.stroke();
      ctx.restore();

      const vg=ctx.createRadialGradient(
        canvas.width/2,canvas.height/2,canvas.width*.2,
        canvas.width/2,canvas.height/2,canvas.width*.7
      );
      vg.addColorStop(0,"rgba(0,0,0,0)");
      vg.addColorStop(1,"rgba(0,0,0,0.7)");
      ctx.fillStyle=vg;
      ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    function spawnParticles(x,y,opt={}){
      const {
        count=12,spread=Math.PI*2,
        speedMin=80,speedMax=260,
        lifeMin=.25,lifeMax=.6,
        sizeMin=2,sizeMax=4,
        color="rgba(255,255,255,1)"
      }=opt;
      for(let i=0;i<count;i++){
        const ang=Math.random()*spread;
        const s=speedMin+Math.random()*(speedMax-speedMin);
        const vx=Math.cos(ang)*s;
        const vy=Math.sin(ang)*s;
        const life=lifeMin+Math.random()*(lifeMax-lifeMin);
        const size=sizeMin+Math.random()*(sizeMax-sizeMin);
        particles.push({x,y,vx,vy,life,maxLife:life,size,color,renderColor:color});
      }
    }
    function updateParticles(dt){
      for(let i=particles.length-1;i>=0;i--){
        const p=particles[i];
        p.life-=dt;
        if(p.life<=0){particles.splice(i,1);continue;}
        const t=p.life/p.maxLife;
        p.x+=p.vx*dt;
        p.y+=p.vy*dt;
        p.vx*=.97;
        p.vy+=20*dt;
        const m=p.color.match(/rgba\((\d+),(\d+),(\d+),([\d.]+)\)/);
        if(m){
          const[r,g,b]=[m[1],m[2],m[3]];
          p.renderColor=`rgba(${r},${g},${b},${t})`;
        }else p.renderColor=p.color;
      }
    }
    function drawParticles(){
      for(const p of particles){
        ctx.beginPath();
        ctx.arc(p.x,p.y,p.size,0,Math.PI*2);
        ctx.fillStyle=p.renderColor||p.color;
        ctx.fill();
      }
    }

    function updateSlowFields(dt){
      for(let i=slowFields.length-1;i>=0;i--){
        const f=slowFields[i];
        f.life-=dt;
        if(f.life<=0)slowFields.splice(i,1);
      }
    }

    /* ============== PLAYER & STATS ============== */
    const BASE_STATS={
      maxHp:100,
      damage:16,
      fireRate:3,
      speed:230,
      bulletSpeed:550,
      bulletsPerShot:1,
      spread:0.18,
      pierce:0,
      onHitHeal:0,
      healAfterWave:10,
      dashCooldown:1.1,
      dashDuration:.22,
      meleeDamage:32,
      meleeRange:80,
      meleeArc:1.7,
      meleeCooldown:.75,
      meleeOnHitHeal:0
    };

    function createPlayer(){
      return{
        x:canvas.width/2,y:canvas.height/2,radius:14,
        hp:BASE_STATS.maxHp,maxHp:BASE_STATS.maxHp,
        damage:BASE_STATS.damage,
        fireRate:BASE_STATS.fireRate,
        speed:BASE_STATS.speed,
        bulletSpeed:BASE_STATS.bulletSpeed,
        bulletsPerShot:BASE_STATS.bulletsPerShot,
        spread:BASE_STATS.spread,
        pierce:BASE_STATS.pierce,
        onHitHeal:BASE_STATS.onHitHeal,
        healAfterWave:BASE_STATS.healAfterWave,
        shootTimer:0,
        dashCooldown:BASE_STATS.dashCooldown,
        dashDuration:BASE_STATS.dashDuration,
        dashCooldownTimer:0,
        dashActiveTimer:0,
        isDashing:false,
        dashVelX:0,dashVelY:0,
        dashMode:"normal",
        meleeDamage:BASE_STATS.meleeDamage,
        meleeRange:BASE_STATS.meleeRange,
        meleeArc:BASE_STATS.meleeArc,
        meleeCooldown:BASE_STATS.meleeCooldown,
        meleeCooldownTimer:0,
        meleeSwingTimer:0,
        meleeSwingDuration:.18,
        meleeAngle:0,
        meleeOnHitHeal:BASE_STATS.meleeOnHitHeal,
        incomingDamageMult:1,
        normalAbilities:[],
        bossAbilities:[],
        // ult & style
        ultId:null,
        ultCooldownTimer:0,
        ultActiveTimer:0,
        ultDamageMult:1,
        ultFireRateMult:1,
        ultSpeedMult:1,
        ultMeleeDamageMult:1,
        ultMeleeRangeMult:1,
        ultPierceBonus:0,
        ultMeleeHealBonus:0,
        ultBulletSpeedMult:1,
        ultIncomingDamageMult:1,
        ultReady:false,
        styleMeter:0,
        styleMax:100,
        styleDecayRate:6,
        styleGainMult:1,
        lastStandActive:false,
        mahitoTouchStacks:0
      };
    }

    const getAbilityById=id=>normalAbilities.find(a=>a.id===id)||bossAbilities.find(a=>a.id===id)||null;
    const getCurseById=id=>curses.find(c=>c.id===id)||null;
    const hasCurse=id=>activeCurses.includes(id);

    function hasBrokenLimit(){
      if(!player)return false;
      return player.normalAbilities.includes("broken_limit")||
             player.bossAbilities.includes("broken_limit");
    }

    function recomputeEnemyScale(){
      enemyScale={hpMult:1,speedMult:1,damageMult:1,countMult:1,bulletSpeedMult:1,bulletDamageMult:1};
      for(const id of activeCurses){
        const c=getCurseById(id);
        if(!c||!c.enemyMods)continue;
        const m=c.enemyMods;
        if(m.enemyHpMult)enemyScale.hpMult*=m.enemyHpMult;
        if(m.enemySpeedMult)enemyScale.speedMult*=m.enemySpeedMult;
        if(m.enemyDamageMult)enemyScale.damageMult*=m.enemyDamageMult;
        if(m.enemyCountMult)enemyScale.countMult*=m.enemyCountMult;
        if(m.enemyBulletSpeedMult)enemyScale.bulletSpeedMult*=m.enemyBulletSpeedMult;
        if(m.enemyBulletDamageMult)enemyScale.bulletDamageMult*=m.enemyBulletDamageMult;
      }
      if(player){
        for(const id of player.bossAbilities){
          const ab=getAbilityById(id);
          if(!ab||!ab.enemyMods)continue;
          const m=ab.enemyMods;
          if(m.enemyHpMult)enemyScale.hpMult*=m.enemyHpMult;
          if(m.enemySpeedMult)enemyScale.speedMult*=m.enemySpeedMult;
          if(m.enemyDamageMult)enemyScale.damageMult*=m.enemyDamageMult;
          if(m.enemyCountMult)enemyScale.countMult*=m.enemyCountMult;
          if(m.enemyBulletSpeedMult)enemyScale.bulletSpeedMult*=m.enemyBulletSpeedMult;
          if(m.enemyBulletDamageMult)enemyScale.bulletDamageMult*=m.enemyBulletDamageMult;
        }
      }
    }

    function recomputePlayerStats(keepHpRatio=true){
      if(!player)return;
      noLimitMode=hasBrokenLimit();
      const oldMax=player.maxHp||BASE_STATS.maxHp;
      const oldRatio=oldMax>0?player.hp/oldMax:1;

      const stats={...BASE_STATS};
      let incomingDamageMult=1;
      let styleGainMult=1;
      const allIds=[...player.normalAbilities,...player.bossAbilities];
      const abilityFactor=noLimitMode?0.5:1;

      function applyMods(m,factor){
        if(!m)return;
        const f=factor;
        const mul=(v,k)=>{if(m[k])stats[v]*=1+(m[k]-1)*f;};
        const add=(v,k)=>{if(m[k])stats[v]+=m[k]*f;};

        mul("maxHp","maxHpMult");add("maxHp","maxHpAdd");
        mul("damage","damageMult");add("damage","damageAdd");
        mul("fireRate","fireRateMult");add("fireRate","fireRateAdd");
        mul("speed","speedMult");add("speed","speedAdd");
        mul("bulletSpeed","bulletSpeedMult");add("bulletSpeed","bulletSpeedAdd");
        add("bulletsPerShot","bulletsPerShotAdd");
        mul("spread","spreadMult");add("spread","spreadAdd");
        add("pierce","pierceAdd");
        add("onHitHeal","onHitHealAdd");
        add("healAfterWave","healAfterWaveAdd");
        mul("dashCooldown","dashCooldownMult");add("dashCooldown","dashCooldownAdd");
        mul("dashDuration","dashDurationMult");add("dashDuration","dashDurationAdd");
        mul("meleeDamage","meleeDamageMult");add("meleeDamage","meleeDamageAdd");
        mul("meleeRange","meleeRangeMult");add("meleeRange","meleeRangeAdd");
        mul("meleeArc","meleeArcMult");add("meleeArc","meleeArcAdd");
        mul("meleeCooldown","meleeCooldownMult");add("meleeCooldown","meleeCooldownAdd");
        add("meleeOnHitHeal","meleeOnHitHealAdd");

        if(m.incomingDamageMult){
          incomingDamageMult*=1+(m.incomingDamageMult-1)*f;
        }
        if(m.styleGainMult){
          styleGainMult*=1+(m.styleGainMult-1)*f;
        }
      }

      for(const id of allIds){
        const ab=getAbilityById(id);
        if(!ab)continue;
        applyMods(ab.mods,abilityFactor);
      }
      for(const id of activeCurses){
        const c=getCurseById(id);
        if(!c)continue;
        applyMods(c.mods,1);
      }

      stats.maxHp=Math.max(20,stats.maxHp);
      stats.damage=Math.max(1,stats.damage);
      stats.fireRate=Math.max(.4,stats.fireRate);
      stats.speed=Math.max(60,stats.speed);
      stats.bulletSpeed=Math.max(200,stats.bulletSpeed);
      stats.bulletsPerShot=Math.max(1,Math.round(stats.bulletsPerShot));
      stats.spread=clamp(stats.spread,0.02,.7);
      stats.pierce=Math.max(0,Math.round(stats.pierce));
      stats.onHitHeal=Math.max(0,stats.onHitHeal);
      stats.healAfterWave=Math.max(0,stats.healAfterWave);
      stats.dashCooldown=clamp(stats.dashCooldown,.25,3);
      stats.dashDuration=clamp(stats.dashDuration,.1,.6);
      stats.meleeDamage=Math.max(4,stats.meleeDamage);
      stats.meleeRange=Math.max(30,stats.meleeRange);
      stats.meleeArc=clamp(stats.meleeArc,.6,Math.PI*1.4);
      stats.meleeCooldown=clamp(stats.meleeCooldown,.15,2);
      stats.meleeOnHitHeal=Math.max(0,stats.meleeOnHitHeal);

      const newMax=stats.maxHp;
      if(keepHpRatio)player.hp=clamp(oldRatio*newMax,1,newMax);
      else player.hp=newMax;

      Object.assign(player,{
        maxHp:stats.maxHp,
        damage:stats.damage,
        fireRate:stats.fireRate,
        speed:stats.speed,
        bulletSpeed:stats.bulletSpeed,
        bulletsPerShot:stats.bulletsPerShot,
        spread:stats.spread,
        pierce:stats.pierce,
        onHitHeal:stats.onHitHeal,
        healAfterWave:stats.healAfterWave,
        dashCooldown:stats.dashCooldown,
        dashDuration:stats.dashDuration,
        meleeDamage:stats.meleeDamage,
        meleeRange:stats.meleeRange,
        meleeArc:stats.meleeArc,
        meleeCooldown:stats.meleeCooldown,
        meleeOnHitHeal:stats.meleeOnHitHeal,
        incomingDamageMult,
        styleGainMult
      });

      const allAbilityIds=[...player.normalAbilities,...player.bossAbilities];
      let dashMode="normal";
      if(allAbilityIds.includes("cursed_dash_bomb"))dashMode="bomb";
      if(allAbilityIds.includes("flame_step"))dashMode="flame";
      if(allAbilityIds.includes("blink_step"))dashMode="blink";
      player.dashMode=dashMode;
      player.lastStandActive=false;
    }

    /* ============== ULT & STYLE ============== */
    const ULT_DEFS={
      jjk_domain:{
        id:"jjk_domain",
        name:"Domain Expansion",
        cooldown:24,
        duration:6,
        damageMult:1.8,
        fireRateMult:1.1,
        pierceBonus:2,
        bulletSpeedMult:1.25,
        spawnsDomain:true,
        domainRadius:240,
        domainDpsMult:1.4,
        domainColor:"rgba(90,60,200,0.20)",
        domainEdgeColor:"rgba(210,180,255,0.95)"
      },
      ofa_100:{
        id:"ofa_100",
        name:"OFA 100%",
        cooldown:22,
        duration:5.5,
        damageMult:1.2,
        fireRateMult:1.5,
        speedMult:1.6
      },
      demon_mark:{
        id:"demon_mark",
        name:"Demon Mark",
        cooldown:26,
        duration:7,
        meleeDamageMult:2.3,
        meleeRangeMult:1.3,
        meleeHealBonus:1.2
      },
      gear_fifth:{
        id:"gear_fifth",
        name:"Gear Fifth",
        cooldown:28,
        duration:6,
        damageMult:1.5,
        fireRateMult:1.2,
        speedMult:1.3,
        bulletSpeedMult:1.2
      },
      susanoo_guardian:{
        id:"susanoo_guardian",
        name:"Susanoo Guardian",
        cooldown:28,
        duration:7,
        damageMult:1.25,
        speedMult:0.8,
        incomingDamageMult:0.5
      },
      cyber_sandevistan:{
        id:"cyber_sandevistan",
        name:"Cyber Sandevistan",
        cooldown:24,
        duration:5,
        speedMult:1.8,
        fireRateMult:1.3,
        incomingDamageMult:1.25
      },
      ghoul_rampage:{
        id:"ghoul_rampage",
        name:"Ghoul Rampage",
        cooldown:27,
        duration:6,
        meleeDamageMult:2.2,
        meleeRangeMult:1.3,
        meleeHealBonus:3
      },
      flame_domain:{
        id:"flame_domain",
        name:"Blazing Flame Ring",
        cooldown:26,
        duration:6,
        damageMult:1.2,
        fireRateMult:1.1,
        speedMult:1.05,
        spawnsDomain:true,
        domainRadius:230,
        domainDpsMult:1.3,
        domainColor:"rgba(255,140,80,0.24)",
        domainEdgeColor:"rgba(255,230,170,0.96)"
      },
      bankai_field:{
        id:"bankai_field",
        name:"Bankai Field",
        cooldown:28,
        duration:7,
        meleeDamageMult:1.8,
        meleeRangeMult:1.3,
        damageMult:1.15,
        fireRateMult:0.85,
        spawnsDomain:true,
        domainRadius:220,
        domainDpsMult:0,
        domainColor:"rgba(150,180,255,0.18)",
        domainEdgeColor:"rgba(220,230,255,0.96)"
      },
      haki_burst:{
        id:"haki_burst",
        name:"Conqueror's Haki Burst",
        cooldown:24,
        duration:4.5,
        damageMult:1.35,
        fireRateMult:1.15,
        spawnsDomain:true,
        domainRadius:260,
        domainDpsMult:0,
        domainColor:"rgba(255,245,180,0.24)",
        domainEdgeColor:"rgba(255,240,200,0.96)"
      }
    };

    function resetUltMultipliers(){
      if(!player)return;
      player.ultDamageMult=1;
      player.ultFireRateMult=1;
      player.ultSpeedMult=1;
      player.ultMeleeDamageMult=1;
      player.ultMeleeRangeMult=1;
      player.ultPierceBonus=0;
      player.ultMeleeHealBonus=0;
      player.ultBulletSpeedMult=1;
      player.ultIncomingDamageMult=1;
    }

    function gainStyle(amount){
      if(!player)return;
      const mult=player.styleGainMult||1;
      let bonus=1;
      if(currentWaveEvent==="curse_storm")bonus*=1.2;
      if(currentWaveEvent==="blood_moon")bonus*=1.1;
      player.styleMeter=clamp(player.styleMeter+amount*mult*bonus,0,player.styleMax);
    }

    function onPlayerDamaged(){
      gainStyle(-25);
    }

    function updateStyle(dt){
      if(!player)return;
      if(player.styleMeter>0){
        player.styleMeter=Math.max(0,player.styleMeter-player.styleDecayRate*dt);
      }
    }

    function tryUseUlt(){
      if(!player||gameState!=="playing")return;
      if(!player.ultId)return;
      if(player.ultActiveTimer>0)return;
      if(player.ultCooldownTimer>0)return;

      const def=ULT_DEFS[player.ultId];
      if(!def)return;

      player.ultActiveTimer=def.duration;
      player.ultCooldownTimer=def.cooldown;
      player.ultReady=false;
      resetUltMultipliers();
      if(def.damageMult)player.ultDamageMult=def.damageMult;
      if(def.fireRateMult)player.ultFireRateMult=def.fireRateMult;
      if(def.speedMult)player.ultSpeedMult=def.speedMult;
      if(def.meleeDamageMult)player.ultMeleeDamageMult=def.meleeDamageMult;
      if(def.meleeRangeMult)player.ultMeleeRangeMult=def.meleeRangeMult;
      if(def.pierceBonus)player.ultPierceBonus=def.pierceBonus;
      if(def.bulletSpeedMult)player.ultBulletSpeedMult=def.bulletSpeedMult; else player.ultBulletSpeedMult=1;
      player.ultMeleeHealBonus=def.meleeHealBonus||0;
      if(def.incomingDamageMult)player.ultIncomingDamageMult=def.incomingDamageMult; else player.ultIncomingDamageMult=1;

      if(def.spawnsDomain){
        domainField.active=true;
        domainField.x=player.x;
        domainField.y=player.y;
        domainField.radius=def.domainRadius||230;
        domainField.type=player.ultId;
        domainField.color=def.domainColor||"rgba(90,60,200,0.20)";
        domainField.edgeColor=def.domainEdgeColor||"rgba(210,180,255,0.95)";
        domainField.dpsMult=def.domainDpsMult||0;
      }

      addScreenShake(10,.4);
      addWhiteFlash(.6);
      spawnParticles(player.x,player.y,{count:40,speedMin:180,speedMax:360,sizeMin:3,sizeMax:6,color:"rgba(255,230,150,1)"});
      showMessage(def.name+"!",1.5);
    }

    function endUlt(){
      if(!player)return;
      domainField.active=false;
      domainField.type=null;
      domainField.dpsMult=0;
      resetUltMultipliers();
      player.ultActiveTimer=0;
      player.ultMeleeHealBonus=0;
      player.ultBulletSpeedMult=1;
      player.ultIncomingDamageMult=1;
    }

    function updateUlt(dt){
      if(!player)return;
      const id=player.ultId;
      if(!id)return;

      if(player.ultActiveTimer>0){
        player.ultActiveTimer-=dt;
        if(id==="demon_mark"){
          const drain=player.maxHp*0.03*dt;
          player.hp=Math.max(1,player.hp-drain);
        }
        if(player.ultActiveTimer<=0){
          endUlt();
        }
      }else{
        if(player.ultCooldownTimer>0){
          let styleFactor=1+(player.styleMeter/player.styleMax)*0.75;
          if(currentWaveEvent==="blood_moon")styleFactor*=1.25;
          player.ultCooldownTimer=Math.max(0,player.ultCooldownTimer-styleFactor*dt);
          if(player.ultCooldownTimer<=0){
            player.ultCooldownTimer=0;
            player.ultReady=true;
            addScreenShake(4,.2);
            spawnParticles(player.x,player.y,{count:18,speedMin:90,speedMax:200,sizeMin:2,sizeMax:4,color:"rgba(200,240,255,1)"});
            showMessage("ULT READY (Q)",1.8);
          }
        }
      }
    }

    /* ============== ABILITY / CURSE DEFINITIONS ============== */
    function addNormalAbility(id,name,rarity,description,mods,requires=null,requiresAll=null){
      normalAbilities.push({id,name,rarity,description,mods,requires,requiresAll,category:"normal"});
    }
    function addBossAbility(id,name,rarity,description,mods,requires=null,requiresAll=null,enemyMods=null){
      bossAbilities.push({id,name,rarity,description,mods,requires,requiresAll,enemyMods,category:"boss"});
    }
    function addCurse(id,name,rarity,description,mods,enemyMods){
      curses.push({id,name,rarity,description,mods,enemyMods,isCurse:true});
    }

    function initAbilities(){
      normalAbilities.length=0;bossAbilities.length=0;curses.length=0;

      // Core normal abilities
      addNormalAbility(
        "cursed_overflow","Cursed Overflow","Rare",
        "DMG +25%, on-hit heal +0.7, max HP -15%, wave heal -5.",
        {damageMult:1.25,onHitHealAdd:.7,maxHpMult:.85,healAfterWaveAdd:-5}
      );
      addNormalAbility(
        "quirk_booster","Quirk Booster","Common",
        "Fire rate +25%, speed +10%, DMG -10%, spread +15%.",
        {fireRateMult:1.25,speedMult:1.1,damageMult:.9,spreadMult:1.15}
      );
      addNormalAbility(
        "survey_maneuvers","Survey Maneuvers","Rare",
        "Speed +35%, dash CD -25%, max HP -10%, wave heal -5.",
        {speedMult:1.35,dashCooldownMult:.75,maxHpMult:.9,healAfterWaveAdd:-5}
      );
      addNormalAbility(
        "kaiju_instinct","Kaiju Instinct","Rare",
        "Max HP +50, DMG +15%, fire rate -10%, spread +10%.",
        {maxHpAdd:50,damageMult:1.15,fireRateMult:.9,spreadMult:1.1}
      );
      addNormalAbility(
        "shadow_garden","Shadow Garden Arts","Rare",
        "DMG +20%, spread -20%, fire rate -10%, speed -10%.",
        {damageMult:1.2,spreadMult:.8,fireRateMult:.9,speedMult:.9}
      );
      addNormalAbility(
        "edgerunner_core","Edgerunner Overclock","Epic",
        "Fire rate +35%, speed +20%, dash CD -20%, max HP -25%, wave heal -20.",
        {fireRateMult:1.35,speedMult:1.2,dashCooldownMult:.8,maxHpMult:.75,healAfterWaveAdd:-20}
      );

      // Black Flash
      addNormalAbility(
        "black_flash_rhythm","Black Flash Rhythm","Epic",
        "DMG +35%, fire rate +10%, on-hit heal +0.5, max HP -15%, spread +15%.",
        {damageMult:1.35,fireRateMult:1.1,onHitHealAdd:0.5,maxHpMult:0.85,spreadMult:1.15}
      );

      // Demon Slayer melee
      addNormalAbility(
        "water_breathing","Water Breathing","Rare",
        "Melee range +25%, melee CD -15%, bullet DMG -10%, wave heal -5.",
        {meleeRangeMult:1.25,meleeCooldownMult:.85,damageMult:.9,healAfterWaveAdd:-5}
      );
      addNormalAbility(
        "blood_edge","Blood-Edge Style","Rare",
        "Melee DMG +45%, melee lifesteal +0.8, melee CD +20%, max HP -10%.",
        {meleeDamageMult:1.45,meleeOnHitHealAdd:.8,meleeCooldownMult:1.2,maxHpMult:.9}
      );

      // Thunder Breathing
      addNormalAbility(
        "thunder_breathing","Thunder Breathing – First Form","Rare",
        "Speed +30%, dash CD -25%, dash duration -20%, max HP -10%.",
        {speedMult:1.3,dashCooldownMult:0.75,dashDurationMult:0.8,maxHpMult:0.9}
      );

      // Six Eyes precision
      addNormalAbility(
        "six_eyes","Six Eyes Focus","Epic",
        "Bullet speed +45%, spread -25%, DMG +20%, max HP -15%, wave heal -15.",
        {bulletSpeedMult:1.45,spreadMult:.75,damageMult:1.2,maxHpMult:.85,healAfterWaveAdd:-15}
      );
      addNormalAbility(
        "gear_shift","Gear Shift","Epic",
        "Fire rate +20%, DMG +15%, speed -10%, max HP -10%.",
        {fireRateMult:1.2,damageMult:1.15,speedMult:.9,maxHpMult:.9}
      );

      // "I Am Atomic"
      addNormalAbility(
        "i_am_atomic","\"I Am Atomic\" Focus","Epic",
        "DMG +45%, +1 bullet, spread +25%, max HP -25%, wave heal -20.",
        {damageMult:1.45,bulletsPerShotAdd:1,spreadMult:1.25,maxHpMult:0.75,healAfterWaveAdd:-20}
      );

      // Dash mods
      addNormalAbility(
        "cursed_dash_bomb","Cursed Dash Bomb","Rare",
        "Dash drops a bomb (big AOE DMG). Dash CD +15%, max HP -10%.",
        {dashCooldownMult:1.15,maxHpMult:.9}
      );
      addNormalAbility(
        "flame_step","Flame Step","Rare",
        "Dash burns around you. Dash duration -10%, wave heal -5.",
        {dashDurationMult:.9,healAfterWaveAdd:-5}
      );
      addNormalAbility(
        "blink_step","Blink Step","Epic",
        "Dash becomes short teleport with brief invuln. Dash CD -10%, max HP -10%.",
        {dashCooldownMult:.9,maxHpMult:.9}
      );
      addNormalAbility(
        "explosion_dash","Explosion Dash","Rare",
        "Dash leaves extra small explosions. Dash CD +15%, wave heal -5.",
        {dashCooldownMult:1.15,healAfterWaveAdd:-5}
      );
      // New dash abilities
      addNormalAbility(
        "thunder_flash_step","Thunder Flash Step","Epic",
        "Dash auto-slashes the first enemy in front for huge damage. Dash CD +20%, max HP -10%.",
        {dashCooldownMult:1.2,maxHpMult:0.9}
      );
      addNormalAbility(
        "blue_lock_slide","Blue Lock Slide","Rare",
        "Dash leaves lingering zones that slow enemies but dash distance -15%.",
        {dashDurationMult:0.85}
      );
      addNormalAbility(
        "blink_clone","Blink Clone Assault","Epic",
        "Requires Blink Step. When you blink, you leave a clone that slashes around your old spot. Dash CD +10%, wave heal -10.",
        {dashCooldownMult:1.1,healAfterWaveAdd:-10},
        null,
        ["blink_step"]
      );

      // Conqueror's Haki
      addNormalAbility(
        "conquerors_haki","Conqueror's Haki Pulse","Epic",
        "Nearby enemies are slowed. DMG +10%, you take +10% damage, wave heal -5.",
        {damageMult:1.1,incomingDamageMult:1.1,healAfterWaveAdd:-5}
      );

      // Fusions
      addNormalAbility(
        "limit_break","Limit Break State","Epic",
        "FUSION: Cursed Overflow + Quirk Booster. Huge DPS, max HP -25%, spread +25%.",
        {damageMult:1.35,fireRateMult:1.25,onHitHealAdd:1,maxHpMult:.75,spreadMult:1.25},
        null,["cursed_overflow","quirk_booster"]
      );
      addNormalAbility(
        "sky_ripper","Sky Ripper Maneuvers","Epic",
        "FUSION: Survey + Kaiju. Crazy mobility, max HP -15%, wave heal -15.",
        {speedMult:1.45,dashCooldownMult:.6,bulletSpeedMult:1.3,maxHpMult:.85,healAfterWaveAdd:-15},
        null,["survey_maneuvers","kaiju_instinct"]
      );
      addNormalAbility(
        "neon_ghoul","Neon Ghoul","Epic",
        "FUSION: Shadow Garden + Edgerunner. High risk, high sustain.",
        {damageMult:1.35,fireRateMult:1.25,onHitHealAdd:1.2,maxHpMult:.8,healAfterWaveAdd:-20},
        null,["shadow_garden","edgerunner_core"]
      );
      addNormalAbility(
        "rumbling_slayer","Rumbling Slayer","Epic",
        "FUSION: Survey Maneuvers + Thunder Breathing. Massive mobility, HP & heal hit.",
        {speedMult:1.45,dashCooldownMult:0.65,maxHpMult:0.8,healAfterWaveAdd:-15},
        null,["survey_maneuvers","thunder_breathing"]
      );

      // Broken limit
      addNormalAbility(
        "broken_limit","Broken Limit","Rare",
        "Removes cap on powers but halves all ability effects. Curses unaffected.",{}
      );

      // Solo Leveling / DB / Bleach / DMC
      addNormalAbility(
        "shadow_army_commander","Shadow Army Commander","Epic",
        "Pierce +1, each kill triggers a small shadow explosion. Max HP -10%.",
        {pierceAdd:1,maxHpMult:0.9}
      );
      addNormalAbility(
        "dagger_assassin","Dagger Assassin","Rare",
        "Melee DMG +30%, melee CD -20%, melee range -15%, max HP -10%.",
        {meleeDamageMult:1.3,meleeCooldownMult:0.8,meleeRangeMult:0.85,maxHpMult:0.9}
      );
      addNormalAbility(
        "kaioken_strain","Kaioken Strain","Epic",
        "DMG +30%, fire rate +20%. While firing, your HP slowly drains. Max HP -15%, wave heal -10.",
        {damageMult:1.3,fireRateMult:1.2,maxHpMult:0.85,healAfterWaveAdd:-10}
      );
      addNormalAbility(
        "ki_blast_overload","Ki Blast Overload","Rare",
        "+2 bullets per shot, DMG -20%, spread +25%, bullet speed -10%.",
        {bulletsPerShotAdd:2,damageMult:0.8,spreadMult:1.25,bulletSpeedMult:0.9}
      );
      addNormalAbility(
        "super_saiyan_focus","Super Saiyan Focus","Epic",
        "DMG +35%, bullet speed +10%, spread -15%, max HP -20%.",
        {damageMult:1.35,bulletSpeedMult:1.1,spreadMult:0.85,maxHpMult:0.8}
      );
      addNormalAbility(
        "spiritual_pressure","Spiritual Pressure","Epic",
        "Nearby enemies move slower. DMG +15%, you take +10% damage, wave heal -10.",
        {damageMult:1.15,incomingDamageMult:1.1,healAfterWaveAdd:-10}
      );
      addNormalAbility(
        "hollow_mask","Hollow Mask","Epic",
        "DMG +25%, fire rate +15%. You take +20% damage, wave heal -10.",
        {damageMult:1.25,fireRateMult:1.15,incomingDamageMult:1.2,healAfterWaveAdd:-10}
      );
      addNormalAbility(
        "devil_trigger_build","Devil Trigger Build","Rare",
        "Style gain +40%, DMG +10%. You take +10% damage, wave heal -10.",
        {styleGainMult:1.4,damageMult:1.1,incomingDamageMult:1.1,healAfterWaveAdd:-10}
      );
      addNormalAbility(
        "trickster_step","Trickster Step","Epic",
        "Dash distance +25%, dash CD -10%. You take +10% damage, max HP -10%.",
        {dashDurationMult:1.15,dashCooldownMult:0.9,incomingDamageMult:1.1,maxHpMult:0.9}
      );
      addNormalAbility(
        "rebellion_combo","Rebellion Combo","Epic",
        "Melee DMG +45%, melee range +10%, melee CD +15%, bullet DMG -15%.",
        {meleeDamageMult:1.45,meleeRangeMult:1.1,meleeCooldownMult:1.15,damageMult:0.85}
      );

      // Fire Force line
      addNormalAbility(
        "fire_force_spark","Fire Force Spark","Common",
        "Dash distance +10%, dash CD -5%, you take +10% more damage.",
        {dashDurationMult:1.1,dashCooldownMult:0.95,incomingDamageMult:1.1}
      );
      addNormalAbility(
        "infernal_engine","Infernal Engine","Rare",
        "DMG +20%, dash CD -10%, max HP -10%, wave heal -10.",
        {damageMult:1.2,dashCooldownMult:0.9,maxHpMult:0.9,healAfterWaveAdd:-10},
        null,
        ["fire_force_spark"]
      );

      // Tokyo Ghoul line
      addNormalAbility(
        "kagune_awakening","Kagune Awakening","Common",
        "Melee lifesteal +0.5, max HP -5%, wave heal -5.",
        {meleeOnHitHealAdd:0.5,maxHpMult:0.95,healAfterWaveAdd:-5}
      );
      addNormalAbility(
        "ghoul_feast","Ghoul Feast","Rare",
        "On-hit heal +1.0, melee lifesteal +1.0, wave heal -15.",
        {onHitHealAdd:1.0,meleeOnHitHealAdd:1.0,healAfterWaveAdd:-15},
        null,
        ["kagune_awakening"]
      );

      // Shadow / Eminence line addition
      addNormalAbility(
        "shadow_legion","Shadow Legion","Rare",
        "Style gain +25%, max HP -10%, wave heal -5.",
        {styleGainMult:1.25,maxHpMult:0.9,healAfterWaveAdd:-5},
        null,
        ["shadow_garden"]
      );

      // Boss powers (Legendary)
      addBossAbility(
        "domain_collapse","Domain Collapse","Legendary",
        "DMG x2.0, +2 bullets, fire rate +15%, max HP -40%, spread +50%, wave heal -30.",
        {damageMult:2,bulletsPerShotAdd:2,fireRateMult:1.15,maxHpMult:.6,spreadMult:1.5,healAfterWaveAdd:-30}
      );
      addBossAbility(
        "titan_ascend","Titan Ascendance","Legendary",
        "Max HP +40%, DMG +60%, pierce +2, speed -30%, wave heal -25.",
        {maxHpMult:1.4,damageMult:1.6,pierceAdd:2,speedMult:.7,healAfterWaveAdd:-25}
      );
      addBossAbility(
        "overclocked_quirk","Overclocked Quirk","Legendary",
        "Fire rate x2.0, speed +30%, max HP -50%, wave heal -35.",
        {fireRateMult:2,speedMult:1.3,maxHpMult:.5,healAfterWaveAdd:-35}
      );
      addBossAbility(
        "cursed_family","Cursed Family – Inverted Spear","Legendary",
        "Melee DMG x2.5, range +60%, melee CD -35%, lifesteal +2, bullets weaker.",
        {meleeDamageMult:2.5,meleeRangeMult:1.6,meleeCooldownMult:.65,meleeOnHitHealAdd:2,damageMult:.65,bulletsPerShotAdd:-1}
      );
      addBossAbility(
        "susanoo_avatar","Susanoo Avatar","Legendary",
        "Max HP +70%, incoming damage -25%, DMG +20%, speed -25%, fire rate -15%.",
        {maxHpMult:1.7,incomingDamageMult:0.75,damageMult:1.2,speedMult:0.75,fireRateMult:0.85}
      );
      addBossAbility(
        "shadow_monarch","Shadow Monarch","Legendary",
        "Pierce +1, on-hit heal +1.5, enemies spawn +25% and have +20% HP.",
        {pierceAdd:1,onHitHealAdd:1.5},
        null,
        null,
        {enemyCountMult:1.25,enemyHpMult:1.2}
      );
      addBossAbility(
        "infinity_barrier","Infinity Barrier","Legendary",
        "Max HP +30%, incoming damage -40%, fire rate -10%, speed -10%.",
        {maxHpMult:1.3,incomingDamageMult:0.6,fireRateMult:0.9,speedMult:0.9}
      );
      addBossAbility(
        "sun_breath_legend","Sun Breathing – Legend","Legendary",
        "DMG +80%, melee DMG +80%, max HP -35%, wave heal -30.",
        {damageMult:1.8,meleeDamageMult:1.8,maxHpMult:0.65,healAfterWaveAdd:-30}
      );
      addBossAbility(
        "gear_fifth_maniac","Gear Fifth Maniac","Legendary",
        "Speed +40%, fire rate +35%, max HP -30%, incoming damage +20%.",
        {speedMult:1.4,fireRateMult:1.35,maxHpMult:0.7,incomingDamageMult:1.2}
      );
      addBossAbility(
        "hollow_king","Hollow King Ascendant","Legendary",
        "DMG +40%, pierce +2, on-hit heal +1, wave heal -25.",
        {damageMult:1.4,pierceAdd:2,onHitHealAdd:1,healAfterWaveAdd:-25}
      );

      // Curses
      addCurse(
        "blood_moon","Blood Moon","Legendary",
        "DMG +25%, enemies faster and spawn +15%.",
        {damageMult:1.25},
        {enemySpeedMult:1.2,enemyCountMult:1.15}
      );
      addCurse(
        "fragile_rage","Fragile Rage","Legendary",
        "Fire rate +40%, max HP -40%.",
        {fireRateMult:1.4,maxHpMult:.6},
        {}
      );
      addCurse(
        "predator","Predator's Hunger","Legendary",
        "On-hit heal +2, enemies +25%.",
        {onHitHealAdd:2},
        {enemyCountMult:1.25}
      );
      addCurse(
        "all_or_nothing","All or Nothing","Legendary",
        "DMG x2.4, max HP -70%.",
        {damageMult:2.4,maxHpMult:.3},
        {}
      );
      addCurse(
        "cursed_eyes","Cursed Eyes – Blind Fury","Legendary",
        "DMG +35%, fire rate +20%, spread +40%, bullet speed -15%.",
        {damageMult:1.35,fireRateMult:1.2,spreadMult:1.4,bulletSpeedMult:0.85},
        {}
      );
      addCurse(
        "last_stand_oath","Last Stand Oath","Legendary",
        "If low HP, go berserk. Max HP -30%, wave heal -20.",
        {maxHpMult:0.7,healAfterWaveAdd:-20},
        {}
      );
      addCurse(
        "glass_cannon_pact","Glass Cannon Pact","Legendary",
        "DMG +45%, fire rate +20%, max HP -60%.",
        {damageMult:1.45,fireRateMult:1.2,maxHpMult:0.4},
        {}
      );
      addCurse(
        "devils_bargain","Devil's Bargain","Legendary",
        "DMG +40%, fire rate +20%. Heal after waves becomes 0 and you take +25% damage.",
        {damageMult:1.4,fireRateMult:1.2,healAfterWaveAdd:-999,incomingDamageMult:1.25},
        {}
      );
      addCurse(
        "eternal_tsukuyomi","Eternal Tsukuyomi","Legendary",
        "DMG +30%, fire rate +10%, max HP -30%, wave heal -25.",
        {damageMult:1.3,fireRateMult:1.1,maxHpMult:0.7,healAfterWaveAdd:-25},
        {}
      );
      addCurse(
        "limitless_void","Limitless Void","Legendary",
        "DMG +20%, bullet speed +40%. Enemy bullets deal +40% damage.",
        {damageMult:1.2,bulletSpeedMult:1.4},
        {enemyBulletDamageMult:1.4}
      );
    }

    /* ============== ABILITY UI & LOGIC ============== */
    function hideUpgradePanel(){upgradePanel.style.display="none";}
    function renderAbilitiesBar(){
      normalAbilitiesListEl.innerHTML="";
      bossAbilitiesListEl.innerHTML="";
      function addSlot(id,category,parent){
        const ab=getAbilityById(id); if(!ab)return;
        const rKey=(ab.rarity||"Common").toLowerCase();
        const slot=document.createElement("button");
        slot.className=`abilitySlot card-rarity-${rKey}`;
        slot.textContent=ab.name;
        slot.onclick=()=>onAbilitySlotClick(id,category);
        parent.appendChild(slot);
      }
      for(const id of player.normalAbilities)addSlot(id,"normal",normalAbilitiesListEl);
      for(const id of player.bossAbilities)addSlot(id,"boss",bossAbilitiesListEl);
    }

    function equipAbility(ability){
      if(ability.isCurse)return false;
      const isBoss=ability.category==="boss";
      const list=isBoss?player.bossAbilities:player.normalAbilities;
      const maxSlots=isBoss?2:5;
      const unlimited=hasBrokenLimit();

      if(list.includes(ability.id)){
        showMessage("Already have "+ability.name,2);
        return false;
      }
      if(unlimited||list.length<maxSlots){
        list.push(ability.id);
        recomputePlayerStats(true);
        renderAbilitiesBar();

        const r=ability.rarity||"Common";
        if(r==="Legendary"){
          addScreenShake(9,.4);addWhiteFlash(.6);
          spawnParticles(player.x,player.y,{count:32,speedMin:160,speedMax:320,sizeMin:3,sizeMax:6,color:"rgba(255,220,120,1)"});
        }else if(r==="Epic")addScreenShake(6,.3);
        else if(r==="Rare")addScreenShake(4,.2);
        return true;
      }
      // Need to replace: pause gameplay and let player choose a slot
      pendingAbility=ability;
      pendingCategory=ability.category;
      return null;
    }

    function onAbilitySlotClick(id,category){
      if(!pendingAbility)return;
      if(category!==pendingCategory){
        showMessage("Pick a "+(pendingCategory==="boss"?"boss":"normal")+" power to replace",2);
        return;
      }
      const list=category==="boss"?player.bossAbilities:player.normalAbilities;
      const idx=list.indexOf(id); if(idx===-1)return;
      list.splice(idx,1);
      list.push(pendingAbility.id);
      recomputePlayerStats(true);
      renderAbilitiesBar();
      showMessage(pendingAbility.name+" equipped",2);
      pendingAbility=null;pendingCategory=null;
      gameState="playing";
      startNextWave(); // start new wave after replacement is chosen
    }

    function getAbilityOptions(count,isBossWave){
      const owned=new Set([...player.normalAbilities,...player.bossAbilities]);
      const normalAvailable=normalAbilities.filter(a=>{
        if(owned.has(a.id))return false;
        if(a.requires&&!owned.has(a.requires))return false;
        if(a.requiresAll&&!a.requiresAll.every(id=>owned.has(id)))return false;
        return true;
      });
      const bossAvailable=isBossWave?bossAbilities.filter(a=>{
        if(owned.has(a.id))return false;
        if(a.requires&&!owned.has(a.requires))return false;
        if(a.requiresAll&&!a.requiresAll.every(id=>owned.has(id)))return false;
        return true;
      }):[];

      const options=[];
      const used=new Set();
      if(isBossWave){
        const pool=bossAvailable.length>0?bossAvailable:bossAbilities;
        const arr=shuffled(pool);
        if(arr[0]){options.push(arr[0]);used.add(arr[0].id);}
      }
      const needed=count-options.length;
      if(needed>0){
        let pool=normalAvailable.length>0?normalAvailable:normalAbilities;
        pool=shuffled(pool);
        for(const a of pool){
          if(options.length>=count)break;
          if(used.has(a.id))continue;
          options.push(a);used.add(a.id);
        }
      }
      return options;
    }

    function getCurseOptions(count){
      let available=curses.filter(c=>!activeCurses.includes(c.id));
      if(available.length===0)available=curses.slice();
      return shuffled(available).slice(0,count);
    }

    function takeCurse(curse){
      if(hasCurse(curse.id)){showMessage("Already cursed by "+curse.name,2);return false;}
      activeCurses.push(curse.id);
      recomputeEnemyScale();
      recomputePlayerStats(true);
      addScreenShake(7,.35);addWhiteFlash(.45);
      spawnParticles(player.x,player.y,{count:24,speedMin:120,speedMax:260,sizeMin:3,sizeMax:5,color:"rgba(200,120,255,1)"});
      return true;
    }

    function showUpgradePanel(options){
      upgradePanel.style.display="flex";
      upgradesContainer.innerHTML="";
      for(const opt of options){
        const isCurse=!!opt.isCurse;
        const rKey=(opt.rarity||"Common").toLowerCase();
        const badgeClass=`rarityBadge rarity-${rKey}`;
        const cardClass=`upgradeButton card-rarity-${rKey}`;
        const badgeText=isCurse?"CURSE":opt.rarity||"Common";
        const btn=document.createElement("button");
        btn.className=cardClass;
        btn.innerHTML=
          `<div class="upgradeTopRow">
             <span class="upgradeName">${opt.name}</span>
             <span class="${badgeClass}">${badgeText}</span>
           </div>
           <span class="upgradeDesc">${opt.description}</span>`;
        btn.onclick=()=>{
          if(isCurse){
            if(takeCurse(opt)){
              hideUpgradePanel();
              gameState="playing";
              startNextWave();
            }
          }else{
            const res=equipAbility(opt);
            if(res===true){
              hideUpgradePanel();
              gameState="playing";
              startNextWave();
            }else if(res===null){
              // Need to replace something: PAUSE game and wait for click on bottom bar
              hideUpgradePanel();
              gameState="chooseReplace";
              showMessage("Click a "+(opt.category==="boss"?"boss":"normal")+" power at the bottom to replace",999);
            }
          }
        };
        upgradesContainer.appendChild(btn);
      }
    }

    /* ============== ENEMIES & WAVES (w/ mini-boss, elites, events) ============== */
    function spawnEnemy(isBoss=false){
      const margin=40;
      let x,y;
      do{
        x=Math.random()*(canvas.width-margin*2)+margin;
        y=Math.random()*(canvas.height-margin*2)+margin;
      }while(player && distance(x,y,player.x,player.y)<160);

      if(isBoss){
        const index=Math.max(0,Math.floor(wave/5)-1)%BOSS_TEMPLATES.length;
        const bossTemplate=BOSS_TEMPLATES[index];
        let hpBase=(320+wave*30)*enemyScale.hpMult;
        const speed=(90+wave*4.5)*enemyScale.speedMult;
        let contactDamage=(35+wave*2.4)*enemyScale.damageMult;
        if(currentWaveEvent==="blood_moon")contactDamage*=1.2;
        const e={
          x,y,radius:42,speed,
          hp:hpBase,maxHp:hpBase,
          contactDamage,isBoss:true,
          isMiniBoss:false,
          phase:1,
          ringCooldown:2.7,
          rushCooldown:3.1,
          crossCooldown:4.5,
          coneCooldown:5.2,
          bossId:bossTemplate.id,
          bossName:bossTemplate.name,
          bossColor:bossTemplate.color,
          mahitoTouchCooldown:0,
          genjutsuCooldown:0,
          slamCooldown:0,
          slamWindup:0,
          slamWindupMax:1.5,
          barrierRadius:0
        };
        if(e.bossId==="itachi"){
          e.genjutsuCooldown=7;
        }else if(e.bossId==="gojo"){
          e.barrierRadius=140;
        }else if(e.bossId==="luffy"){
          e.slamCooldown=6;
          e.slamWindup=0;
          e.slamWindupMax=1.5;
        }
        enemies.push(e);
      }else{
        let hpBase=(28+wave*4.5)*enemyScale.hpMult;
        let speed=(130+wave*7)*enemyScale.speedMult;
        let contactDamage=(9+wave*1.1)*enemyScale.damageMult;
        if(currentWaveEvent==="blood_moon")contactDamage*=1.2;

        // Elite chance
        let eliteChance=0.08+wave*0.004;
        if(currentWaveEvent==="hunt_night")eliteChance*=2;
        eliteChance=clamp(eliteChance,0,0.5);
        const isElite=Math.random()<eliteChance;

        const r=Math.random();
        let type="runner";
        if(wave>=3&&r<.25)type="sniper";
        else if(wave>=5&&r<.5)type="bomber";
        let radius=16;
        if(type==="sniper"){speed*=.8;radius=17;}
        if(type==="bomber"){speed*=1.05;contactDamage*=2;radius=18;}

        if(isElite){
          hpBase*=1.8;
          speed*=1.1;
          contactDamage*=1.3;
          radius+=2;
        }

        const e={x,y,radius,speed,hp:hpBase,maxHp:hpBase,contactDamage,type,isBoss:false,isMiniBoss:false,isElite};
        if(type==="sniper"){e.shotCooldown=2.2;e.strafeDir=Math.random()<.5?-1:1;}
        enemies.push(e);
      }
    }

    function spawnMiniBoss(){
      const margin=60;
      let x,y;
      do{
        x=Math.random()*(canvas.width-margin*2)+margin;
        y=Math.random()*(canvas.height-margin*2)+margin;
      }while(player && distance(x,y,player.x,player.y)<180);
      const template=MINI_BOSS_TEMPLATES[Math.floor(Math.random()*MINI_BOSS_TEMPLATES.length)];
      let hpBase=(220+wave*26)*enemyScale.hpMult;
      let speed=(120+wave*5)*enemyScale.speedMult;
      let contactDamage=(24+wave*1.8)*enemyScale.damageMult;
      if(currentWaveEvent==="blood_moon")contactDamage*=1.2;
      enemies.push({
        x,y,
        radius:28,
        speed,
        hp:hpBase,
        maxHp:hpBase,
        contactDamage,
        type:"miniboss",
        isBoss:false,
        isMiniBoss:true,
        isElite:false,
        miniBossId:template.id,
        miniBossName:template.name,
        miniBossColor:template.color,
        pattern:template.pattern,
        coneCooldown:2.4,
        rushCooldown:3.0,
        spinCooldown:4.0
      });
    }

    function spawnEnemyBulletAtPlayer(e,speed){
      const dx=player.x-e.x,dy=player.y-e.y;
      const dist=Math.hypot(dx,dy)||1;
      const v=speed*enemyScale.bulletSpeedMult;
      const vx=dx/dist*v,vy=dy/dist*v;
      let dmg=(14+wave*1.4)*enemyScale.bulletDamageMult;
      if(currentWaveEvent==="blood_moon")dmg*=1.2;
      enemyBullets.push({x:e.x,y:e.y,vx,vy,radius:4,damage:dmg});
    }

    function spawnBossRing(e,count,speed){
      const v=speed*enemyScale.bulletSpeedMult;
      let dmg=(16+wave*1.5)*enemyScale.bulletDamageMult;
      if(currentWaveEvent==="blood_moon")dmg*=1.2;
      for(let i=0;i<count;i++){
        const ang=Math.PI*2*i/count;
        enemyBullets.push({
          x:e.x,y:e.y,
          vx:Math.cos(ang)*v,
          vy:Math.sin(ang)*v,
          radius:4,
          damage:dmg
        });
      }
    }

    function spawnBossCross(e,speed){
      const v=speed*enemyScale.bulletSpeedMult;
      let dmg=(14+wave*1.3)*enemyScale.bulletDamageMult;
      if(currentWaveEvent==="blood_moon")dmg*=1.2;
      const dirs=[
        [1,0],[-1,0],[0,1],[0,-1],
        [Math.SQRT1_2,Math.SQRT1_2],
        [-Math.SQRT1_2,Math.SQRT1_2],
        [Math.SQRT1_2,-Math.SQRT1_2],
        [-Math.SQRT1_2,-Math.SQRT1_2]
      ];
      for(const[dX,dY]of dirs){
        enemyBullets.push({
          x:e.x,y:e.y,
          vx:dX*v,
          vy:dY*v,
          radius:4,
          damage:dmg
        });
      }
    }

    function spawnBossConeAtPlayer(e,count,spread,speed){
      const dx=player.x-e.x,dy=player.y-e.y;
      const base=Math.atan2(dy,dx);
      const half=spread/2;
      const v=speed*enemyScale.bulletSpeedMult;
      let dmg=(15+wave*1.4)*enemyScale.bulletDamageMult;
      if(currentWaveEvent==="blood_moon")dmg*=1.2;
      if(count<=1){
        enemyBullets.push({x:e.x,y:e.y,vx:Math.cos(base)*v,vy:Math.sin(base)*v,radius:4,damage:dmg});
        return;
      }
      for(let i=0;i<count;i++){
        const t=count===1?0:i/(count-1);
        const ang=base-half+spread*t;
        enemyBullets.push({
          x:e.x,y:e.y,
          vx:Math.cos(ang)*v,
          vy:Math.sin(ang)*v,
          radius:4,
          damage:dmg
        });
      }
    }

    function triggerBomberExplosion(e){
      const radius=90;
      let baseDamage=(24+wave*2)*enemyScale.damageMult;
      if(currentWaveEvent==="blood_moon")baseDamage*=1.2;
      const distToPlayer=distance(e.x,e.y,player.x,player.y);
      if(distToPlayer<=radius+player.radius&&!player.isDashing){
        const dmg=baseDamage*(player.incomingDamageMult||1)*(player.ultIncomingDamageMult||1);
        player.hp-=dmg;
        onPlayerDamaged();
        if(player.hp<=0){player.hp=0;gameOver();}
      }
      fireBursts.push({x:e.x,y:e.y,radius,life:.25,maxLife:.25,color:"#ff7744"});
    }

    function updateMiniBoss(e,dt,slowRadius,slowMult){
      const dx=player.x-e.x,dy=player.y-e.y;
      const dist=Math.hypot(dx,dy)||1;
      const dirX=dx/dist,dirY=dy/dist;

      let speedMul=1;
      if(slowRadius>0 && distance(e.x,e.y,player.x,player.y)<slowRadius) speedMul*=slowMult;
      if(domainField.active && domainField.type==="haki_burst"){
        if(distance(e.x,e.y,domainField.x,domainField.y)<domainField.radius+e.radius) speedMul*=0.6;
      }
      if(slowFields.length>0){
        for(const f of slowFields){
          if(distance(e.x,e.y,f.x,f.y)<f.radius+e.radius){
            speedMul*=f.slowMult||0.6;
            break;
          }
        }
      }

      const stepSpeed=e.speed*speedMul;
      e.x+=dirX*stepSpeed*dt;
      e.y+=dirY*stepSpeed*dt;
      e.x=clamp(e.x,e.radius,canvas.width-e.radius);
      e.y=clamp(e.y,e.radius,canvas.height-e.radius);

      if(e.pattern==="cone"){
        e.coneCooldown-=dt;
        if(e.coneCooldown<=0){
          const count=7;
          spawnBossConeAtPlayer(e,count,Math.PI/3,210+wave*2.5);
          e.coneCooldown=2.7;
        }
      }else if(e.pattern==="rush"){
        e.rushCooldown-=dt;
        if(e.rushCooldown<=0){
          const rushSpeed=e.speed*2.5;
          e.x+=dirX*rushSpeed*dt*0.4;
          e.y+=dirY*rushSpeed*dt*0.4;
          fireBursts.push({x:e.x,y:e.y,radius:80,life:.2,maxLife:.2,color:"#ff88cc"});
          e.rushCooldown=3.4;
        }
      }else if(e.pattern==="spin"){
        e.spinCooldown-=dt;
        if(e.spinCooldown<=0){
          spawnBossRing(e,10,230+wave*2.5);
          e.spinCooldown=3.6;
        }
      }

      const distToPlayer=distance(e.x,e.y,player.x,player.y);
      const minDist=e.radius+player.radius;
      if(distToPlayer<minDist){
        const overlap=minDist-distToPlayer;
        const px=(player.x-e.x)/(distToPlayer||1);
        const py=(player.y-e.y)/(distToPlayer||1);
        player.x+=px*overlap*.5;
        player.y+=py*overlap*.5;
        e.x-=px*overlap*.5;
        e.y-=py*overlap*.5;
        if(!player.isDashing){
          const dmg=e.contactDamage*dt*(player.incomingDamageMult||1)*(player.ultIncomingDamageMult||1);
          player.hp-=dmg;
          onPlayerDamaged();
          if(player.hp<=0){player.hp=0;gameOver();}
        }
      }
    }

    function updateEnemies(dt){
      const hasHaki=player && (player.normalAbilities.includes("conquerors_haki")||player.bossAbilities.includes("conquerors_haki"));
      const hasPressure=player && (player.normalAbilities.includes("spiritual_pressure")||player.bossAbilities.includes("spiritual_pressure"));
      let slowRadius=0;
      let slowMult=1;
      if(hasHaki){
        slowRadius=Math.max(slowRadius,260);
        slowMult*=0.8;
      }
      if(hasPressure){
        slowRadius=Math.max(slowRadius,230);
        slowMult*=0.85;
      }

      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        if(e.isBoss){updateBoss(e,dt,slowRadius,slowMult);continue;}
        if(e.isMiniBoss){updateMiniBoss(e,dt,slowRadius,slowMult);continue;}

        const dx=player.x-e.x,dy=player.y-e.y;
        const dist=Math.hypot(dx,dy)||1;
        const dirX=dx/dist,dirY=dy/dist;

        let speedMul=1;
        if(slowRadius>0 && dist<slowRadius) speedMul*=slowMult;
        if(domainField.active && domainField.type==="haki_burst"){
          if(distance(e.x,e.y,domainField.x,domainField.y)<domainField.radius+e.radius) speedMul*=0.6;
        }
        if(slowFields.length>0){
          for(const f of slowFields){
            if(distance(e.x,e.y,f.x,f.y)<f.radius+e.radius){
              speedMul*=f.slowMult||0.6;
              break;
            }
          }
        }

        if(e.type==="sniper"){
          const minDist=260,maxDist=360;
          let moveX=0,moveY=0;
          if(dist<minDist){moveX=-dirX;moveY=-dirY;}
          else if(dist>maxDist){moveX=dirX;moveY=dirY;}
          else{moveX=-dy*e.strafeDir/dist;moveY=dx*e.strafeDir/dist;}
          let len=Math.hypot(moveX,moveY)||1;
          moveX/=len;moveY/=len;
          const stepSpeed=e.speed*speedMul;
          let nx=e.x+moveX*stepSpeed*dt;
          let ny=e.y+moveY*stepSpeed*dt;
          if(nx<e.radius||nx>canvas.width-e.radius){
            e.strafeDir=-e.strafeDir;
            nx=clamp(nx,e.radius,canvas.width-e.radius);
          }
          if(ny<e.radius||ny>canvas.height-e.radius){
            e.strafeDir=-e.strafeDir;
            ny=clamp(ny,e.radius,canvas.height-e.radius);
          }
          e.x=nx;e.y=ny;
          e.shotCooldown-=dt;
          if(e.shotCooldown<=0){
            spawnEnemyBulletAtPlayer(e,250+wave*2.8);
            e.shotCooldown=2.4;
          }
        }else{
          const stepSpeed=e.speed*speedMul;
          e.x+=dirX*stepSpeed*dt;
          e.y+=dirY*stepSpeed*dt;
        }

        e.x=clamp(e.x,e.radius,canvas.width-e.radius);
        e.y=clamp(e.y,e.radius,canvas.height-e.radius);

        const distToPlayer=distance(e.x,e.y,player.x,player.y);
        const minDist=e.radius+player.radius;
        if(distToPlayer<minDist){
          const overlap=minDist-distToPlayer;
          const px=(player.x-e.x)/(distToPlayer||1);
          const py=(player.y-e.y)/(distToPlayer||1);
          player.x+=px*overlap*.5;
          player.y+=py*overlap*.5;
          e.x-=px*overlap*.5;
          e.y-=py*overlap*.5;

          if(e.type==="bomber"){
            triggerBomberExplosion(e);
            enemies.splice(i,1);
            continue;
          }
          if(!player.isDashing){
            const dmg=e.contactDamage*dt*(player.incomingDamageMult||1)*(player.ultIncomingDamageMult||1);
            player.hp-=dmg;
            onPlayerDamaged();
            if(player.hp<=0){player.hp=0;gameOver();return;}
          }
        }
      }
    }

    function updateBoss(e,dt,slowRadius,slowMult){
      if(e.bossId==="mahito" && e.mahitoTouchCooldown>0){
        e.mahitoTouchCooldown=Math.max(0,e.mahitoTouchCooldown-dt);
      }

      if(e.bossId==="itachi"){
        if(e.genjutsuCooldown>0)e.genjutsuCooldown-=dt;
        if(e.genjutsuCooldown<=0){
          e.genjutsuCooldown=e.phase===1?11:e.phase===2?9:7;
          bossGenjutsuTimer=GENJUTSU_DURATION;
          showMessage("Itachi's Tsukuyomi!",2.5);
          addScreenShake(6,0.35);
        }
      }

      if(e.bossId==="luffy"){
        if(e.slamCooldown>0)e.slamCooldown-=dt;
        if(e.slamWindup>0){
          e.slamWindup-=dt;
          if(e.slamWindup<=0){
            const slamRadius=200;
            const distToPlayer=distance(e.x,e.y,player.x,player.y);
            if(distToPlayer<=slamRadius+player.radius && !player.isDashing){
              let slamDmg=(30+wave*3)*enemyScale.damageMult;
              if(currentWaveEvent==="blood_moon")slamDmg*=1.2;
              slamDmg*= (player.incomingDamageMult||1)*(player.ultIncomingDamageMult||1);
              player.hp-=slamDmg;
              onPlayerDamaged();
              if(player.hp<=0){
                player.hp=0;
                gameOver();
                return;
              }
            }
            fireBursts.push({x:e.x,y:e.y,radius:slamRadius,life:0.3,maxLife:0.3,color:"#ffd27f"});
            addScreenShake(9,0.45);
            addWhiteFlash(0.25);
            e.slamCooldown=e.phase===1?9:e.phase===2?7:5;
          }
        }else if(e.slamCooldown<=0){
          e.slamWindup=1.5;
          e.slamWindupMax=1.5;
          showMessage("Gear Fifth Slam incoming!",1.6);
        }
      }

      const ratio=e.hp/e.maxHp;
      if(e.phase===1&&ratio<=.66){
        e.phase=2;
        if(e.bossId==="mahito"){
          showMessage("Mahito's Domain Expansion!",2.8);
        }else{
          showMessage("Boss Phase 2!",2);
        }
        addScreenShake(8,.35);addWhiteFlash(.3);
        spawnParticles(e.x,e.y,{count:28,speedMin:150,speedMax:320,sizeMin:3,sizeMax:5,color:"rgba(255,220,140,1)"});
      }else if(e.phase===2&&ratio<=.33){
        e.phase=3;showMessage("Boss Final Phase!",2.5);
        addScreenShake(10,.4);addWhiteFlash(.4);
        spawnParticles(e.x,e.y,{count:32,speedMin:170,speedMax:340,sizeMin:3,sizeMax:6,color:"rgba(255,150,150,1)"});
      }

      const dx=player.x-e.x,dy=player.y-e.y;
      const dist=Math.hypot(dx,dy)||1;
      const dirX=dx/dist,dirY=dy/dist;
      let moveSpeed=e.speed*(e.phase===1?.7:e.phase===2?.9:1.05);
      if(slowRadius>0 && distance(e.x,e.y,player.x,player.y)<slowRadius) moveSpeed*=slowMult;
      if(domainField.active && domainField.type==="haki_burst"){
        if(distance(e.x,e.y,domainField.x,domainField.y)<domainField.radius+e.radius) moveSpeed*=0.6;
      }
      if(slowFields.length>0){
        for(const f of slowFields){
          if(distance(e.x,e.y,f.x,f.y)<f.radius+e.radius){
            moveSpeed*=f.slowMult||0.6;
            break;
          }
        }
      }
      e.x+=dirX*moveSpeed*dt;
      e.y+=dirY*moveSpeed*dt;
      e.x=clamp(e.x,e.radius,canvas.width-e.radius);
      e.y=clamp(e.y,e.radius,canvas.height-e.radius);

      e.ringCooldown-=dt;
      if(e.ringCooldown<=0){
        const base=8+Math.min(8,Math.floor(wave/2));
        const count=e.phase===1?base:e.phase===2?base+4:base+8;
        spawnBossRing(e,count,210+wave*3.5+20*e.phase);
        e.ringCooldown=e.phase===1?3.2:e.phase===2?2.7:2.2;
      }

      e.rushCooldown-=dt;
      if(e.rushCooldown<=0){
        spawnEnemyBulletAtPlayer(e,250+wave*3+20*e.phase);
        if(e.phase>=2)spawnEnemyBulletAtPlayer(e,260+wave*3.5+30*e.phase);
        e.rushCooldown=e.phase===1?2.4:e.phase===2?1.9:1.5;
      }

      e.crossCooldown-=dt;
      if(e.crossCooldown<=0&&e.phase>=2){
        spawnBossCross(e,220+wave*3+15*e.phase);
        e.crossCooldown=e.phase===2?5:4;
      }

      e.coneCooldown-=dt;
      if(e.coneCooldown<=0){
        const count=e.phase===1?9:e.phase===2?13:17;
        spawnBossConeAtPlayer(e,count,Math.PI/2.8,230+wave*3.2+10*e.phase);
        e.coneCooldown=e.phase===1?5.4:e.phase===2?4.4:3.6;
      }

      if(e.bossId==="mahito" && e.phase>=2){
        const domR=230;
        const distDom=distance(e.x,e.y,player.x,player.y);
        if(distDom<=domR+player.radius && !player.isDashing){
          let domDps=player.maxHp*0.035*dt;
          if(currentWaveEvent==="blood_moon")domDps*=1.15;
          domDps*= (player.incomingDamageMult||1)*(player.ultIncomingDamageMult||1);
          player.hp-=domDps;
          onPlayerDamaged();
          if(player.hp<=0){
            player.hp=0;
            gameOver();
            return;
          }
        }
      }

      const distToPlayer2=distance(e.x,e.y,player.x,player.y);
      const minDist=e.radius+player.radius;
      if(distToPlayer2<minDist){
        const overlap=minDist-distToPlayer2;
        const px=(player.x-e.x)/(distToPlayer2||1);
        const py=(player.y-e.y)/(distToPlayer2||1);
        player.x+=px*overlap*.5;
        player.y+=py*overlap*.5;
        e.x-=px*overlap*.5;
        e.y-=py*overlap*.5;
        if(!player.isDashing){
          if(e.bossId==="mahito"){
            if(e.mahitoTouchCooldown<=0){
              player.mahitoTouchStacks=(player.mahitoTouchStacks||0)+1;
              e.mahitoTouchCooldown=1.0;
              if(player.mahitoTouchStacks>=2){
                player.hp=0;
                onPlayerDamaged();
                showMessage("Mahito reshaped your soul.",3.5);
                gameOver();
                return;
              }else{
                onPlayerDamaged();
                showMessage("Mahito touched your soul ("+player.mahitoTouchStacks+"/2)",2.3);
              }
            }
          }else{
            let dmg=e.contactDamage*dt*1.2;
            dmg*= (player.incomingDamageMult||1)*(player.ultIncomingDamageMult||1);
            player.hp-=dmg;
            onPlayerDamaged();
            if(player.hp<=0){player.hp=0;gameOver();return;}
          }
        }
      }
    }

    function updateEnemyBullets(dt){
      for(let i=enemyBullets.length-1;i>=0;i--){
        const b=enemyBullets[i];
        b.x+=b.vx*dt;
        b.y+=b.vy*dt;
        if(b.x<-50||b.x>canvas.width+50||b.y<-50||b.y>canvas.height+50){
          enemyBullets.splice(i,1);continue;
        }
        const distToPlayer=distance(b.x,b.y,player.x,player.y);
        if(distToPlayer<b.radius+player.radius){
          if(!player.isDashing){
            const dmg=b.damage*(player.incomingDamageMult||1)*(player.ultIncomingDamageMult||1);
            player.hp-=dmg;
            onPlayerDamaged();
            if(player.hp<=0){player.hp=0;gameOver();}
          }
          enemyBullets.splice(i,1);
        }
      }
    }

    function damageEnemiesInRadius(x,y,radius,damage,triggerEffects=true){
      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        if(distance(e.x,e.y,x,y)<=radius+e.radius){
          e.hp-=damage;
          gainStyle(4);
          if(e.hp<=0){
            gainStyle(6);
            if(triggerEffects) triggerOnKillEffects(e.x,e.y);
            if(e.isBoss){
              spawnParticles(e.x,e.y,{count:40,speedMin:150,speedMax:350,sizeMin:3,sizeMax:6,color:"rgba(255,210,140,1)"});
              addScreenShake(11,.5);
            }
            if(e.type==="bomber")triggerBomberExplosion(e);
            enemies.splice(i,1);
          }
        }
      }
    }

    function triggerOnKillEffects(x,y){
      if(!player)return;
      if(player.normalAbilities.includes("shadow_army_commander")||player.bossAbilities.includes("shadow_army_commander")){
        const radius=80;
        const dmg=player.damage*1.0+20;
        damageEnemiesInRadius(x,y,radius,dmg,false);
        fireBursts.push({x,y,radius,life:.18,maxLife:.18,color:"#6f5cff"});
      }
    }

    /* ============== DASH / MELEE / BULLETS ============== */
    function startDash(){
      if(!player||gameState!=="playing")return;
      if(player.dashActiveTimer>0||player.dashCooldownTimer>0)return;

      let dirX=0,dirY=0;
      if(keys["w"]||keys["arrowup"])dirY-=1;
      if(keys["s"]||keys["arrowdown"])dirY+=1;
      if(keys["a"]||keys["arrowleft"])dirX-=1;
      if(keys["d"]||keys["arrowright"])dirX+=1;
      let len=Math.hypot(dirX,dirY);
      if(len===0){
        dirX=mousePos.x-player.x;
        dirY=mousePos.y-player.y;
        len=Math.hypot(dirX,dirY)||1;
      }
      dirX/=len;dirY/=len;

      const startX=player.x;
      const startY=player.y;

      spawnParticles(player.x,player.y,{count:18,speedMin:90,speedMax:220,sizeMin:2,sizeMax:4,color:"rgba(160,220,255,1)"});

      const hasThunderFlash=player.normalAbilities.includes("thunder_flash_step")||player.bossAbilities.includes("thunder_flash_step");
      const hasBlueLock=player.normalAbilities.includes("blue_lock_slide")||player.bossAbilities.includes("blue_lock_slide");
      const hasBlinkClone=player.normalAbilities.includes("blink_clone")||player.bossAbilities.includes("blink_clone");

      if(hasThunderFlash && enemies.length>0){
        let best=null;
        let bestDist=999999;
        for(const e of enemies){
          if(e.isBoss||e.isMiniBoss)continue;
          const ex=e.x-startX,ey=e.y-startY;
          const dist=Math.hypot(ex,ey);
          if(dist>260+e.radius)continue;
          const dot=(ex*dirX+ey*dirY)/(dist||1);
          if(dot<0.9)continue;
          if(dist<bestDist){
            bestDist=dist;
            best=e;
          }
        }
        if(best){
          const slashDamage=player.meleeDamage*2.5+player.damage*1.2;
          best.hp-=slashDamage;
          gainStyle(6);
          spawnParticles(best.x,best.y,{count:20,speedMin:140,speedMax:260,sizeMin:2,sizeMax:4,color:"rgba(255,220,160,1)"});
          addScreenShake(6,0.25);
          if(best.hp<=0){
            const idx=enemies.indexOf(best);
            if(idx>=0){
              if(best.type==="bomber")triggerBomberExplosion(best);
              triggerOnKillEffects(best.x,best.y);
              enemies.splice(idx,1);
            }
          }
        }
      }

      let dashSpeed=player.speed*4*player.ultSpeedMult;
      if(player.normalAbilities.includes("trickster_step")||player.bossAbilities.includes("trickster_step")){
        dashSpeed*=1.25;
      }

      if(player.dashMode==="blink"){
        if(hasBlueLock){
          const blinkDist=180;
          const pathLen=blinkDist;
          const segments=3;
          for(let i=1;i<=segments;i++){
            const fx=startX+dirX*pathLen*(i/(segments+1));
            const fy=startY+dirY*pathLen*(i/(segments+1));
            slowFields.push({
              x:fx,y:fy,
              radius:80,
              life:1.6,
              maxLife:1.6,
              slowMult:0.55
            });
          }
        }
        if(hasBlinkClone){
          const cloneRadius=110;
          const cloneDamage=player.meleeDamage*2.1+player.damage*1.2+20;
          damageEnemiesInRadius(startX,startY,cloneRadius,cloneDamage);
          fireBursts.push({x:startX,y:startY,radius:cloneRadius,life:.22,maxLife:.22,color:"#c4e4ff"});
          addScreenShake(5,0.25);
        }

        const blinkDist=180;
        const tx=player.x+dirX*blinkDist;
        const ty=player.y+dirY*blinkDist;
        player.x=clamp(tx,player.radius,canvas.width-player.radius);
        player.y=clamp(ty,player.radius,canvas.height-player.radius);
        player.dashVelX=0;player.dashVelY=0;
        player.dashActiveTimer=Math.max(.12,player.dashDuration*.6);
        player.dashCooldownTimer=player.dashCooldown;
        player.isDashing=true;
        return;
      }

      if(hasBlueLock){
        const dashDist=dashSpeed*player.dashDuration;
        const segments=3;
        for(let i=1;i<=segments;i++){
          const fx=startX+dirX*dashDist*(i/(segments+1));
          const fy=startY+dirY*dashDist*(i/(segments+1));
          slowFields.push({
            x:fx,y:fy,
            radius:70,
            life:1.6,
            maxLife:1.6,
            slowMult:0.55
          });
        }
      }

      if(player.dashMode==="bomb"){
        const r=120;
        const dmg=player.damage*3+40+wave*4;
        const fuse=.55;
        playerBombs.push({x:player.x,y:player.y,radius:r,damage:dmg,fuse,maxFuse:fuse});
      }
      if(player.dashMode==="flame"){
        const r=130;
        const dmg=player.damage*2.1+30+wave*3;
        damageEnemiesInRadius(player.x,player.y,r,dmg);
        fireBursts.push({x:player.x,y:player.y,radius:r,life:.2,maxLife:.2,color:"#ff7b47"});
      }

      if(player.normalAbilities.includes("explosion_dash")||player.bossAbilities.includes("explosion_dash")){
        const rSmall=80;
        const dmgSmall=player.damage*2+20+wave*3;
        const fuseSmall=.35;
        playerBombs.push({x:player.x,y:player.y,radius:rSmall,damage:dmgSmall,fuse:fuseSmall,maxFuse:fuseSmall});
      }

      const dashVx=dirX*dashSpeed;
      const dashVy=dirY*dashSpeed;
      player.dashVelX=dashVx;
      player.dashVelY=dashVy;
      player.dashActiveTimer=player.dashDuration;
      player.dashCooldownTimer=player.dashCooldown;
      player.isDashing=true;
    }

    function tryMeleeAttack(){
      if(!player||gameState!=="playing")return;
      if(player.meleeCooldownTimer>0)return;

      const dx=mousePos.x-player.x,dy=mousePos.y-player.y;
      const baseAngle=Math.atan2(dy,dx);
      player.meleeAngle=baseAngle;
      player.meleeSwingTimer=player.meleeSwingDuration;
      player.meleeCooldownTimer=player.meleeCooldown;

      const range=player.meleeRange*player.ultMeleeRangeMult;
      const dmgBase=player.meleeDamage*player.ultMeleeDamageMult;

      spawnParticles(
        player.x+Math.cos(baseAngle)*range*.7,
        player.y+Math.sin(baseAngle)*range*.7,
        {count:14,speedMin:120,speedMax:260,sizeMin:2,sizeMax:4,color:"rgba(255,200,160,1)"}
      );

      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        const ex=e.x-player.x,ey=e.y-player.y;
        const dist=Math.hypot(ex,ey);
        if(dist>range+e.radius)continue;
        const ang=Math.atan2(ey,ex);
        const diff=Math.abs(angleDiff(ang,baseAngle));
        if(diff<=player.meleeArc/2){
          e.hp-=dmgBase;
          gainStyle(4);
          const healBase=player.meleeOnHitHeal+player.ultMeleeHealBonus;
          if(healBase>0)
            player.hp=Math.min(player.maxHp,player.hp+healBase);
          if(e.hp<=0){
            gainStyle(6);
            triggerOnKillEffects(e.x,e.y);
            if(e.type==="bomber")triggerBomberExplosion(e);
            enemies.splice(i,1);
          }
        }
      }
    }

    function shoot(){
      const dx=mousePos.x-player.x,dy=mousePos.y-player.y;
      const baseAngle=Math.atan2(dy,dx);
      const count=player.bulletsPerShot;
      const totalSpread=player.spread*(count-1);
      const baseDmg=player.damage*player.ultDamageMult;
      const bulletSpeed=player.bulletSpeed*(player.ultBulletSpeedMult||1);
      for(let i=0;i<count;i++){
        const ang=baseAngle-totalSpread/2+player.spread*i;
        const vx=Math.cos(ang)*bulletSpeed;
        const vy=Math.sin(ang)*bulletSpeed;
        bullets.push({
          x:player.x,
          y:player.y,
          vx,vy,
          radius:5,
          damage:baseDmg,
          pierceLeft:player.pierce+(player.ultPierceBonus||0)
        });
      }
    }

    function updatePlayer(dt){
      if(player.dashCooldownTimer>0)player.dashCooldownTimer=Math.max(0,player.dashCooldownTimer-dt);
      if(player.dashActiveTimer>0){
        player.dashActiveTimer-=dt;
        if(player.dashActiveTimer<=0){player.dashActiveTimer=0;player.isDashing=false;}
      }
      if(player.meleeCooldownTimer>0)player.meleeCooldownTimer=Math.max(0,player.meleeCooldownTimer-dt);
      if(player.meleeSwingTimer>0)player.meleeSwingTimer=Math.max(0,player.meleeSwingTimer-dt);

      if(activeCurses.includes("last_stand_oath")){
        const threshold=0.3;
        const dmgMult=1.5;
        const fireMult=1.3;
        const isLow=player.hp>0?(player.hp/player.maxHp)<=threshold:false;
        if(isLow && !player.lastStandActive){
          player.damage*=dmgMult;
          player.fireRate*=fireMult;
          player.lastStandActive=true;
        }else if(!isLow && player.lastStandActive){
          player.damage/=dmgMult;
          player.fireRate/=fireMult;
          player.lastStandActive=false;
        }
      }

      if(player.isDashing){
        player.x+=player.dashVelX*dt;
        player.y+=player.dashVelY*dt;
      }else{
        let dx=0,dy=0;
        if(keys["w"]||keys["arrowup"])dy-=1;
        if(keys["s"]||keys["arrowdown"])dy+=1;
        if(keys["a"]||keys["arrowleft"])dx-=1;
        if(keys["d"]||keys["arrowright"])dx+=1;
        const len=Math.hypot(dx,dy);
        if(len>0){
          dx/=len;dy/=len;
          let effSpeed=player.speed*player.ultSpeedMult;
          if(bossGenjutsuTimer>0)effSpeed*=0.5;
          player.x+=dx*effSpeed*dt;
          player.y+=dy*effSpeed*dt;
        }
      }
      player.x=clamp(player.x,player.radius,canvas.width-player.radius);
      player.y=clamp(player.y,player.radius,canvas.height-player.radius);

      player.shootTimer+=dt;
      if(mouseDown){
        let effRate=player.fireRate*player.ultFireRateMult;
        if(bossGenjutsuTimer>0)effRate*=0.7;
        const needed=1/effRate;
        if(player.shootTimer>=needed){shoot();player.shootTimer=0;}
      }

      if(gameState==="playing" && mouseDown &&
         (player.normalAbilities.includes("kaioken_strain")||player.bossAbilities.includes("kaioken_strain"))){
        const drain=player.maxHp*0.015*dt;
        if(player.hp>1){
          player.hp=Math.max(1,player.hp-drain);
        }
      }

      if(player.hp<=0){player.hp=0;gameOver();}
    }

    function updateBullets(dt){
      let gojoBoss=null;
      for(const e of enemies){
        if(e.isBoss && e.bossId==="gojo"){gojoBoss=e;break;}
      }

      for(let i=bullets.length-1;i>=0;i--){
        const b=bullets[i];

        if(gojoBoss){
          const distToGojo=distance(b.x,b.y,gojoBoss.x,gojoBoss.y);
          const rad=(gojoBoss.barrierRadius||140)+10;
          if(distToGojo<rad){
            b.vx*=0.85;
            b.vy*=0.85;
            b.damage*=0.97;
          }
        }

        b.x+=b.vx*dt;
        b.y+=b.vy*dt;
        if(b.x<-50||b.x>canvas.width+50||b.y<-50||b.y>canvas.height+50){
          bullets.splice(i,1);continue;
        }
        for(let j=enemies.length-1;j>=0;j--){
          const e=enemies[j];
          if(distance(b.x,b.y,e.x,e.y)<b.radius+e.radius){
            e.hp-=b.damage;
            gainStyle(2);
            if(player.onHitHeal>0)
              player.hp=Math.min(player.maxHp,player.hp+player.onHitHeal);

            spawnParticles(e.x,e.y,{count:8,speedMin:80,speedMax:180,sizeMin:2,sizeMax:3,color:"rgba(255,200,150,1)"});
            if(e.hp<=0){
              gainStyle(6);
              triggerOnKillEffects(e.x,e.y);
              spawnParticles(e.x,e.y,{count:18,speedMin:120,speedMax:260,sizeMin:2,sizeMax:4,color:"rgba(255,140,140,1)"});
              if(e.isBoss)addScreenShake(11,.5);
              if(e.type==="bomber")triggerBomberExplosion(e);
              enemies.splice(j,1);
            }
            if(b.pierceLeft<=0){bullets.splice(i,1);}
            else b.pierceLeft--;
            break;
          }
        }
      }
    }

    function updateBombs(dt){
      for(let i=playerBombs.length-1;i>=0;i--){
        const bomb=playerBombs[i];
        bomb.fuse-=dt;
        if(bomb.fuse<=0){
          damageEnemiesInRadius(bomb.x,bomb.y,bomb.radius,bomb.damage);
          fireBursts.push({x:bomb.x,y:bomb.y,radius:bomb.radius,life:.25,maxLife:.25,color:"#ffd56b"});
          playerBombs.splice(i,1);
        }
      }
    }
    function updateFireBursts(dt){
      for(let i=fireBursts.length-1;i>=0;i--){
        const f=fireBursts[i];
        f.life-=dt;
        if(f.life<=0)fireBursts.splice(i,1);
      }
    }

    function updateDomains(dt){
      if(!domainField.active || !player)return;
      if(domainField.dpsMult<=0)return;
      const dps=player.damage*domainField.dpsMult;
      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        const distToCenter=distance(e.x,e.y,domainField.x,domainField.y);
        if(distToCenter<=domainField.radius+e.radius){
          e.hp-=dps*dt;
          if(e.hp<=0){
            gainStyle(6);
            triggerOnKillEffects(e.x,e.y);
            spawnParticles(e.x,e.y,{count:16,speedMin:120,speedMax:260,sizeMin:2,sizeMax:4,color:"rgba(210,180,255,1)"});
            if(e.isBoss)addScreenShake(11,.4);
            if(e.type==="bomber")triggerBomberExplosion(e);
            enemies.splice(i,1);
          }
        }
      }
    }

    /* ============== HUD & STATE ============== */
    function updateHUD(){
      hudWave.textContent=`Wave ${wave}`;
      hudHP.textContent=`HP: ${Math.round(player.hp)} / ${Math.round(player.maxHp)}`;
      if(player.hp/player.maxHp<=.3)hudHP.classList.add("low");
      else hudHP.classList.remove("low");

      const dashLabel=player.dashCooldownTimer<=0?"Dash: Ready":`Dash: ${player.dashCooldownTimer.toFixed(1)}s`;
      const meleeLabel=player.meleeCooldownTimer<=0?"Melee: Ready":`Melee: ${player.meleeCooldownTimer.toFixed(1)}s`;
      const noLimitText=noLimitMode?"Slots: ∞ (halved)":"Slots: 5 normal / 2 boss";

      hudStats.textContent=
        `DMG ${Math.round(player.damage)} | Fire ${(player.fireRate*player.ultFireRateMult).toFixed(1)}/s | Bullets ${player.bulletsPerShot} | `+
        `Pierce ${player.pierce+(player.ultPierceBonus||0)} | ${meleeLabel} | ${dashLabel} | ${noLimitText}`;

      let ultText="Ult: None";
      hudUlt.classList.remove("ult-ready");
      if(player.ultId){
        const def=ULT_DEFS[player.ultId];
        const name=def?def.name:"Ult";
        if(player.ultActiveTimer>0){
          ultText=`${name}: ACTIVE ${player.ultActiveTimer.toFixed(1)}s`;
        }else if(player.ultCooldownTimer<=0){
          ultText=`${name}: READY (Q)`;
          hudUlt.classList.add("ult-ready");
        }else{
          ultText=`${name}: ${player.ultCooldownTimer.toFixed(1)}s`;
        }
      }
      hudUlt.textContent=ultText;

      const sp=Math.round(player.styleMeter/player.styleMax*100);
      let rank="C";
      if(sp>=80)rank="S";
      else if(sp>=60)rank="A";
      else if(sp>=35)rank="B";
      let eventText="";
      if(currentWaveEvent==="curse_storm")eventText=" | Curse Storm";
      else if(currentWaveEvent==="blood_moon")eventText=" | Blood Moon";
      else if(currentWaveEvent==="hunt_night")eventText=" | Hunt Night";
      const styleText=`Style: ${sp}% [${rank}]${eventText}`;
      hudStyle.textContent=styleText;
      if(sp>=60)hudStyle.classList.add("style-high");
      else hudStyle.classList.remove("style-high");
    }

    function checkWaveCleared(){
      if(gameState!=="playing" && gameState!=="chooseReplace")return;
      if(enemies.length===0)onWaveCleared();
    }
    function onWaveCleared(){
      gameState="upgrade";
      player.hp=Math.min(player.maxHp,player.hp+player.healAfterWave);
      pendingAbility=null;pendingCategory=null;

      const isBossWave=wave%5===0;
      const abilityOptions=getAbilityOptions(isBossWave?2:3,isBossWave);
      let finalOptions=abilityOptions;
      if(isBossWave){
        const curseOptions=getCurseOptions(1);
        finalOptions=abilityOptions.concat(curseOptions);
      }

      if(finalOptions.length===0){
        gameState="playing";
        startNextWave();
        return;
      }
      showUpgradePanel(finalOptions);
    }

    function gameOver(){
      gameState="gameover";
      addScreenShake(12,.6);addWhiteFlash(.5);
      spawnParticles(player.x,player.y,{count:40,speedMin:150,speedMax:340,sizeMin:3,sizeMax:6,color:"rgba(255,120,120,1)"});
      showMessage("Game Over – press R to restart",999);
    }

    /* ============== MAIN UPDATE & DRAW ============== */
    function update(dt){
      if(gameState==="menu")return;
      if(messageTimer>0){
        messageTimer-=dt;
        if(messageTimer<=0)overlayMessageEl.textContent="";
      }
      if(screenShakeTimer>0){
        screenShakeTimer-=dt;
        if(screenShakeTimer<=0){
          screenShakeTimer=0;screenShakeIntensity=0;screenShakeDuration=0;
        }
      }
      if(whiteFlashAlpha>0){
        whiteFlashAlpha-=dt*1.5;
        if(whiteFlashAlpha<0)whiteFlashAlpha=0;
      }
      if(bossGenjutsuTimer>0){
        bossGenjutsuTimer=Math.max(0,bossGenjutsuTimer-dt);
      }

      updateBackground(dt);
      updateParticles(dt);
      updateSlowFields(dt);

      if(gameState==="upgrade"||gameState==="gameover"||gameState==="chooseReplace"){
        updateStyle(dt);
        updateUlt(dt);
        updateHUD();
        return;
      }

      updatePlayer(dt);
      updateBullets(dt);
      updateEnemies(dt);
      updateEnemyBullets(dt);
      updateBombs(dt);
      updateFireBursts(dt);
      updateDomains(dt);
      updateStyle(dt);
      updateUlt(dt);
      checkWaveCleared();
      updateHUD();
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawBackground();

      let shakeX=0,shakeY=0;
      if(screenShakeTimer>0&&screenShakeDuration>0&&screenShakeIntensity>0){
        const t=screenShakeTimer/screenShakeDuration;
        const power=t*t;
        const maxOffset=screenShakeIntensity*power;
        shakeX=(Math.random()*2-1)*maxOffset;
        shakeY=(Math.random()*2-1)*maxOffset;
      }
      ctx.save();
      ctx.translate(shakeX,shakeY);

      if(domainField.active){
        ctx.save();
        ctx.beginPath();
        ctx.arc(domainField.x,domainField.y,domainField.radius,0,Math.PI*2);
        ctx.fillStyle=domainField.color;
        ctx.fill();
        ctx.lineWidth=3;
        ctx.strokeStyle=domainField.edgeColor;
        ctx.stroke();
        ctx.restore();
      }

      for(const f of fireBursts){
        const t=f.life/f.maxLife;
        ctx.save();
        ctx.globalAlpha=.5*t;
        ctx.beginPath();
        ctx.arc(f.x,f.y,f.radius*(1+(1-t)*.3),0,Math.PI*2);
        ctx.fillStyle=f.color;
        ctx.fill();
        ctx.restore();
      }

      for(const s of slowFields){
        const t=s.life/s.maxLife;
        ctx.save();
        ctx.globalAlpha=0.2*t;
        ctx.beginPath();
        ctx.arc(s.x,s.y,s.radius,0,Math.PI*2);
        ctx.fillStyle="rgba(120,200,255,1)";
        ctx.fill();
        ctx.restore();
      }

      for(const b of playerBombs){
        const t=b.fuse/b.maxFuse;
        ctx.save();
        ctx.globalAlpha=.25+(1-t)*.3;
        ctx.beginPath();
        ctx.arc(b.x,b.y,b.radius*(0.4+0.2*(1-t)),0,Math.PI*2);
        ctx.fillStyle="#ffdd55";
        ctx.fill();
        ctx.restore();
      }

      drawParticles();

      for(const b of enemyBullets){
        ctx.beginPath();
        ctx.arc(b.x,b.y,b.radius,0,Math.PI*2);
        ctx.fillStyle="#ff5555";
        ctx.fill();
      }

      for(const e of enemies){
        if(e.isBoss){
          if(e.bossId==="mahito" && e.phase>=2){
            const domR=230;
            ctx.save();
            ctx.beginPath();
            ctx.arc(e.x,e.y,domR,0,Math.PI*2);
            ctx.globalAlpha=0.16;
            ctx.fillStyle="rgba(130,90,255,1)";
            ctx.fill();
            ctx.lineWidth=2.5;
            ctx.strokeStyle="rgba(220,200,255,0.9)";
            ctx.stroke();
            ctx.restore();
          }
          if(e.bossId==="gojo"){
            const r=e.barrierRadius||140;
            ctx.save();
            ctx.beginPath();
            ctx.arc(e.x,e.y,r,0,Math.PI*2);
            ctx.globalAlpha=0.22;
            ctx.strokeStyle="rgba(180,230,255,0.95)";
            ctx.lineWidth=3;
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(e.x,e.y,r*0.6,0,Math.PI*2);
            ctx.globalAlpha=0.08;
            ctx.fillStyle="rgba(120,180,255,1)";
            ctx.fill();
            ctx.restore();
          }
          if(e.bossId==="luffy" && e.slamWindup>0){
            const slamRadius=200;
            const t=e.slamWindup/e.slamWindupMax;
            ctx.save();
            ctx.beginPath();
            ctx.arc(e.x,e.y,slamRadius,0,Math.PI*2);
            ctx.globalAlpha=0.12+0.15*(1-t);
            ctx.strokeStyle="rgba(255,230,150,0.95)";
            ctx.lineWidth=3;
            ctx.stroke();
            ctx.restore();
          }
          const auraR=e.phase===1?130:e.phase===2?150:180;
          ctx.save();
          ctx.beginPath();
          ctx.arc(e.x,e.y,auraR,0,Math.PI*2);
          ctx.globalAlpha=.18;
          ctx.fillStyle=e.bossColor||"#9a6bff";
          ctx.fill();
          ctx.restore();
        }else if(e.isMiniBoss){
          const auraR=100;
          ctx.save();
          ctx.beginPath();
          ctx.arc(e.x,e.y,auraR,0,Math.PI*2);
          ctx.globalAlpha=.16;
          ctx.fillStyle=e.miniBossColor||"#ff9966";
          ctx.fill();
          ctx.restore();
        }else if(e.isElite){
          const auraR=e.radius+20;
          ctx.save();
          ctx.beginPath();
          ctx.arc(e.x,e.y,auraR,0,Math.PI*2);
          ctx.globalAlpha=.12;
          ctx.fillStyle="rgba(255,220,140,1)";
          ctx.fill();
          ctx.restore();
        }

        const hpRatio=e.hp/e.maxHp;
        ctx.beginPath();
        ctx.arc(e.x,e.y,e.radius,0,Math.PI*2);
        if(e.isBoss)ctx.fillStyle=e.bossColor||"#ff3b3b";
        else if(e.isMiniBoss)ctx.fillStyle=e.miniBossColor||"#ff9966";
        else ctx.fillStyle=e.type==="sniper"?"#87c7ff":e.type==="bomber"?"#ffb86c":"#ffae00";
        ctx.fill();
        const barW=e.radius*2,barH=4;
        ctx.fillStyle="#000";
        ctx.fillRect(e.x-e.radius,e.y-e.radius-8,barW,barH);
        ctx.fillStyle="#00ff4b";
        ctx.fillRect(e.x-e.radius,e.y-e.radius-8,barW*hpRatio,barH);

        ctx.save();
        ctx.font="12px system-ui, sans-serif";
        ctx.fillStyle="#f5f5f5";
        ctx.textAlign="center";
        ctx.textBaseline="top";
        if(e.isBoss)ctx.fillText(e.bossName||"Boss",e.x,e.y+e.radius+6);
        else if(e.isMiniBoss)ctx.fillText(e.miniBossName||"Mini-Boss",e.x,e.y+e.radius+6);
        ctx.restore();
      }

      for(const b of bullets){
        ctx.beginPath();
        ctx.arc(b.x,b.y,b.radius,0,Math.PI*2);
        ctx.fillStyle="#f5f5f5";
        ctx.fill();
      }

      if(player){
        if(player.meleeSwingTimer>0){
          const t=player.meleeSwingTimer/player.meleeSwingDuration;
          ctx.save();
          ctx.translate(player.x,player.y);
          ctx.rotate(player.meleeAngle);
          ctx.beginPath();
          ctx.moveTo(0,0);
          ctx.arc(0,0,player.meleeRange*player.ultMeleeRangeMult,-player.meleeArc/2,player.meleeArc/2);
          ctx.closePath();
          ctx.globalAlpha=.2+.2*t;
          ctx.fillStyle="#ffcc88";
          ctx.fill();
          ctx.restore();
        }

        ctx.beginPath();
        ctx.arc(player.x,player.y,player.radius,0,Math.PI*2);
        ctx.fillStyle=player.isDashing?"#9ff6ff":"#39c5ff";
        ctx.fill();

        const dx=mousePos.x-player.x,dy=mousePos.y-player.y;
        const ang=Math.atan2(dy,dx);
        const gunLen=player.radius+6;
        ctx.beginPath();
        ctx.moveTo(player.x,player.y);
        ctx.lineTo(player.x+Math.cos(ang)*gunLen,player.y+Math.sin(ang)*gunLen);
        ctx.strokeStyle="#ffffff";
        ctx.lineWidth=3;
        ctx.stroke();
      }

      ctx.restore();

      if(bossGenjutsuTimer>0){
        const t=bossGenjutsuTimer/GENJUTSU_DURATION;
        ctx.save();
        ctx.globalAlpha=0.18+0.22*t;
        ctx.fillStyle="#3b163b";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.restore();
      }

      if(whiteFlashAlpha>0){
        ctx.save();
        ctx.globalAlpha=whiteFlashAlpha;
        ctx.fillStyle="#ffffff";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.restore();
      }
    }

    function loop(ts){
      if(!lastTime)lastTime=ts;
      const dt=(ts-lastTime)/1000;
      lastTime=ts;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    /* ============== INIT & WAVES ============== */
    function startNextWave(){
      wave++;
      enemies=[];bullets=[];enemyBullets.length=0;playerBombs.length=0;fireBursts.length=0;slowFields.length=0;
      const isBossWave=wave%5===0;
      const isMiniBossWave=!isBossWave && wave>1 && wave%5===3;

      currentWaveEvent=null;
      let eventText="";
      if(!isBossWave){
        const roll=Math.random();
        if(roll<0.2){
          const evTypes=["curse_storm","blood_moon","hunt_night"];
          currentWaveEvent=evTypes[Math.floor(Math.random()*evTypes.length)];
          if(currentWaveEvent==="curse_storm")eventText="Curse Storm – more enemies, more style gain.";
          else if(currentWaveEvent==="blood_moon")eventText="Blood Moon – enemies hit harder, your style & ult charge faster.";
          else if(currentWaveEvent==="hunt_night")eventText="Hunt Night – fewer enemies, many elites.";
        }
      }

      let baseCount=4+wave*2;
      if(currentWaveEvent==="curse_storm")baseCount=Math.round(baseCount*1.4);
      if(currentWaveEvent==="hunt_night")baseCount=Math.round(baseCount*0.7);
      baseCount=Math.round(baseCount*enemyScale.countMult);
      baseCount=Math.max(1,baseCount);

      if(isBossWave){
        spawnEnemy(true);
        const extra=Math.max(2,Math.floor(baseCount/3));
        for(let i=0;i<extra;i++)spawnEnemy(false);
        if(player)player.mahitoTouchStacks=0;
        const boss=enemies.find(e=>e.isBoss);
        let msg=boss?`Boss: ${boss.bossName} (Wave ${wave})`:`Boss Wave ${wave}`;
        if(eventText)msg+=" | "+eventText;
        showMessage(msg,3);
        addScreenShake(8,.4);addWhiteFlash(.3);
      }else if(isMiniBossWave){
        spawnMiniBoss();
        const extraCount=Math.max(2,Math.floor(baseCount*0.6));
        for(let i=0;i<extraCount;i++)spawnEnemy(false);
        let msg=`Mini-Boss Wave ${wave}`;
        if(eventText)msg+=" | "+eventText;
        showMessage(msg,3);
        addScreenShake(6,.35);
      }else{
        for(let i=0;i<baseCount;i++)spawnEnemy(false);
        let msg=`Wave ${wave}`;
        if(eventText)msg+=" | "+eventText;
        showMessage(msg,2.5);
      }
    }

    function resetGame(){
      bullets=[];enemies=[];enemyBullets=[];playerBombs.length=0;fireBursts.length=0;particles.length=0;slowFields.length=0;
      activeCurses=[];recomputeEnemyScale();
      wave=0;pendingAbility=null;pendingCategory=null;
      gameState="playing";lastTime=0;
      hideUpgradePanel();
      player=createPlayer();
      player.normalAbilities=[];
      player.bossAbilities=[];
      const arch=ARCHETYPES[selectedArchetype]||ARCHETYPES.sorcerer;
      if(arch && arch.startAbilities){
        for(const id of arch.startAbilities){
          if(!player.normalAbilities.includes(id))player.normalAbilities.push(id);
        }
      }
      if(combatStyle==="melee" && !player.normalAbilities.includes("water_breathing")){
        player.normalAbilities.push("water_breathing");
      }
      if(combatStyle==="ranged" && !player.normalAbilities.includes("quirk_booster")){
        player.normalAbilities.push("quirk_booster");
      }
      player.ultId=selectedUltId;
      resetUltMultipliers();
      player.ultCooldownTimer=8;
      player.ultActiveTimer=0;
      player.ultReady=false;
      domainField.active=false;
      domainField.type=null;
      domainField.dpsMult=0;
      bossGenjutsuTimer=0;
      player.styleMeter=0;
      player.styleMax=100;
      player.styleDecayRate=6;
      player.styleGainMult=1;
      player.mahitoTouchStacks=0;
      recomputePlayerStats(false);
      renderAbilitiesBar();
      initBackground();
      startNextWave();
    }

    // Menu event listeners
    document.querySelectorAll(".menuButton[data-style]").forEach(btn=>{
      btn.addEventListener("click",()=>{
        const style=btn.getAttribute("data-style");
        combatStyle=style;
        document.querySelectorAll(".menuButton[data-style]").forEach(b=>b.classList.remove("styleActive"));
        btn.classList.add("styleActive");
        mainMenu.style.display="none";
        initAbilities();
        resetGame();
        requestAnimationFrame(loop);
      });
    });

    document.querySelectorAll(".ultButton").forEach(btn=>{
      btn.addEventListener("click",()=>{
        const id=btn.getAttribute("data-ult");
        selectedUltId=id;
        document.querySelectorAll(".ultButton").forEach(b=>b.classList.remove("styleActive"));
        btn.classList.add("styleActive");
      });
    });

    document.querySelectorAll(".archButton").forEach(btn=>{
      btn.addEventListener("click",()=>{
        const id=btn.getAttribute("data-arch");
        selectedArchetype=id;
        document.querySelectorAll(".archButton").forEach(b=>b.classList.remove("styleActive"));
        btn.classList.add("styleActive");
      });
    });

    skipButton.addEventListener("click",()=>{
      if(gameState!=="upgrade")return;
      pendingAbility=null;pendingCategory=null;
      hideUpgradePanel();
      gameState="playing";
      startNextWave();
    });
  </script>
</body>
</html>
