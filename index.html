<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Anime Roguelike Shooter</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    body{
      background:#050509;
      color:#f5f5f5;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      display:flex;
      flex-direction:column;
      align-items:center;
      padding:10px;
      user-select:none;
    }
    h1{font-size:22px;margin-bottom:4px}
    p{font-size:12px;margin-bottom:6px;opacity:.85}

    #container{position:relative;display:inline-block}
    #game{
      display:block;
      border-radius:8px;
      border:2px solid #333;
      background:#000;
      image-rendering:pixelated;
    }
    #overlayMessage{
      position:absolute;
      top:8px;
      left:50%;
      transform:translateX(-50%);
      padding:4px 10px;
      background:rgba(0,0,0,.6);
      border-radius:999px;
      font-size:12px;
      pointer-events:none;
    }

    #hud{
      margin-top:6px;
      font-size:13px;
      display:flex;
      gap:12px;
      justify-content:center;
      flex-wrap:wrap;
    }
    #hudHP.low{
      color:#ff7070;
      text-shadow:0 0 8px rgba(255,90,90,.9);
    }
    #hudUlt.ult-ready{
      color:#ffe08a;
      text-shadow:0 0 8px rgba(255,210,120,.9);
    }
    #hudStyle.style-high{
      color:#87c7ff;
      text-shadow:0 0 8px rgba(120,180,255,.9);
    }

    #upgradePanel{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.75);
      z-index:10;
    }
    #upgradePanelInner{
      background:#101010;
      border-radius:10px;
      padding:14px;
      max-width:620px;
      width:92%;
      box-shadow:0 0 24px rgba(0,0,0,.9);
      font-size:13px;
    }
    #upgradePanelInner h2{margin-bottom:6px;font-size:18px}
    #upgradePanelInner p{margin-bottom:8px;font-size:11px;opacity:.9}
    #upgrades{
      display:flex;
      flex-direction:column;
      gap:6px;
      margin-bottom:6px;
    }
    .upgradeButton{
      background:#181818;
      border-radius:6px;
      padding:7px;
      text-align:left;
      cursor:pointer;
      font-size:12px;
      border:1px solid #555;
      color:#f5f5f5;
      transition:background .1s,transform .05s,box-shadow .1s,border-color .1s;
    }
    .upgradeButton:hover{
      background:#252525;
      transform:translateY(-1px);
      box-shadow:0 0 16px rgba(255,255,255,.16);
    }
    .upgradeTopRow{
      display:flex;
      justify-content:space-between;
      margin-bottom:2px;
    }
    .upgradeName{font-weight:600}
    .upgradeDesc{font-size:11px;opacity:.92;color:#f0f0f0}

    .rarityBadge{
      font-size:9px;
      padding:2px 6px;
      border-radius:999px;
      text-transform:uppercase;
      letter-spacing:.05em;
      font-weight:600;
      border:1px solid transparent;
    }
    .rarity-common{
      color:#b8f7b8;
      background:rgba(80,160,80,.18);
      border-color:rgba(120,220,120,.7);
    }
    .rarity-rare{
      color:#87c7ff;
      background:rgba(80,120,200,.18);
      border-color:rgba(120,180,255,.7);
    }
    .rarity-epic{
      color:#e3b3ff;
      background:rgba(150,80,200,.2);
      border-color:rgba(210,150,255,.8);
    }
    .rarity-legendary{
      color:#ffe08a;
      background:rgba(200,140,40,.25);
      border-color:rgba(255,206,120,.9);
    }

    .card-rarity-common{
      box-shadow:0 0 6px rgba(130,220,130,.5);
      border-color:rgba(130,220,130,.7);
    }
    .card-rarity-rare{
      box-shadow:0 0 9px rgba(120,180,255,.7);
      border-color:rgba(120,180,255,.9);
    }
    .card-rarity-epic{
      box-shadow:0 0 11px rgba(210,140,255,.8);
      border-color:rgba(210,140,255,1);
    }
    .card-rarity-legendary{
      box-shadow:0 0 14px rgba(255,210,100,1);
      border-color:rgba(255,210,100,1);
    }

    #skipButton{
      margin-top:2px;
      padding:5px 10px;
      border-radius:999px;
      border:1px solid #777;
      background:#222;
      color:#f5f5f5;
      cursor:pointer;
      font-size:11px;
      float:right;
    }
    #skipButton:hover{background:#333}

    #abilitiesBar{
      margin-top:8px;
      display:flex;
      gap:20px;
      justify-content:center;
      flex-wrap:wrap;
      max-width:960px;
      font-size:11px;
    }
    .abilitiesGroup{
      display:flex;
      flex-direction:column;
      gap:4px;
      align-items:flex-start;
    }
    .abilitiesTitle{opacity:.75;font-size:11px}
    .abilitiesList{
      display:flex;
      gap:4px;
      flex-wrap:wrap;
      max-width:460px;
    }
    .abilitySlot{
      border-radius:999px;
      padding:3px 7px;
      border:1px solid #666;
      background:#151515;
      font-size:10px;
      cursor:pointer;
      white-space:nowrap;
      display:inline-flex;
      align-items:center;
      transition:background .1s,transform .05s,box-shadow .1s,border-color .1s;
    }
    .abilitySlot:hover{
      background:#232323;
      transform:translateY(-1px);
    }
    .abilitySlot.card-rarity-common{
      box-shadow:0 0 4px rgba(130,220,130,.5);
      border-color:rgba(130,220,130,.7);
    }
    .abilitySlot.card-rarity-rare{
      box-shadow:0 0 6px rgba(120,180,255,.7);
      border-color:rgba(120,180,255,.9);
    }
    .abilitySlot.card-rarity-epic{
      box-shadow:0 0 7px rgba(210,140,255,.8);
      border-color:rgba(210,140,255,1);
    }
    .abilitySlot.card-rarity-legendary{
      box-shadow:0 0 9px rgba(255,210,100,1);
      border-color:rgba(255,210,100,1);
    }

    /* MAIN MENU */

    #mainMenu{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.9);
      z-index:20;
    }
    #mainMenuInner{
      background:#111;
      padding:16px 20px;
      border-radius:10px;
      max-width:720px;
      width:92%;
      box-shadow:0 0 24px rgba(0,0,0,.9);
      text-align:left;
      font-size:13px;
    }
    #mainMenuInner h2{margin-bottom:4px;font-size:20px}
    #mainMenuInner p{opacity:.85;margin-bottom:6px;font-size:11px}

    .menuButtons{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin:6px 0;
    }
    .menuButton{
      padding:7px 12px;
      border-radius:999px;
      border:1px solid #666;
      background:#222;
      color:#f5f5f5;
      cursor:pointer;
      font-size:12px;
      transition:background .1s,transform .05s,box-shadow .1s;
    }
    .menuButton:hover{
      background:#333;
      transform:translateY(-1px);
      box-shadow:0 0 12px rgba(255,255,255,.15);
    }
    .menuButton.styleActive{
      background:#203040;
      border-color:#7bd0ff;
      box-shadow:0 0 12px rgba(123,208,255,.8);
    }
    .menuButton.cosmeticLocked{
      opacity:0.35;
      border-style:dashed;
      cursor:not-allowed;
      box-shadow:none;
    }
    .menuButton.cosmeticSelected{
      box-shadow:0 0 12px rgba(255,255,255,0.5);
    }

    .mainMenuTabsRow{
      display:flex;
      gap:8px;
      margin:8px 0 6px 0;
      flex-wrap:wrap;
    }
    .mainMenuSection{
      margin-top:6px;
      padding-top:4px;
      border-top:1px solid #222;
    }
    .menuSectionTitle{
      margin-top:4px;
      margin-bottom:2px;
      font-weight:600;
      font-size:11px;
      opacity:.9;
      text-transform:uppercase;
      letter-spacing:.05em;
    }
    .menuHint{
      margin-top:4px;
      font-size:10px;
      opacity:.7;
    }

    .settingsRow{
      display:flex;
      flex-direction:column;
      gap:2px;
      margin-bottom:6px;
      padding:5px 6px;
      border-radius:6px;
      background:#181818;
      border:1px solid #333;
    }
    .settingsRow label{
      font-size:12px;
      display:flex;
      align-items:center;
      gap:6px;
    }
    .settingsRow span{
      font-size:10px;
      opacity:.78;
      padding-left:18px;
    }
    .settingsRow input[type="checkbox"]{
      width:14px;
      height:14px;
      accent-color:#7bd0ff;
    }

    .achievementsList{
      display:flex;
      flex-direction:column;
      gap:6px;
      margin-top:4px;
      max-height:220px;
      overflow-y:auto;
      padding-right:4px;
    }
    .achievementItem{
      padding:6px 8px;
      border-radius:6px;
      background:#181818;
      border:1px solid #333;
      font-size:11px;
    }
    .achievementItem.achieved{
      border-color:#7bd0ff;
      box-shadow:0 0 10px rgba(123,208,255,0.35);
    }
    .achievementName{
      font-weight:600;
      margin-bottom:2px;
    }
    .achievementDesc{
      opacity:.8;
      margin-bottom:2px;
    }
    .achievementProgress{
      font-size:10px;
      opacity:.8;
    }

    /* Layout with right-hand stats panel */

    #pageRow{
      margin-top:6px;
      display:flex;
      align-items:flex-start;
      gap:16px;
      max-width:1220px;
    }
    #leftColumn{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
    }
    #statsPanel{
      min-width:210px;
      max-width:230px;
      padding:8px 10px;
      border-radius:8px;
      background:rgba(10,10,20,0.95);
      border:1px solid #333;
      box-shadow:0 0 18px rgba(0,0,0,0.8);
      font-size:11px;
    }
    #statsPanel h3{
      font-size:13px;
      margin-bottom:4px;
      text-align:left;
      letter-spacing:0.04em;
      text-transform:uppercase;
      opacity:0.85;
    }
    #statsContent{
      display:flex;
      flex-direction:column;
      gap:2px;
      max-height:480px;
      overflow-y:auto;
      padding-right:2px;
    }
    .statRow{
      display:flex;
      justify-content:space-between;
      gap:6px;
    }
    .statRow span:first-child{
      opacity:0.7;
    }
    .statRow span:last-child{
      font-weight:600;
    }
  </style>
</head>
<body>
  <h1>Anime Roguelike Shooter</h1>
  <p>WASD / Arrows move • Mouse aim • Left click shoot • Right click / E melee • Space dash • Q ultimate • R restart</p>

  <!-- MAIN MENU -->
  <div id="mainMenu">
    <div id="mainMenuInner">
      <h2>Anime Rogue Run</h2>
      <p>Build insane anime runs: Demon Slayer, One Piece, JJK, MHA, Cyberpunk, Solo Leveling and more.</p>

      <div class="mainMenuTabsRow">
        <button class="menuButton mainTabButton styleActive" data-tab="playTab">Play</button>
        <button class="menuButton mainTabButton" data-tab="settingsTab">Settings</button>
        <button class="menuButton mainTabButton" data-tab="achievementsTab">Achievements</button>
        <button class="menuButton mainTabButton" data-tab="cosmeticsTab">Cosmetics</button>
      </div>

      <!-- PLAY TAB -->
      <div id="playTab" class="mainMenuSection">
        <p class="menuHint">Choose difficulty, playstyle and ultimate – then dive into waves and bosses.</p>

        <p class="menuSectionTitle">Mode</p>
        <div class="menuButtons">
          <button class="menuButton modeButton" data-mode="chill">Chill</button>
          <button class="menuButton modeButton styleActive" data-mode="normal">Normal</button>
          <button class="menuButton modeButton" data-mode="cursed">Cursed</button>
        </div>

        <p class="menuSectionTitle">Combat Style</p>
        <div class="menuButtons">
          <button class="menuButton" data-style="melee">Melee Focus</button>
          <button class="menuButton" data-style="ranged">Ranged Focus</button>
        </div>

        <p class="menuSectionTitle">Archetype</p>
        <div class="menuButtons">
          <button class="menuButton archButton" data-arch="swordsman">Sharp Swordsman</button>
          <button class="menuButton archButton styleActive" data-arch="sorcerer">Cursed Sorcerer</button>
          <button class="menuButton archButton" data-arch="titan">Titan Slayer</button>
          <button class="menuButton archButton" data-arch="hero">Quirked Hero</button>
        </div>

        <p class="menuSectionTitle">Ultimate (Q to cast)</p>
        <div class="menuButtons" id="ultMenu">
          <button class="menuButton ultButton styleActive" data-ult="jjk_domain">JJK Domain</button>
          <button class="menuButton ultButton" data-ult="ofa_100">OFA 100%</button>
          <button class="menuButton ultButton" data-ult="demon_mark">Demon Mark</button>
          <button class="menuButton ultButton" data-ult="gear_fifth">Gear Fifth</button>
          <button class="menuButton ultButton" data-ult="susanoo_guardian">Susanoo Guardian</button>
          <button class="menuButton ultButton" data-ult="cyber_sandevistan">Cyber Sandevistan</button>
          <button class="menuButton ultButton" data-ult="ghoul_rampage">Ghoul Rampage</button>
          <button class="menuButton ultButton" data-ult="flame_domain">Flame Ring</button>
          <button class="menuButton ultButton" data-ult="bankai_field">Bankai Field</button>
          <button class="menuButton ultButton" data-ult="haki_burst">Haki Burst</button>
          <button class="menuButton ultButton" data-ult="chimera_shadow_garden">Chimera Shadow Garden</button>
          <button class="menuButton ultButton" data-ult="thunder_god_avatar">Thunder God Avatar</button>
          <button class="menuButton ultButton" data-ult="orbital_strike">Orbital Strike</button>
        </div>

        <p class="menuSectionTitle">Power Info</p>
        <p class="menuHint">
          Normal powers: up to 5 active at once, each giving buffs with drawbacks.<br>
          Boss powers: up to 2 at once, very strong but risky.<br>
          Curses: <b>Legendary</b> – huge bonuses but make enemies much stronger.<br>
          On <b>Boss waves</b> you always see at least one Legendary and one Curse. Hover cards during runs to see exact stat changes.
        </p>

        <div class="menuButtons" style="margin-top:10px;justify-content:flex-start;">
          <button id="startRunButton" class="menuButton" style="padding:8px 20px;font-weight:600;">Start Run</button>
        </div>

        <p class="menuHint">
          Powers every wave with drawbacks. Boss &amp; curse options every 5 waves. Summons, dashes, domains and broken builds.
        </p>
      </div>
      <!-- SETTINGS TAB -->
      <div id="settingsTab" class="mainMenuSection" style="display:none;">
        <p class="menuHint">Tweaks that affect feel and comfort.</p>

        <div class="settingsRow">
          <label><input type="checkbox" id="settingScreenShake" checked> Screen shake</label>
          <span>Impact shake on hits, dashes and explosions.</span>
        </div>

        <div class="settingsRow">
          <label><input type="checkbox" id="settingLowFlash"> Reduce flashes</label>
          <span>Dim white flashes on ults and big hits.</span>
        </div>

        <div class="settingsRow">
          <label><input type="checkbox" id="settingShowHints" checked> Show hint popups</label>
          <span>Small text at the top for events, bosses and tips.</span>
        </div>

        <p class="menuHint">
          Settings are saved locally on this device.
        </p>
      </div>

      <!-- ACHIEVEMENTS TAB -->
      <div id="achievementsTab" class="mainMenuSection" style="display:none;">
        <p class="menuHint">Milestones from your previous runs. Some unlock cosmetics.</p>
        <div id="achievementsList" class="achievementsList"></div>
      </div>

      <!-- COSMETICS TAB -->
      <div id="cosmeticsTab" class="mainMenuSection" style="display:none;">
        <p class="menuSectionTitle">Cosmetics – Player Skin</p>
        <div class="menuButtons" id="skinMenu">
          <button class="menuButton skinButton" data-skin="skin_default" title="Always unlocked.">Default Hunter</button>
          <button class="menuButton skinButton" data-skin="skin_hashira" title="Reach Wave 10 to unlock.">Hashira Cloak</button>
          <button class="menuButton skinButton" data-skin="skin_domain_freak" title="Use a Domain-style ult 3 times total to unlock.">Domain Freak</button>
          <button class="menuButton skinButton" data-skin="skin_shadow_monarch" title="Defeat a boss while using Shadow Army Commander to unlock.">Shadow Monarch</button>
        </div>

        <p class="menuSectionTitle">Cosmetics – Bullet Trail</p>
        <div class="menuButtons" id="trailMenu">
          <button class="menuButton trailButton" data-trail="trail_default" title="Always unlocked.">Default Trail</button>
          <button class="menuButton trailButton" data-trail="trail_flame" title="Beat any boss to unlock.">Flame Rounds</button>
          <button class="menuButton trailButton" data-trail="trail_cursed" title="Take any Curse to unlock.">Cursed Sparks</button>
          <button class="menuButton trailButton" data-trail="trail_lightning" title="Reach Style rank S to unlock.">Lightning Shots</button>
        </div>

        <p class="menuSectionTitle">Cosmetics – Dash Trail</p>
        <div class="menuButtons" id="dashMenu">
          <button class="menuButton dashButton" data-dash="dash_default" title="Always unlocked.">Default Dash</button>
          <button class="menuButton dashButton" data-dash="dash_afterimage" title="Dash 50 times total to unlock.">Afterimage Step</button>
          <button class="menuButton dashButton" data-dash="dash_void" title="Reach Wave 15 to unlock.">Void Step</button>
        </div>

        <p class="menuHint">
          Locked cosmetics are greyed out – unlock them by hitting milestones in your runs.
        </p>
      </div>
    </div>
  </div>

  <div id="pageRow">
    <div id="leftColumn">
      <div id="container">
        <canvas id="game" width="960" height="540"></canvas>
        <div id="overlayMessage"></div>

        <div id="upgradePanel">
          <div id="upgradePanelInner">
            <h2>Choose a Power-Up</h2>
            <p>
              Every wave you get a power with a drawback. Max <b>5 normal</b> powers and <b>2 boss</b> powers – once you’re capped you’ll replace old ones.
              Boss waves offer <b>Legendary</b> options and <b>Curses</b> with extreme tradeoffs.
              Hover cards to see the exact stat changes.
            </p>
            <div id="upgrades"></div>
            <button id="skipButton">Skip – no power this wave</button>
          </div>
        </div>
      </div>

      <div id="hud">
        <div id="hudWave"></div>
        <div id="hudHP"></div>
        <div id="hudStats"></div>
        <div id="hudUlt"></div>
        <div id="hudStyle"></div>
        <div id="hudKills"></div>
      </div>

      <div id="abilitiesBar">
        <div class="abilitiesGroup">
          <span class="abilitiesTitle">Normal Powers (cap 5):</span>
          <div id="normalAbilitiesList" class="abilitiesList"></div>
        </div>
        <div class="abilitiesGroup">
          <span class="abilitiesTitle">Boss Powers (cap 2):</span>
          <div id="bossAbilitiesList" class="abilitiesList"></div>
        </div>
      </div>
    </div>

    <div id="statsPanel">
      <h3>Build Stats</h3>
      <div id="statsContent"></div>
    </div>
  </div>

  <script>
    const canvas=document.getElementById("game");
    const ctx=canvas.getContext("2d");
    const overlayMessageEl=document.getElementById("overlayMessage");
    const upgradePanel=document.getElementById("upgradePanel");
    const upgradesContainer=document.getElementById("upgrades");
    const skipButton=document.getElementById("skipButton");
    const hudWave=document.getElementById("hudWave");
    const hudHP=document.getElementById("hudHP");
    const hudStats=document.getElementById("hudStats");
    const hudUlt=document.getElementById("hudUlt");
    const hudStyle=document.getElementById("hudStyle");
    const hudKills=document.getElementById("hudKills");
    const mainMenu=document.getElementById("mainMenu");
    const normalAbilitiesListEl=document.getElementById("normalAbilitiesList");
    const bossAbilitiesListEl=document.getElementById("bossAbilitiesList");
    const statsContentEl=document.getElementById("statsContent");

    const keys={};
    let mousePos={x:canvas.width/2,y:canvas.height/2};
    let mouseDown=false;
    let combatStyle=null;
    let selectedUltId="jjk_domain";
    let selectedArchetype="sorcerer";
    let difficulty="normal";
    let gameState="menu";
    let lastTime=0;
    let messageTimer=0;

    let bgTime=0;
    const particles=[];
    const fireBursts=[];
    const playerBombs=[];
    const slowFields=[];
    let summons=[];
    let titanSummon=null;

    let screenShakeTimer=0;
    let screenShakeDuration=0;
    let screenShakeIntensity=0;
    let whiteFlashAlpha=0;

    let domainField={
      active:false,
      x:0,y:0,
      radius:220,
      type:null,
      color:"rgba(90,60,200,0.18)",
      edgeColor:"rgba(210,180,255,0.9)",
      dpsMult:0
    };

    const GENJUTSU_DURATION=3.2;
    let bossGenjutsuTimer=0;

    let player=null;
    let bullets=[];
    let enemies=[];
    let enemyBullets=[];
    let enemyIdCounter=1;

    let wave=0;
    let normalAbilities=[];
    let bossAbilities=[];
    let curses=[];
    let activeCurses=[];
    let noLimitMode=false;
    let replaceTarget=null;

    let enemyScale={
      hpMult:1,
      speedMult:1,
      damageMult:1,
      countMult:1,
      bulletSpeedMult:1,
      bulletDamageMult:1
    };

    let currentWaveEvent=null;
    let runKills=0;

    const DIFFICULTY_SETTINGS={
      chill:{enemyHpMult:0.85,enemyDamageMult:0.8,enemyCountMult:0.9},
      normal:{enemyHpMult:1,enemyDamageMult:1,enemyCountMult:1},
      cursed:{enemyHpMult:1.2,enemyDamageMult:1.25,enemyCountMult:1.15}
    };

    const BOSS_TEMPLATES=[
      {id:"mahito",name:"Mahito",color:"#b88cff"},
      {id:"itachi",name:"Itachi",color:"#ff6666"},
      {id:"gojo",name:"Gojo",color:"#7bd0ff"},
      {id:"luffy",name:"Gear Fifth Luffy",color:"#ffd480"}
    ];

    const MINI_BOSS_TEMPLATES=[
      {id:"upper_moon_demon",name:"Upper Moon Demon",color:"#ff9966",pattern:"cone"},
      {id:"high_end_nomu",name:"High-End Nomu",color:"#c84cff",pattern:"rush"},
      {id:"armored_titan",name:"Armored Titan",color:"#d8aa6a",pattern:"spin"}
    ];

    const ARCHETYPES={
      swordsman:{id:"swordsman",name:"Sharp Swordsman",startAbilities:["water_breathing","blood_edge"]},
      sorcerer:{id:"sorcerer",name:"Cursed Sorcerer",startAbilities:["shadow_garden","black_flash_rhythm"]},
      titan:{id:"titan",name:"Titan Slayer",startAbilities:["survey_maneuvers","shadow_army_commander"]},
      hero:{id:"hero",name:"Quirked Hero",startAbilities:["fire_force_spark"]}
    };

    const COSMETICS={
      skins:[
        {id:"skin_default",name:"Default Hunter",unlockCheck:(s)=>true},
        {id:"skin_hashira",name:"Hashira Cloak",unlockCheck:(s)=>s.maxWaveEver>=10},
        {id:"skin_domain_freak",name:"Domain Freak",unlockCheck:(s)=>s.totalDomainsCast>=3},
        {id:"skin_shadow_monarch",name:"Shadow Monarch",unlockCheck:(s)=>s.defeatedBossWithShadowCommanderOnce}
      ],
      bulletTrails:[
        {id:"trail_default",name:"Default Trail",unlockCheck:(s)=>true},
        {id:"trail_flame",name:"Flame Rounds",unlockCheck:(s)=>s.bossesKilled>=1},
        {id:"trail_cursed",name:"Cursed Sparks",unlockCheck:(s)=>s.cursesTaken>=1},
        {id:"trail_lightning",name:"Lightning Shots",unlockCheck:(s)=>s.reachedStyleSOnce}
      ],
      dashTrails:[
        {id:"dash_default",name:"Default Dash",unlockCheck:(s)=>true},
        {id:"dash_afterimage",name:"Afterimage Step",unlockCheck:(s)=>s.totalDashes>=50},
        {id:"dash_void",name:"Void Step",unlockCheck:(s)=>s.maxWaveEver>=15}
      ]
    };

    const ACHIEVEMENTS=[
      {
        id:"wave5",
        name:"First Trial",
        desc:"Reach Wave 5 in any mode.",
        check:(s)=>s.maxWaveEver>=5,
        progress:(s)=>`${Math.min(s.maxWaveEver,5)}/5 waves`
      },
      {
        id:"wave10",
        name:"Hashira Prospects",
        desc:"Reach Wave 10 (unlocks Hashira Clook).",
        check:(s)=>s.maxWaveEver>=10,
        progress:(s)=>`${Math.min(s.maxWaveEver,10)}/10 waves`
      },
      {
        id:"domain_addict",
        name:"Domain Addict",
        desc:"Cast a domain-style ultimate 3 times.",
        check:(s)=>s.totalDomainsCast>=3,
        progress:(s)=>`${Math.min(s.totalDomainsCast,3)}/3 casts`
      },
      {
        id:"boss_slayer",
        name:"Boss Slayer",
        desc:"Defeat 3 bosses total.",
        check:(s)=>s.bossesKilled>=3,
        progress:(s)=>`${Math.min(s.bossesKilled,3)}/3 bosses`
      },
      {
        id:"cursed_runner",
        name:"Cursed Runner",
        desc:"Take at least 1 Curse in a run.",
        check:(s)=>s.cursesTaken>=1,
        progress:(s)=>`${Math.min(s.cursesTaken,1)}/1 curse`
      },
      {
        id:"style_god",
        name:"Style God",
        desc:"Reach Style rank S at least once.",
        check:(s)=>s.reachedStyleSOnce,
        progress:(s)=>s.reachedStyleSOnce?"Done":"Not yet"
      }
    ];

    let cosmeticUnlocks={};
    let cosmeticSelection={
      skin:"skin_default",
      bulletTrail:"trail_default",
      dashTrail:"dash_default"
    };
    let cosmeticStats={
      maxWaveEver:0,
      totalDashes:0,
      totalDomainsCast:0,
      bossesKilled:0,
      cursesTaken:0,
      reachedStyleSOnce:false,
      defeatedBossWithShadowCommanderOnce:false
    };

    let gameSettings={
      screenShake:true,
      lowFlash:false,
      showHints:true
    };
    /* INPUT */
    window.addEventListener("keydown",e=>{
      const k=e.key.toLowerCase();
      keys[k]=true;
      if(e.code==="Space"&&gameState==="playing")startDash();
      if(e.code==="KeyE"&&gameState==="playing")tryMeleeAttack();
      if(k==="q"&&gameState==="playing")tryUseUlt();
      if(k==="r"&&gameState==="gameover")resetGame();
    });
    window.addEventListener("keyup",e=>{keys[e.key.toLowerCase()]=false;});
    canvas.addEventListener("mousemove",e=>{
      const r=canvas.getBoundingClientRect();
      mousePos.x=e.clientX-r.left;
      mousePos.y=e.clientY-r.top;
    });
    canvas.addEventListener("mousedown",e=>{
      if(e.button===0)mouseDown=true;
      if(e.button===2&&gameState==="playing")tryMeleeAttack();
    });
    canvas.addEventListener("mouseup",e=>{if(e.button===0)mouseDown=false;});
    canvas.addEventListener("contextmenu",e=>e.preventDefault());

    /* UTILS */
    const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
    const distance=(x1,y1,x2,y2)=>Math.hypot(x2-x1,y2-y1);
    function shuffled(a){a=a.slice();for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}
    function shuffledInPlace(arr){for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[arr[i],arr[j]]=[arr[j],arr[i]];}}
    function angleDiff(a,b){let d=a-b;while(d>Math.PI)d-=Math.PI*2;while(d<-Math.PI)d+=Math.PI*2;return d;}

    function showMessage(msg,t=2){
      if(!gameSettings.showHints)return;
      overlayMessageEl.textContent=msg;
      messageTimer=t;
    }
    function addScreenShake(intensity,duration){
      if(!gameSettings.screenShake)return;
      screenShakeIntensity=Math.max(screenShakeIntensity,intensity);
      screenShakeDuration=Math.max(screenShakeDuration,duration);
      screenShakeTimer=Math.max(screenShakeTimer,duration);
    }
    function addWhiteFlash(strength){
      const limit=gameSettings.lowFlash?0.35:1;
      const scale=gameSettings.lowFlash?0.6:1;
      whiteFlashAlpha=Math.min(limit,whiteFlashAlpha+strength*scale);
    }

    /* SETTINGS PERSIST */

    function loadSettings(){
      try{
        const raw=localStorage.getItem("animeRogue_settings");
        if(raw){
          const s=JSON.parse(raw);
          gameSettings={...gameSettings,...s};
        }
      }catch(e){}
    }
    function saveSettings(){
      try{
        localStorage.setItem("animeRogue_settings",JSON.stringify(gameSettings));
      }catch(e){}
    }

    /* COSMETICS */

    function ensureBaseCosmeticsUnlocked(){
      ["skin_default","trail_default","dash_default"].forEach(id=>{cosmeticUnlocks[id]=true;});
    }
    function loadCosmeticsFromStorage(){
      try{
        const u=localStorage.getItem("animeRogue_cosmeticUnlocks");
        if(u)cosmeticUnlocks=JSON.parse(u)||{};
        const s=localStorage.getItem("animeRogue_cosmeticStats");
        if(s)cosmeticStats={...cosmeticStats,...JSON.parse(s)};
        const sel=localStorage.getItem("animeRogue_cosmeticSelection");
        if(sel)cosmeticSelection={...cosmeticSelection,...JSON.parse(sel)};
      }catch(e){cosmeticUnlocks={};}
      ensureBaseCosmeticsUnlocked();
    }
    function saveCosmeticUnlocks(){try{localStorage.setItem("animeRogue_cosmeticUnlocks",JSON.stringify(cosmeticUnlocks));}catch(e){}}
    function saveCosmeticStats(){try{localStorage.setItem("animeRogue_cosmeticStats",JSON.stringify(cosmeticStats));}catch(e){}}
    function saveCosmeticSelection(){try{localStorage.setItem("animeRogue_cosmeticSelection",JSON.stringify(cosmeticSelection));}catch(e){}}

    function refreshAchievementsUI(){
      const container=document.getElementById("achievementsList");
      if(!container)return;
      const s=cosmeticStats;
      let html="";
      ACHIEVEMENTS.forEach(a=>{
        const unlocked=a.check(s);
        const prog=a.progress?a.progress(s):(unlocked?"Done":"");
        html+=`
          <div class="achievementItem ${unlocked?"achieved":""}">
            <div class="achievementName">${a.name}</div>
            <div class="achievementDesc">${a.desc}</div>
            <div class="achievementProgress">${prog}</div>
          </div>
        `;
      });
      container.innerHTML=html;
    }

    function checkCosmeticUnlocks(){
      ensureBaseCosmeticsUnlocked();
      const s=cosmeticStats;
      const checkGroup=(list)=>{
        for(const c of list){
          if(cosmeticUnlocks[c.id])continue;
          let unlocked=false;
          if(!c.unlockCheck)unlocked=true;
          else unlocked=!!c.unlockCheck(s);
          if(unlocked)cosmeticUnlocks[c.id]=true;
        }
      };
      checkGroup(COSMETICS.skins);
      checkGroup(COSMETICS.bulletTrails);
      checkGroup(COSMETICS.dashTrails);
      saveCosmeticUnlocks();
      refreshCosmeticButtons();
      refreshAchievementsUI();
    }

    function refreshCosmeticButtons(){
      const skinButtons=document.querySelectorAll(".skinButton");
      skinButtons.forEach(btn=>{
        const id=btn.getAttribute("data-skin");
        const unlocked=!!cosmeticUnlocks[id];
        btn.classList.remove("cosmeticLocked","styleActive","cosmeticSelected");
        if(!unlocked && id!=="skin_default")btn.classList.add("cosmeticLocked");
        if(cosmeticSelection.skin===id && unlocked)btn.classList.add("styleActive","cosmeticSelected");
      });
      const trailButtons=document.querySelectorAll(".trailButton");
      trailButtons.forEach(btn=>{
        const id=btn.getAttribute("data-trail");
        const unlocked=!!cosmeticUnlocks[id];
        btn.classList.remove("cosmeticLocked","styleActive","cosmeticSelected");
        if(!unlocked && id!=="trail_default")btn.classList.add("cosmeticLocked");
        if(cosmeticSelection.bulletTrail===id && unlocked)btn.classList.add("styleActive","cosmeticSelected");
      });
      const dashButtons=document.querySelectorAll(".dashButton");
      dashButtons.forEach(btn=>{
        const id=btn.getAttribute("data-dash");
        const unlocked=!!cosmeticUnlocks[id];
        btn.classList.remove("cosmeticLocked","styleActive","cosmeticSelected");
        if(!unlocked && id!=="dash_default")btn.classList.add("cosmeticLocked");
        if(cosmeticSelection.dashTrail===id && unlocked)btn.classList.add("styleActive","cosmeticSelected");
      });
    }

    function initCosmeticsSystem(){
      loadCosmeticsFromStorage();
      checkCosmeticUnlocks();
      document.querySelectorAll(".skinButton").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const id=btn.getAttribute("data-skin");
          const unlocked=!!cosmeticUnlocks[id];
          if(!unlocked){showMessage("Skin locked – keep playing to unlock it!",2.2);return;}
          cosmeticSelection.skin=id;
          saveCosmeticSelection();
          refreshCosmeticButtons();
        });
      });
      document.querySelectorAll(".trailButton").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const id=btn.getAttribute("data-trail");
          const unlocked=!!cosmeticUnlocks[id];
          if(!unlocked){showMessage("Bullet trail locked – keep playing to unlock it!",2.2);return;}
          cosmeticSelection.bulletTrail=id;
          saveCosmeticSelection();
          refreshCosmeticButtons();
        });
      });
      document.querySelectorAll(".dashButton").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const id=btn.getAttribute("data-dash");
          const unlocked=!!cosmeticUnlocks[id];
          if(!unlocked){showMessage("Dash trail locked – keep playing to unlock it!",2.2);return;}
          cosmeticSelection.dashTrail=id;
          saveCosmeticSelection();
          refreshCosmeticButtons();
        });
      });
    }

    function setupSettingsUI(){
      const cbShake=document.getElementById("settingScreenShake");
      const cbLowFlash=document.getElementById("settingLowFlash");
      const cbHints=document.getElementById("settingShowHints");
      if(cbShake)cbShake.checked=!!gameSettings.screenShake;
      if(cbLowFlash)cbLowFlash.checked=!!gameSettings.lowFlash;
      if(cbHints)cbHints.checked=!!gameSettings.showHints;

      if(cbShake){
        cbShake.addEventListener("change",()=>{
          gameSettings.screenShake=cbShake.checked;
          saveSettings();
        });
      }
      if(cbLowFlash){
        cbLowFlash.addEventListener("change",()=>{
          gameSettings.lowFlash=cbLowFlash.checked;
          saveSettings();
        });
      }
      if(cbHints){
        cbHints.addEventListener("change",()=>{
          gameSettings.showHints=cbHints.checked;
          if(!gameSettings.showHints){
            overlayMessageEl.textContent="";
            messageTimer=0;
          }
          saveSettings();
        });
      }
    }

    function getPlayerSkinTheme(){
      switch(cosmeticSelection.skin){
        case "skin_hashira":
          return {
            bodyColor:"#1c2733",
            outlineColor:"#7cf0c1",
            auraColor:"rgba(124,240,193,0.45)",
            dashGlowColor:"#7cf0c1",
            weaponColor:"#c8fff3"
          };
        case "skin_domain_freak":
          return {
            bodyColor:"#33204f",
            outlineColor:"#d2b3ff",
            auraColor:"rgba(164,118,255,0.5)",
            dashGlowColor:"#e6d2ff",
            weaponColor:"#f5e6ff"
          };
        case "skin_shadow_monarch":
          return {
            bodyColor:"#101018",
            outlineColor:"#b68bff",
            auraColor:"rgba(94,70,140,0.65)",
            dashGlowColor:"#b68bff",
            weaponColor:"#f0e6ff"
          };
        default:
          return {
            bodyColor:"#39c5ff",
            outlineColor:"#9ff6ff",
            auraColor:"rgba(120,200,255,0.55)",
            dashGlowColor:"#9ff6ff",
            weaponColor:"#ffffff"
          };
      }
    }
    function getBulletColor(){
      switch(cosmeticSelection.bulletTrail){
        case "trail_flame":return "#ffb35c";
        case "trail_cursed":return "#c68cff";
        case "trail_lightning":return "#e7f6ff";
        default:return "#f5f5f5";
      }
    }
    function getBulletTrailParticleColor(){
      switch(cosmeticSelection.bulletTrail){
        case "trail_flame":return "rgba(255,180,120,1)";
        case "trail_cursed":return "rgba(200,140,255,1)";
        case "trail_lightning":return "rgba(230,250,255,1)";
        default:return null;
      }
    }
    function getDashParticleColor(){
      switch(cosmeticSelection.dashTrail){
        case "dash_afterimage":return "rgba(255,255,255,0.9)";
        case "dash_void":return "rgba(110,90,180,1)";
        default:return "rgba(160,220,255,1)";
      }
    }
    function addBulletTrailFX(b){
      const color=getBulletTrailParticleColor();
      if(!color)return;
      if(Math.random()>0.5)return;
      spawnParticles(b.x,b.y,{
        count:1,speedMin:10,speedMax:40,lifeMin:0.2,lifeMax:0.5,sizeMin:1.2,sizeMax:2.4,color
      });
    }

    /* BACKGROUND – Neon cursed grid */
    function updateBackground(dt){bgTime+=dt;}

    function drawBackground(){
      const cx=canvas.width/2;
      const cy=canvas.height/2;

      const g=ctx.createRadialGradient(
        cx,cy,0,
        cx,cy,canvas.width*0.9
      );
      g.addColorStop(0,"#14172a");
      g.addColorStop(0.4,"#090918");
      g.addColorStop(1,"#020208");
      ctx.fillStyle=g;
      ctx.fillRect(0,0,canvas.width,canvas.height);

      const gridSize=32;
      const scroll=(bgTime*25)%gridSize;

      ctx.save();
      ctx.translate(0,canvas.height*0.15);
      ctx.globalAlpha=0.3;
      ctx.strokeStyle="#283757";
      ctx.lineWidth=1;

      for(let x=-gridSize;x<canvas.width+gridSize;x+=gridSize){
        ctx.beginPath();
        ctx.moveTo(Math.floor(x+scroll)+0.5,0);
        ctx.lineTo(Math.floor(x+scroll)+0.5,canvas.height);
        ctx.stroke();
      }
      for(let y=0;y<canvas.height;y+=gridSize){
        const yy=Math.floor(y+scroll)+0.5;
        ctx.beginPath();
        ctx.moveTo(0,yy);
        ctx.lineTo(canvas.width,yy);
        ctx.stroke();
      }
      ctx.restore();

      ctx.save();
      ctx.globalAlpha=0.12;
      ctx.strokeStyle="#7e5bff";
      ctx.lineWidth=2;
      const t=bgTime*40;
      for(let i=0;i<4;i++){
        const offset=(t+i*120)%(canvas.width+200)-100;
        ctx.beginPath();
        ctx.moveTo(offset,-20);
        ctx.lineTo(offset+160,canvas.height+40);
        ctx.stroke();
      }
      ctx.restore();

      const cell=8;
      ctx.save();
      ctx.globalAlpha=0.04;
      for(let y=0;y<canvas.height;y+=cell){
        for(let x=0;x<canvas.width;x+=cell){
          if(((x+y)>>3)&1){
            ctx.fillStyle="#000000";
            ctx.fillRect(x,y,cell,cell);
          }
        }
      }
      ctx.restore();

      const vg=ctx.createRadialGradient(
        cx,cy,canvas.width*0.35,
        cx,cy,canvas.width*0.95
      );
      vg.addColorStop(0,"rgba(0,0,0,0)");
      vg.addColorStop(1,"rgba(0,0,0,0.8)");
      ctx.fillStyle=vg;
      ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    /* PARTICLES & FIELDS */
    function spawnParticles(x,y,opt={}){
      const {
        count=12,spread=Math.PI*2,
        speedMin:spMin=80,speedMax:spMax=260,
        lifeMin=0.25,lifeMax=0.6,
        sizeMin=2,sizeMax=4,
        color="rgba(255,255,255,1)"
      }=opt;
      for(let i=0;i<count;i++){
        const ang=Math.random()*spread;
        const s=spMin+Math.random()*(spMax-spMin);
        const vx=Math.cos(ang)*s;
        const vy=Math.sin(ang)*s;
        const life=lifeMin+Math.random()*(lifeMax-lifeMin);
        const size=sizeMin+Math.random()*(sizeMax-sizeMin);
        particles.push({x,y,vx,vy,life,maxLife:life,size,color,renderColor:color});
      }
    }
    function updateParticles(dt){
      for(let i=particles.length-1;i>=0;i--){
        const p=particles[i];
        p.life-=dt;
        if(p.life<=0){particles.splice(i,1);continue;}
        const t=p.life/p.maxLife;
        p.x+=p.vx*dt;
        p.y+=p.vy*dt;
        p.vx*=0.97;
        p.vy+=20*dt;
        const m=p.color.match(/rgba\((\d+),(\d+),(\d+),([\d.]+)\)/);
        if(m){
          const[r,g,b]=[m[1],m[2],m[3]];
          p.renderColor=`rgba(${r},${g},${b},${t})`;
        }else p.renderColor=p.color;
      }
    }
    function drawParticles(){
      for(const p of particles){
        ctx.beginPath();
        ctx.arc(p.x,p.y,p.size,0,Math.PI*2);
        ctx.fillStyle=p.renderColor||p.color;
        ctx.fill();
      }
    }
    function updateSlowFields(dt){
      for(let i=slowFields.length-1;i>=0;i--){
        const f=slowFields[i];
        f.life-=dt;
        if(f.life<=0)slowFields.splice(i,1);
      }
    }

    /* PLAYER & STATS */

    const BASE_STATS={
      maxHp:110,
      damage:16,
      fireRate:3,
      speed:230,
      bulletSpeed:550,
      bulletsPerShot:1,
      spread:0.18,
      pierce:0,
      onHitHeal:0,
      healAfterWave:12,
      dashCooldown:1.1,
      dashDuration:0.22,
      meleeDamage:42,
      meleeRange:95,
      meleeArc:1.7,
      meleeCooldown:0.6,
      meleeOnHitHeal:1
    };

    function createPlayer(){
      return{
        x:canvas.width/2,y:canvas.height/2,radius:10,
        hp:BASE_STATS.maxHp,maxHp:BASE_STATS.maxHp,
        damage:BASE_STATS.damage,
        fireRate:BASE_STATS.fireRate,
        speed:BASE_STATS.speed,
        bulletSpeed:BASE_STATS.bulletSpeed,
        bulletsPerShot:BASE_STATS.bulletsPerShot,
        spread:BASE_STATS.spread,
        pierce:0,
        onHitHeal:BASE_STATS.onHitHeal,
        healAfterWave:BASE_STATS.healAfterWave,
        shootTimer:0,
        dashCooldown:BASE_STATS.dashCooldown,
        dashDuration:BASE_STATS.dashDuration,
        dashCooldownTimer:0,
        dashActiveTimer:0,
        isDashing:false,
        dashVelX:0,dashVelY:0,
        dashMode:"normal",
        meleeDamage:BASE_STATS.meleeDamage,
        meleeRange:BASE_STATS.meleeRange,
        meleeArc:BASE_STATS.meleeArc,
        meleeCooldown:BASE_STATS.meleeCooldown,
        meleeCooldownTimer:0,
        meleeSwingTimer:0,
        meleeSwingDuration:0.18,
        meleeAngle:0,
        meleeOnHitHeal:BASE_STATS.meleeOnHitHeal,
        incomingDamageMult:1,
        onHitHealMult:1,
        healAfterWaveMult:1,
        styleMeter:0,
        styleMax:100,
        styleDecayRate:6,
        styleGainMult:1,
        ultId:null,
        ultCooldownTimer:0,
        ultActiveTimer:0,
        ultDamageMult:1,
        ultFireRateMult:1,
        ultSpeedMult:1,
        ultMeleeDamageMult:1,
        ultMeleeRangeMult:1,
        ultPierceBonus:0,
        ultMeleeHealBonus:0,
        ultBulletSpeedMult:1,
        ultIncomingDamageMult:1,
        ultReady:false,
        lastStandActive:false,
        mahitoTouchStacks:0,
        summonDpsMult:1,
        normalAbilities:[],
        bossAbilities:[]
      };
    }

    function getAbilityById(id){
      return normalAbilities.find(a=>a.id===id)||bossAbilities.find(a=>a.id===id)||null;
    }
    function getCurseById(id){
      return curses.find(c=>c.id===id)||null;
    }
    function hasCurse(id){return activeCurses.includes(id);}
    function hasCurse(id){return activeCurses.includes(id);}

    const NORMAL_POWER_CAP=5;
    const BOSS_POWER_CAP=2;

    function playerHasAbility(id){
      if(!player)return false;
      return player.normalAbilities.includes(id)||player.bossAbilities.includes(id)||activeCurses.includes(id);
    }

    /* ABILITY DEFINITIONS */

    const ABILITY_NORMAL_DEFS=[
      {
        id:"basic_training",
        name:"Basic Training",
        rarity:"common",
        kind:"normal",
        desc:"+10% damage, +10% fire rate\n-10% heal after wave.",
        applyStats(s){
          s.damage*=1.1;
          s.fireRate*=1.1;
          s.healAfterWave*=0.9;
        }
      },
      {
        id:"swift_steps",
        name:"Swift Steps",
        rarity:"common",
        kind:"normal",
        desc:"+15% move speed\n-5% max HP.",
        applyStats(s){
          s.speed*=1.15;
          s.maxHp*=0.95;
        }
      },
      {
        id:"steady_aim",
        name:"Steady Aim",
        rarity:"common",
        kind:"normal",
        desc:"Tighter spread, +10% bullet speed\n-10% dash distance.",
        applyStats(s){
          s.spread*=0.8;
          s.bulletSpeed*=1.1;
          s.dashDistanceMult*=0.9;
        }
      },
      /* Demon Slayer / One Piece basics */
      {
        id:"water_breathing",
        name:"Water Breathing",
        rarity:"rare",
        kind:"normal",
        desc:"+25% melee damage & range\n-10% fire rate.",
        applyStats(s){
          s.meleeDamage*=1.25;
          s.meleeRange*=1.25;
          s.fireRate*=0.9;
        }
      },
      {
        id:"water_breathing_ii",
        name:"Water Breathing II",
        rarity:"epic",
        kind:"normal",
        requires:["water_breathing"],
        desc:"+30% melee damage, dash creates splash that slows.\n-15% max HP.",
        applyStats(s){
          s.meleeDamage*=1.3;
          s.meleeRange*=1.15;
          s.maxHp*=0.85;
          s.dashSplashSlow=true;
        }
      },
      {
        id:"gear_second",
        name:"Gear Second",
        rarity:"rare",
        kind:"normal",
        desc:"+25% fire rate, +15% move speed\n+25% damage taken.",
        applyStats(s){
          s.fireRate*=1.25;
          s.speed*=1.15;
          s.incomingDamageMult*=1.25;
        }
      },
      {
        id:"thunder_breathing",
        name:"Thunder Breathing",
        rarity:"epic",
        kind:"normal",
        desc:"+40% dash distance, dash leaves lightning that damages.\n-20% base damage.",
        applyStats(s){
          s.dashDistanceMult*=1.4;
          s.dashLightningTrail=true;
          s.damage*=0.8;
        }
      },
      /* JJK / Toji / Nanami style */
      {
        id:"black_flash_rhythm",
        name:"Black Flash Rhythm",
        rarity:"rare",
        kind:"normal",
        desc:"+30% damage if you haven’t been hit in 10s.\n-10% max HP.",
        applyStats(s){
          s.blackFlashStyle=true;
          s.maxHp*=0.9;
        }
      },
      {
        id:"cursed_family_spear",
        name:"Cursed Family (Spear)",
        rarity:"epic",
        kind:"normal",
        desc:"Inverted Spear of Heaven: +60% melee damage, +20% dash speed.\n-25% max HP, -20% bullet damage.",
        applyStats(s){
          s.meleeDamage*=1.6;
          s.meleeRange*=1.1;
          s.speed*=1.1;
          s.dashDistanceMult*=1.2;
          s.maxHp*=0.75;
          s.damage*=0.8;
        }
      },
      {
        id:"nanami_ratio",
        name:"Ratio Technique",
        rarity:"epic",
        kind:"normal",
        desc:"Every 7th melee hit deals 400% damage.\n-20% fire rate.",
        applyStats(s){
          s.nanamiRatio=true;
          s.fireRate*=0.8;
        }
      },
      /* Ranged / dash replacements */
      {
        id:"dash_bomb",
        name:"Cursed Dash Bomb",
        rarity:"rare",
        kind:"normal",
        desc:"Dash leaves an explosive bomb.\n+20% dash cooldown.",
        applyStats(s){
          s.dashMode="bomb";
          s.dashCooldown*=1.2;
        }
      },
      {
        id:"dash_fire_burst",
        name:"Flame Step",
        rarity:"rare",
        kind:"normal",
        desc:"Dash emits a cone of fire.\n-10% move speed.",
        applyStats(s){
          s.dashMode="fire";
          s.speed*=0.9;
        }
      },
      {
        id:"dash_replace",
        name:"Blink Step",
        rarity:"epic",
        kind:"normal",
        desc:"Dash becomes a short-range blink.\n-20% max HP.",
        applyStats(s){
          s.dashMode="blink";
          s.maxHp*=0.8;
        }
      },
      /* lifesteal / sustain */
      {
        id:"blood_edge",
        name:"Blood Edge",
        rarity:"rare",
        kind:"normal",
        desc:"+50% melee lifesteal, +10% melee damage.\n+20% damage taken.",
        applyStats(s){
          s.meleeDamage*=1.1;
          s.meleeOnHitHeal*=1.5;
          s.incomingDamageMult*=1.2;
        }
      },
      {
        id:"ghoul_instinct",
        name:"Ghoul Instinct",
        rarity:"epic",
        kind:"normal",
        desc:"Heal 2 HP on hit, +15% damage.\nHeal after wave is halved.",
        applyStats(s){
          s.onHitHeal+=2;
          s.damage*=1.15;
          s.healAfterWave*=0.5;
        }
      },
      /* projectile patterns */
      {
        id:"spread_shot",
        name:"Spread Shot",
        rarity:"rare",
        kind:"normal",
        desc:"+2 bullets per shot.\n+35% spread, -10% damage.",
        applyStats(s){
          s.bulletsPerShot+=2;
          s.spread*=1.35;
          s.damage*=0.9;
        }
      },
      {
        id:"piercing_rounds",
        name:"Piercing Rounds",
        rarity:"epic",
        kind:"normal",
        desc:"+2 pierce, +20% bullet speed.\n-15% fire rate.",
        applyStats(s){
          s.pierce+=2;
          s.bulletSpeed*=1.2;
          s.fireRate*=0.85;
        }
      },
      /* archetype starting powers */
      {
        id:"shadow_garden",
        name:"Shadow Tricks",
        rarity:"rare",
        kind:"normal",
        desc:"+10% damage and move speed inside domain fields.\n-10% damage outside.",
        applyStats(s){
          s.shadowGardenBonus=true;
        }
      },
      {
        id:"survey_maneuvers",
        name:"ODM Gear",
        rarity:"rare",
        kind:"normal",
        desc:"+20% move speed, +10% dash distance.\n-10% melee damage.",
        applyStats(s){
          s.speed*=1.2;
          s.dashDistanceMult*=1.1;
          s.meleeDamage*=0.9;
        }
      },
      {
        id:"shadow_army_commander",
        name:"Shadow Commander",
        rarity:"epic",
        kind:"normal",
        desc:"Summoned shadows deal damage around you.\n-15% bullet damage, -5% max HP.",
        applyStats(s){
          s.summonAura=true;
          s.summonDpsMult*=1.0;
          s.damage*=0.85;
          s.maxHp*=0.95;
        }
      },
      {
        id:"fire_force_spark",
        name:"Ignition Boost",
        rarity:"rare",
        kind:"normal",
        desc:"+15% fire rate, dash leaves small flame.\n+10% damage taken.",
        applyStats(s){
          s.fireRate*=1.15;
          s.dashFlameTrail=true;
          s.incomingDamageMult*=1.1;
        }
      }
    ];

    const ABILITY_BOSS_DEFS=[
      {
        id:"domain_amp",
        name:"Domain Amplification",
        rarity:"legendary",
        kind:"boss",
        desc:"Ult domains last longer and deal +60% damage.\n+20% damage taken, ult cooldown +30%.",
        applyStats(s){
          s.domainAmp=true;
          s.ultDurationMult*=1.3;
          s.ultDamageMultBonus*=1.6;
          s.ultCooldownMult*=1.3;
          s.incomingDamageMult*=1.2;
        }
      },
      {
        id:"titan_hunter",
        name:"Titan Hunter",
        rarity:"legendary",
        kind:"boss",
        desc:"+40% damage vs bosses, +15% move speed.\n-20% damage vs normal enemies.",
        applyStats(s){
          s.bossDamageMult*=1.4;
          s.normalEnemyDamageMult*=0.8;
          s.speed*=1.15;
        }
      },
      {
        id:"cursed_family_overdrive",
        name:"Cursed Family: Overdrive",
        rarity:"legendary",
        kind:"boss",
        requires:["cursed_family_spear"],
        desc:"+80% melee damage & dash distance.\n-35% max HP, -25% bullet damage.",
        applyStats(s){
          s.meleeDamage*=1.8;
          s.dashDistanceMult*=1.4;
          s.maxHp*=0.65;
          s.damage*=0.75;
        }
      },
      {
        id:"nanami_overtime",
        name:"Overtime",
        rarity:"legendary",
        kind:"boss",
        requires:["nanami_ratio"],
        desc:"After 60s in a run, +80% damage and huge style gain.\nBefore then, -15% damage.",
        applyStats(s){
          s.nanamiOvertime=true;
        }
      },
      {
        id:"shadow_legion",
        name:"Shadow Legion",
        rarity:"legendary",
        kind:"boss",
        requires:["shadow_army_commander"],
        desc:"Shadow aura damage massively increased.\n-20% move speed, -20% heal after wave.",
        applyStats(s){
          s.summonDpsMult*=2.2;
          s.speed*=0.8;
          s.healAfterWave*=0.8;
        }
      },
      {
        id:"limitless_greed",
        name:"Limitless Greed",
        rarity:"legendary",
        kind:"boss",
        desc:"Power cap removed (no limit on powers).\nAll your stats are reduced by ~25%.",
        applyStats(s){
          s.limitlessGreed=true;
          s.globalStatDownMult*=0.75;
        }
      }
    ];

    const CURSE_DEFS=[
      {
        id:"glass_cannon",
        name:"Glass Cannon Curse",
        rarity:"legendary",
        kind:"curse",
        desc:"+70% damage, +20% fire rate.\nMax HP -55%, +25% damage taken.",
        applyStats(s){
          s.damage*=1.7;
          s.fireRate*=1.2;
          s.maxHp*=0.45;
          s.incomingDamageMult*=1.25;
        }
      },
      {
        id:"blood_price",
        name:"Blood Price",
        rarity:"legendary",
        kind:"curse",
        desc:"Heal 5 HP on hit.\nHeal after wave set to 0, +30% damage taken.",
        applyStats(s){
          s.onHitHeal+=5;
          s.healAfterWave*=0;
          s.incomingDamageMult*=1.3;
        }
      },
      {
        id:"cursed_swarm",
        name:"Cursed Swarm",
        rarity:"legendary",
        kind:"curse",
        desc:"+30% fire rate, enemies spawn more and move faster.",
        applyStats(s){
          s.fireRate*=1.3;
          s.enemyHpMult*=1.1;
          s.enemySpeedMult*=1.2;
          s.enemyCountMult*=1.25;
        }
      },
      {
        id:"time_limit",
        name:"Time Limit",
        rarity:"legendary",
        kind:"curse",
        desc:"Style gains quickly but decays fast; ult charges faster.\n+15% incoming damage.",
        applyStats(s){
          s.styleGainMult*=1.5;
          s.styleDecayRateMult*=1.5;
          s.ultChargeGainMult*=1.4;
          s.incomingDamageMult*=1.15;
        }
      }
    ];

    normalAbilities=ABILITY_NORMAL_DEFS;
    bossAbilities=ABILITY_BOSS_DEFS;
    curses=CURSE_DEFS;

    function applyStatsFromAbilityDef(stats,def){
      if(def && typeof def.applyStats==="function")def.applyStats(stats);
    }

    function recomputePlayerStats(){
      if(!player)return;
      const oldMax=player.maxHp||BASE_STATS.maxHp;
      const oldHp=player.hp||BASE_STATS.maxHp;

      const s={
        maxHp:BASE_STATS.maxHp,
        damage:BASE_STATS.damage,
        fireRate:BASE_STATS.fireRate,
        speed:BASE_STATS.speed,
        bulletSpeed:BASE_STATS.bulletSpeed,
        bulletsPerShot:BASE_STATS.bulletsPerShot,
        spread:BASE_STATS.spread,
        pierce:0,
        onHitHeal:BASE_STATS.onHitHeal,
        healAfterWave:BASE_STATS.healAfterWave,
        dashCooldown:BASE_STATS.dashCooldown,
        dashDuration:BASE_STATS.dashDuration,
        dashMode:"normal",
        dashDistanceMult:1,
        meleeDamage:BASE_STATS.meleeDamage,
        meleeRange:BASE_STATS.meleeRange,
        meleeArc:BASE_STATS.meleeArc,
        meleeCooldown:BASE_STATS.meleeCooldown,
        meleeOnHitHeal:BASE_STATS.meleeOnHitHeal,
        incomingDamageMult:1,
        onHitHealMult:1,
        healAfterWaveMult:1,
        styleGainMult:1,
        styleDecayRateMult:1,
        ultDurationMult:1,
        ultDamageMultBonus:1,
        ultCooldownMult:1,
        ultChargeGainMult:1,
        summonDpsMult:1,
        bossDamageMult:1,
        normalEnemyDamageMult:1,
        globalStatDownMult:1,
        enemyHpMult:1,
        enemySpeedMult:1,
        enemyCountMult:1,
        dashSplashSlow:false,
        dashLightningTrail:false,
        dashFlameTrail:false,
        shadowGardenBonus:false,
        nanamiRatio:false,
        nanamiOvertime:false,
        summonAura:false,
        blackFlashStyle:false,
        limitlessGreed:false
      };

      // apply curses first (they can buff enemies / global penalties)
      activeCurses.forEach(id=>{
        const def=getCurseById(id);
        applyStatsFromAbilityDef(s,def);
      });

      // normal & boss powers
      player.normalAbilities.forEach(id=>{
        const def=getAbilityById(id);
        applyStatsFromAbilityDef(s,def);
      });
      player.bossAbilities.forEach(id=>{
        const def=getAbilityById(id);
        applyStatsFromAbilityDef(s,def);
      });

      // global stat down (from Limitless Greed)
      s.maxHp*=s.globalStatDownMult;
      s.damage*=s.globalStatDownMult;
      s.fireRate*=s.globalStatDownMult;
      s.speed*=s.globalStatDownMult;
      s.bulletSpeed*=s.globalStatDownMult;
      s.meleeDamage*=s.globalStatDownMult;

      // write back to player
      player.maxHp=Math.max(10,s.maxHp);
      const ratio=oldHp/oldMax;
      player.hp=Math.max(1,Math.min(player.maxHp,player.maxHp*ratio));

      player.damage=s.damage;
      player.fireRate=s.fireRate;
      player.speed=s.speed;
      player.bulletSpeed=s.bulletSpeed;
      player.bulletsPerShot=Math.max(1,Math.round(s.bulletsPerShot));
      player.spread=s.spread;
      player.pierce=s.pierce;
      player.onHitHeal=s.onHitHeal*s.onHitHealMult;
      player.healAfterWave=s.healAfterWave*s.healAfterWaveMult;
      player.dashCooldown=s.dashCooldown;
      player.dashDuration=s.dashDuration;
      player.meleeDamage=s.meleeDamage;
      player.meleeRange=s.meleeRange;
      player.meleeArc=s.meleeArc;
      player.meleeCooldown=s.meleeCooldown;
      player.meleeOnHitHeal=s.meleeOnHitHeal;
      player.incomingDamageMult=s.incomingDamageMult;
      player.styleGainMult=s.styleGainMult;
      player.styleDecayRateBase=BASE_STATS.styleDecayRate||6;
      player.styleDecayRate=player.styleDecayRateBase*s.styleDecayRateMult;
      player.dashMode=s.dashMode;
      player.dashDistanceMult=s.dashDistanceMult;
      player.summonAura=s.summonAura;
      player.summonDpsMult=s.summonDpsMult;
      player.bossDamageMult=s.bossDamageMult;
      player.normalEnemyDamageMult=s.normalEnemyDamageMult;
      player.blackFlashStyle=s.blackFlashStyle;
      player.nanamiRatio=s.nanamiRatio;
      player.nanamiOvertime=s.nanamiOvertime;
      player.limitlessGreed=s.limitlessGreed;

      // dash visual flags
      player.dashSplashSlow=s.dashSplashSlow;
      player.dashLightningTrail=s.dashLightningTrail;
      player.dashFlameTrail=s.dashFlameTrail;

      // propagate enemy scale from curses
      enemyScale.hpMult*=s.enemyHpMult;
      enemyScale.speedMult*=s.enemySpeedMult;
      enemyScale.countMult*=s.enemyCountMult;
    }

    function abilityRarityClass(r){
      switch(r){
        case "common":return "card-rarity-common";
        case "rare":return "card-rarity-rare";
        case "epic":return "card-rarity-epic";
        case "legendary":return "card-rarity-legendary";
        default:return "";
      }
    }
    function abilityRarityLabel(r){
      switch(r){
        case "common":return "Common";
        case "rare":return "Rare";
        case "epic":return "Epic";
        case "legendary":return "Legendary";
        default:return "";
      }
    }

    function updateAbilitiesUI(){
      if(!player)return;
      normalAbilitiesListEl.innerHTML="";
      bossAbilitiesListEl.innerHTML="";

      const makeSlot=(id,isBoss)=>{
        const def=isBoss?bossAbilities.find(a=>a.id===id)||getAbilityById(id):getAbilityById(id);
        if(!def)return;
        const slot=document.createElement("div");
        slot.className="abilitySlot "+abilityRarityClass(def.rarity);
        slot.textContent=def.name;
        slot.title=def.desc||"";
        slot.addEventListener("click",()=>{
          replaceTarget={id,kind:isBoss?"boss":"normal"};
          showMessage(`Will replace: ${def.name} on next pick.`,2.2);
        });
        return slot;
      };

      player.normalAbilities.forEach(id=>{
        const slot=makeSlot(id,false);
        if(slot)normalAbilitiesListEl.appendChild(slot);
      });
      player.bossAbilities.forEach(id=>{
        const slot=makeSlot(id,true);
        if(slot)bossAbilitiesListEl.appendChild(slot);
      });
    }

    function updateStatsPanel(){
      statsContentEl.innerHTML="";
      if(!player)return;
      const rows=[];
      rows.push(["Wave", wave||0]);
      rows.push(["HP", `${Math.round(player.hp)}/${Math.round(player.maxHp)}`]);
      rows.push(["Damage", player.damage.toFixed(1)]);
      rows.push(["Fire Rate", player.fireRate.toFixed(2)+"/s"]);
      rows.push(["Move Speed", player.speed.toFixed(0)]);
      rows.push(["Bullet Speed", player.bulletSpeed.toFixed(0)]);
      rows.push(["Bullets/Shot", player.bulletsPerShot]);
      rows.push(["Pierce", player.pierce]);
      rows.push(["Melee Dmg", player.meleeDamage.toFixed(1)]);
      rows.push(["Melee Range", player.meleeRange.toFixed(0)]);
      rows.push(["Dash CD", player.dashCooldown.toFixed(2)+"s"]);
      rows.push(["Dash Mode", player.dashMode]);
      rows.push(["Heal / Wave", player.healAfterWave.toFixed(1)]);
      rows.push(["On-hit Heal", player.onHitHeal.toFixed(1)]);
      rows.push(["Kills", runKills]);
      rows.push(["Normal Powers", `${player.normalAbilities.length}/${NORMAL_POWER_CAP}${player.limitlessGreed?" (ignored)":""}`]);
      rows.push(["Boss Powers", `${player.bossAbilities.length}/${BOSS_POWER_CAP}${player.limitlessGreed?" (ignored)":""}`]);
      if(activeCurses.length>0)rows.push(["Curses", activeCurses.length]);

      statsContentEl.innerHTML=rows.map(([k,v])=>`
        <div class="statRow">
          <span>${k}</span><span>${v}</span>
        </div>
      `).join("");
    }

    /* UPGRADE GENERATION */

    function rollRarity(isBossWave){
      const r=Math.random();
      if(isBossWave){
        if(r<0.25)return"common";
        if(r<0.55)return"rare";
        if(r<0.8)return"epic";
        return"legendary";
      }else{
        if(r<0.45)return"common";
        if(r<0.75)return"rare";
        if(r<0.95)return"epic";
        return"legendary";
      }
    }

    function randomFrom(arr){return arr[Math.floor(Math.random()*arr.length)]||null;}

    function filterAvailableAbilityPool(pool,rarity){
      const owned=id=>playerHasAbility(id);
      return pool.filter(def=>{
        if(def.rarity!==rarity)return false;
        if(owned(def.id))return false;
        if(def.requires){
          const reqs=Array.isArray(def.requires)?def.requires:[def.requires];
          for(const req of reqs){
            if(!playerHasAbility(req))return false;
          }
        }
        return true;
      });
    }

    function rollNonCurseAbilityByRarity(rarity){
      let pool=[...ABILITY_NORMAL_DEFS,...ABILITY_BOSS_DEFS];
      pool=filterAvailableAbilityPool(pool,rarity);
      if(pool.length===0)return null;
      return randomFrom(pool);
    }

    function rollCurseAbility(){
      const pool=CURSE_DEFS.filter(def=>!activeCurses.includes(def.id));
      if(pool.length===0)return null;
      return randomFrom(pool);
    }

    let awaitingUpgrade=false;
    let currentWaveIsBoss=false;

    function openUpgradePanel(isBossWave){
      if(!player)return;
      awaitingUpgrade=true;
      currentWaveIsBoss=isBossWave;
      gameState="upgrading";
      upgradePanel.style.display="flex";
      upgradesContainer.innerHTML="";

      const options=[];
      if(isBossWave){
        // three non-curse, one guaranteed curse
        for(let i=0;i<3;i++){
          const rarity=rollRarity(true);
          let picked=rollNonCurseAbilityByRarity(rarity);
          if(!picked){
            // fall back any rarity
            const allPool=[...ABILITY_NORMAL_DEFS,...ABILITY_BOSS_DEFS].filter(d=>!playerHasAbility(d.id));
            if(allPool.length>0)picked=randomFrom(allPool);
          }
          if(picked)options.push({def:picked,isCurse:false});
        }
        // guarantee curse
        const curse=rollCurseAbility();
        if(curse)options.push({def:curse,isCurse:true});

        // ensure at least one legendary
        const hasLegendary=options.some(o=>o.def && o.def.rarity==="legendary" && !o.isCurse);
        if(!hasLegendary){
          const legendaryPool=[...ABILITY_NORMAL_DEFS,...ABILITY_BOSS_DEFS]
            .filter(d=>d.rarity==="legendary" && !playerHasAbility(d.id));
          if(legendaryPool.length>0){
            const forced=randomFrom(legendaryPool);
            if(options.length>0)options[0]={def:forced,isCurse:false};
            else options.push({def:forced,isCurse:false});
          }
        }
      }else{
        for(let i=0;i<3;i++){
          const rarity=rollRarity(false);
          let picked=rollNonCurseAbilityByRarity(rarity);
          if(!picked){
            const allPool=[...ABILITY_NORMAL_DEFS,...ABILITY_BOSS_DEFS].filter(d=>!playerHasAbility(d.id));
            if(allPool.length>0)picked=randomFrom(allPool);
          }
          if(picked)options.push({def:picked,isCurse:false});
        }
      }

      if(options.length===0){
        // nothing available – just continue
        closeUpgradePanel();
        return;
      }

      options.forEach((opt,idx)=>{
        const def=opt.def;
        if(!def)return;
        const btn=document.createElement("button");
        btn.className=`upgradeButton ${abilityRarityClass(def.rarity)}`;
        const rarityLabel=abilityRarityLabel(def.rarity)+(opt.isCurse?" Curse":"");
        const reqTxt=def.requires?" (needs: "+(Array.isArray(def.requires)?def.requires.join(", "):def.requires)+")":"";
        btn.innerHTML=`
          <div class="upgradeTopRow">
            <span class="upgradeName">${def.name}</span>
            <span class="rarityBadge rarity-${def.rarity}">${rarityLabel}</span>
          </div>
          <div class="upgradeDesc">${def.desc.replace(/\n/g,"<br>")}${reqTxt}</div>
        `;
        btn.title=def.desc;
        btn.addEventListener("click",()=>{
          pickUpgrade(def,opt.isCurse);
        });
        upgradesContainer.appendChild(btn);
      });

      showMessage(isBossWave?
        "Boss cleared – choose a Legendary and a Curse if you dare.":
        "Wave cleared – pick your next power (or skip).",
        3
      );
    }

    function closeUpgradePanel(){
      upgradePanel.style.display="none";
      gameState="playing";
      awaitingUpgrade=false;
      replaceTarget=null;
    }

    function pickUpgrade(def,isCurse){
      if(!player)return;
      if(isCurse){
        activeCurses.push(def.id);
        cosmeticStats.cursesTaken++;
      }else if(def.kind==="boss"){
        if(player.bossAbilities.length>=BOSS_POWER_CAP && !player.limitlessGreed){
          // need to replace
          let idx=0;
          if(replaceTarget && replaceTarget.kind==="boss"){
            idx=player.bossAbilities.indexOf(replaceTarget.id);
            if(idx===-1)idx=0;
          }
          player.bossAbilities.splice(idx,1);
        }
        player.bossAbilities.push(def.id);
        if(def.id==="limitless_greed"){
          noLimitMode=true;
        }
      }else{ // normal
        if(player.normalAbilities.length>=NORMAL_POWER_CAP && !player.limitlessGreed){
          let idx=0;
          if(replaceTarget && replaceTarget.kind==="normal"){
            idx=player.normalAbilities.indexOf(replaceTarget.id);
            if(idx===-1)idx=0;
          }
          player.normalAbilities.splice(idx,1);
        }
        player.normalAbilities.push(def.id);
      }

      recomputePlayerStats();
      updateAbilitiesUI();
      checkCosmeticUnlocks();
      saveCosmeticStats();
      closeUpgradePanel();
      startNextWave();
    }

    skipButton.addEventListener("click",()=>{
      closeUpgradePanel();
      startNextWave();
    });

    /* RUN / WAVES / ENEMIES */

    function resetEnemyScaling(){
      const ds=DIFFICULTY_SETTINGS[difficulty]||DIFFICULTY_SETTINGS.normal;
      enemyScale.hpMult=ds.enemyHpMult;
      enemyScale.damageMult=ds.enemyDamageMult;
      enemyScale.countMult=ds.enemyCountMult;
      enemyScale.speedMult=1;
      enemyScale.bulletSpeedMult=1;
      enemyScale.bulletDamageMult=1;
    }

    function startRun(){
      bullets=[];
      enemies=[];
      enemyBullets=[];
      playerBombs.length=0;
      slowFields.length=0;
      runKills=0;
      activeCurses=[];
      noLimitMode=false;
      domainField.active=false;
      bossGenjutsuTimer=0;
      currentWaveEvent=null;
      resetEnemyScaling();

      player=createPlayer();
      player.ultId=selectedUltId;
      player.styleMeter=0;
      player.ultCharge=0;
      player.ultCooldownTimer=0;
      player.ultActiveTimer=0;
      player.normalAbilities=[];
      player.bossAbilities=[];
      player.mahitoTouchStacks=0;

      // starting abilities from archetype
      const arch=ARCHETYPES[selectedArchetype]||ARCHETYPES.sorcerer;
      if(arch.startAbilities){
        arch.startAbilities.forEach(id=>{
          if(!player.normalAbilities.includes(id))player.normalAbilities.push(id);
        });
      }
      recomputePlayerStats();
      updateAbilitiesUI();
      updateStatsPanel();

      wave=0;
      gameState="playing";
      mainMenu.style.display="none";
      showMessage("Run started – survive and stack powers.",2.5);
      cosmeticStats.maxWaveEver=Math.max(cosmeticStats.maxWaveEver,wave);
      saveCosmeticStats();
      startNextWave();
    }

    function isBossWave(w){return w>0 && w%5===0;}

    function startNextWave(){
      if(gameState!=="playing")return;
      wave++;
      cosmeticStats.maxWaveEver=Math.max(cosmeticStats.maxWaveEver,wave);
      saveCosmeticStats();

      // scale enemies slightly each wave
      enemyScale.hpMult*=1.05;
      enemyScale.damageMult*=1.03;
      enemyScale.speedMult*=1.02;
      enemyScale.countMult*=1.03;

      bullets.length=0;
      enemyBullets.length=0;
      playerBombs.length=0;
      slowFields.length=0;
      enemies.length=0;

      const boss=isBossWave(wave);
      if(boss)spawnBossWave();
      else spawnRegularWave();

      currentWaveIsBoss=boss;
      updateHUD();
      updateStatsPanel();
    }

    function spawnRegularWave(){
      const baseCount=6+Math.floor(wave*1.4);
      const total=Math.round(baseCount*enemyScale.countMult);
      for(let i=0;i<total;i++){
        const t=Math.random();
        let kind="chaser";
        if(t>0.7)kind="shooter";
        if(t>0.9)kind="bomber";
        spawnEnemy(kind);
      }
      showMessage(`Wave ${wave} – ${total} enemies.`,2);
    }

    function spawnEnemy(kind){
      let x,y;
      if(Math.random()<0.5){
        x=Math.random()*canvas.width;
        y=Math.random()<0.5?-40:canvas.height+40;
      }else{
        x=Math.random()<0.5?-40:canvas.width+40;
        y=Math.random()*canvas.height;
      }
      const hpBase=kind==="bomber"?55:(kind==="shooter"?60:70);
      const speedBase=kind==="bomber"?80:(kind==="shooter"?95:110);
      const dmgBase=kind==="bomber"?34:20; // bomb damage nerfed
      enemies.push({
        id:enemyIdCounter++,
        kind,
        x,y,
        radius:kind==="bomber"?14:12,
        hp:hpBase*enemyScale.hpMult,
        maxHp:hpBase*enemyScale.hpMult,
        speed:speedBase*enemyScale.speedMult,
        contactDamage:dmgBase*enemyScale.damageMult,
        shootTimer:Math.random()*1.5
      });
    }

    function spawnBossWave(){
      const template=BOSS_TEMPLATES[(Math.floor(wave/5)-1)%BOSS_TEMPLATES.length];
      const hpBase=850+wave*90;
      const boss={
        id:enemyIdCounter++,
        kind:"boss",
        bossId:template.id,
        name:template.name,
        color:template.color,
        x:canvas.width/2,
        y:canvas.height*0.3,
        radius:30,
        hp:hpBase*enemyScale.hpMult,
        maxHp:hpBase*enemyScale.hpMult,
        speed:80*enemyScale.speedMult,
        contactDamage:35*enemyScale.damageMult,
        phase:1,
        patternTimer:0
      };
      enemies.push(boss);
      showMessage(`Boss Wave ${wave} – ${boss.name} appears!`,3);
    }

    function onEnemyKilled(e){
      runKills++;
      if(e.kind==="boss"){
        cosmeticStats.bossesKilled++;
        if(player.normalAbilities.includes("shadow_army_commander")){
          cosmeticStats.defeatedBossWithShadowCommanderOnce=true;
        }
        checkCosmeticUnlocks();
      }
      // ult charge & style
      if(player){
        player.styleMeter=Math.min(player.styleMax,player.styleMeter+8*player.styleGainMult);
        player.ultCharge=Math.min(1,player.ultCharge+0.12);
        if(player.styleMeter>=player.styleMax && !cosmeticStats.reachedStyleSOnce){
          cosmeticStats.reachedStyleSOnce=true;
          checkCosmeticUnlocks();
        }
      }
      updateHUD();
      saveCosmeticStats();
    }

    function updateHUD(){
      hudWave.textContent=`Wave ${wave}`;
      if(player){
        hudHP.textContent=`HP: ${Math.round(player.hp)}/${Math.round(player.maxHp)}`;
        hudHP.classList.toggle("low",player.hp/player.maxHp<0.35);
        const ultPercent=Math.floor((player.ultCharge||0)*100);
        hudUlt.textContent=`Ult: ${ultPercent}%`;
        hudUlt.classList.toggle("ult-ready",player.ultCharge>=1 && player.ultCooldownTimer<=0);
        const styleRank=player.styleMeter>=80?"S":player.styleMeter>=55?"A":player.styleMeter>=30?"B":"C";
        hudStyle.textContent=`Style: ${styleRank}`;
        hudStyle.classList.toggle("style-high",styleRank==="S"||styleRank==="A");
        hudStats.textContent=`DMG ${player.damage.toFixed(1)} | FR ${player.fireRate.toFixed(2)}/s | SPD ${player.speed.toFixed(0)}`;
      }else{
        hudHP.textContent="";
        hudUlt.textContent="";
        hudStyle.textContent="";
        hudStats.textContent="";
      }
      hudKills.textContent=`Kills: ${runKills}`;
    }
    function updateGame(dt){
      updateBackground(dt);
      updatePlayer(dt);
      updateEnemies(dt);
      updateBullets(dt);
      updateEnemyBullets(dt);
      updateDomainField(dt);
      updateBombVisuals(dt);
      updateFireBursts(dt);
      updateParticles(dt);
      updateSlowFields(dt);

      if(enemies.length===0 && !awaitingUpgrade){
        openUpgradePanel(isBossWave(wave));
      }

      updateHUD();
      updateStatsPanel();
    }

    function globalTimersUpdate(dt){
      if(messageTimer>0){
        messageTimer-=dt;
        if(messageTimer<=0){
          messageTimer=0;
          overlayMessageEl.textContent="";
        }
      }
      if(screenShakeTimer>0){
        screenShakeTimer-=dt;
        if(screenShakeTimer<=0){
          screenShakeTimer=0;
          screenShakeIntensity=0;
          screenShakeDuration=0;
        }
      }
      if(whiteFlashAlpha>0){
        whiteFlashAlpha=Math.max(0,whiteFlashAlpha-dt*1.8);
      }
      if(bossGenjutsuTimer>0){
        bossGenjutsuTimer-=dt;
        if(bossGenjutsuTimer<0)bossGenjutsuTimer=0;
      }
    }

    /* EXPLOSIONS / FIELDS */

    function dealExplosionDamage(x,y,radius,damage){
      if(!player)return;
      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        const d=distance(x,y,e.x,e.y);
        if(d<radius+e.radius){
          e.hp-=damage;
          spawnParticles(e.x,e.y,{
            count:16,speedMin:90,speedMax:260,
            lifeMin:0.25,lifeMax:0.6,
            sizeMin:2,sizeMax:4,
            color:"rgba(255,200,150,1)"
          });
          if(e.hp<=0){
            const dead=enemies.splice(i,1)[0];
            onEnemyKilled(dead);
          }
        }
      }
      addScreenShake(12,0.25);
      addWhiteFlash(0.25);
    }

    function spawnBomb(x,y,damage){
      playerBombs.push({
        x,y,
        radius:90,
        life:0.3,
        maxLife:0.3
      });
      dealExplosionDamage(x,y,90,damage);
    }

    function spawnSlowField(x,y){
      slowFields.push({
        x,y,
        radius:140,
        slowMult:0.55,
        life:1.8,
        maxLife:1.8
      });
    }

    function spawnFireBurst(x,y){
      const angle=Math.atan2(mousePos.y-y,mousePos.x-x);
      fireBursts.push({
        x,y,
        radius:120,
        angle,
        spread:1.3,
        life:0.4,
        maxLife:0.4,
        dps:110
      });
      spawnParticles(x,y,{
        count:18,speedMin:80,speedMax:240,
        lifeMin:0.25,lifeMax:0.6,
        sizeMin:2,sizeMax:4,
        color:"rgba(255,170,120,1)"
      });
      addScreenShake(10,0.2);
    }

    function updateBombVisuals(dt){
      for(let i=playerBombs.length-1;i>=0;i--){
        const b=playerBombs[i];
        b.life-=dt;
        if(b.life<=0)playerBombs.splice(i,1);
      }
    }

    function updateFireBursts(dt){
      for(let i=fireBursts.length-1;i>=0;i--){
        const f=fireBursts[i];
        f.life-=dt;
        if(f.life<=0){fireBursts.splice(i,1);continue;}
        for(let j=enemies.length-1;j>=0;j--){
          const e=enemies[j];
          const dx=e.x-f.x,dy=e.y-f.y;
          const dist=Math.hypot(dx,dy)||1;
          const ang=Math.atan2(dy,dx);
          if(dist<f.radius+e.radius && Math.abs(angleDiff(ang,f.angle))<=f.spread/2){
            const dmg=f.dps*dt;
            e.hp-=dmg;
            if(e.hp<=0){
              const dead=enemies.splice(j,1)[0];
              onEnemyKilled(dead);
            }
          }
        }
      }
    }

    /* ULT SYSTEM */

    let activeUltDef=null;

    const ULT_DEFS={
      jjk_domain:{
        id:"jjk_domain",
        name:"Domain Expansion",
        duration:7,
        cooldown:18,
        isDomain:true,
        onStart(p){
          clearUltMultipliers();
          p.ultDamageMult=1.7;
          p.ultFireRateMult=1.25;
          domainField.active=true;
          domainField.type="jjk";
          domainField.x=p.x;
          domainField.y=p.y;
          domainField.radius=240;
          domainField.color="rgba(80,40,160,0.3)";
          domainField.edgeColor="rgba(220,190,255,0.95)";
        },
        onEnd(p){
          if(domainField.type==="jjk")domainField.active=false;
        }
      },
      ofa_100:{
        id:"ofa_100",
        name:"OFA 100%",
        duration:5.5,
        cooldown:20,
        isDomain:false,
        onStart(p){
          clearUltMultipliers();
          p.ultDamageMult=1.9;
          p.ultFireRateMult=1.4;
          p.ultSpeedMult=1.5;
          p.ultIncomingDamageMult=0.7;
        },
        onEnd:clearUltMultipliers
      },
      demon_mark:{
        id:"demon_mark",
        name:"Demon Mark",
        duration:6,
        cooldown:18,
        isDomain:false,
        onStart(p){
          clearUltMultipliers();
          p.ultDamageMult=1.6;
          p.ultMeleeDamageMult=2.0;
          p.ultMeleeRangeMult=1.4;
        },
        onEnd:clearUltMultipliers
      },
      gear_fifth:{
        id:"gear_fifth",
        name:"Gear Fifth",
        duration:7,
        cooldown:22,
        isDomain:false,
        onStart(p){
          clearUltMultipliers();
          p.ultDamageMult=1.5;
          p.ultFireRateMult=1.6;
          p.ultSpeedMult=1.35;
          p.ultPierceBonus=2;
        },
        onEnd:clearUltMultipliers
      },
      susanoo_guardian:{
        id:"susanoo_guardian",
        name:"Susanoo Guardian",
        duration:8,
        cooldown:24,
        isDomain:false,
        onStart(p){
          clearUltMultipliers();
          p.ultIncomingDamageMult=0.45;
          p.ultDamageMult=1.25;
        },
        onEnd:clearUltMultipliers
      },
      cyber_sandevistan:{
        id:"cyber_sandevistan",
        name:"Sandevistan Burst",
        duration:4,
        cooldown:18,
        isDomain:false,
        onStart(p){
          clearUltMultipliers();
          p.ultSpeedMult=2.0;
          p.ultFireRateMult=1.8;
        },
        onEnd:clearUltMultipliers
      },
      ghoul_rampage:{
        id:"ghoul_rampage",
        name:"Ghoul Rampage",
        duration:6,
        cooldown:20,
        isDomain:false,
        onStart(p){
          clearUltMultipliers();
          p.ultMeleeDamageMult=2.2;
          p.ultMeleeHealBonus=4;
          p.ultIncomingDamageMult=1.2;
        },
        onEnd:clearUltMultipliers
      },
      flame_domain:{
        id:"flame_domain",
        name:"Flame Ring",
        duration:7,
        cooldown:20,
        isDomain:true,
        onStart(p){
          clearUltMultipliers();
          p.ultDamageMult=1.4;
          domainField.active=true;
          domainField.type="flame";
          domainField.x=p.x;
          domainField.y=p.y;
          domainField.radius=220;
          domainField.color="rgba(255,120,60,0.28)";
          domainField.edgeColor="rgba(255,200,140,0.95)";
        },
        onEnd(p){
          if(domainField.type==="flame")domainField.active=false;
        }
      },
      bankai_field:{
        id:"bankai_field",
        name:"Bankai Field",
        duration:7,
        cooldown:22,
        isDomain:true,
        onStart(p){
          clearUltMultipliers();
          p.ultDamageMult=1.5;
          domainField.active=true;
          domainField.type="bankai";
          domainField.x=p.x;
          domainField.y=p.y;
          domainField.radius=230;
          domainField.color="rgba(120,160,255,0.25)";
          domainField.edgeColor="rgba(220,240,255,0.95)";
        },
        onEnd(p){
          if(domainField.type==="bankai")domainField.active=false;
        }
      },
      haki_burst:{
        id:"haki_burst",
        name:"Conqueror's Haki",
        duration:4.5,
        cooldown:20,
        isDomain:false,
        onStart(p){
          clearUltMultipliers();
          p.ultDamageMult=1.7;
        },
        onEnd:clearUltMultipliers
      },
      chimera_shadow_garden:{
        id:"chimera_shadow_garden",
        name:"Chimera Shadow Garden",
        duration:7.5,
        cooldown:24,
        isDomain:true,
        onStart(p){
          clearUltMultipliers();
          p.ultDamageMult=1.4;
          p.ultMeleeDamageMult=1.4;
          domainField.active=true;
          domainField.type="shadow";
          domainField.x=p.x;
          domainField.y=p.y;
          domainField.radius=240;
          domainField.color="rgba(40,40,80,0.45)";
          domainField.edgeColor="rgba(190,150,255,0.95)";
        },
        onEnd(p){
          if(domainField.type==="shadow")domainField.active=false;
        }
      },
      thunder_god_avatar:{
        id:"thunder_god_avatar",
        name:"Thunder God Avatar",
        duration:6.5,
        cooldown:22,
        isDomain:true,
        onStart(p){
          clearUltMultipliers();
          p.ultDamageMult=1.5;
          p.ultSpeedMult=1.4;
          domainField.active=true;
          domainField.type="thunder";
          domainField.x=p.x;
          domainField.y=p.y;
          domainField.radius=220;
          domainField.color="rgba(160,200,255,0.3)";
          domainField.edgeColor="rgba(230,250,255,0.95)";
        },
        onEnd(p){
          if(domainField.type==="thunder")domainField.active=false;
        }
      },
      orbital_strike:{
        id:"orbital_strike",
        name:"Orbital Strike",
        duration:0.1,
        cooldown:22,
        isDomain:false,
        onStart(p){
          clearUltMultipliers();
          // massive instant strike on all enemies
          for(let i=enemies.length-1;i>=0;i--){
            const e=enemies[i];
            const dmg=210;
            e.hp-=dmg;
            spawnParticles(e.x,e.y,{
              count:18,speedMin:100,speedMax:260,
              lifeMin:0.25,lifeMax:0.6,
              sizeMin:2,sizeMax:4,
              color:"rgba(230,240,255,1)"
            });
            if(e.hp<=0){
              const dead=enemies.splice(i,1)[0];
              onEnemyKilled(dead);
            }
          }
          addScreenShake(16,0.3);
          addWhiteFlash(0.45);
        },
        onEnd:clearUltMultipliers
      }
    };

    function clearUltMultipliers(){
      if(!player)return;
      player.ultDamageMult=1;
      player.ultFireRateMult=1;
      player.ultSpeedMult=1;
      player.ultMeleeDamageMult=1;
      player.ultMeleeRangeMult=1;
      player.ultPierceBonus=0;
      player.ultMeleeHealBonus=0;
      player.ultBulletSpeedMult=1;
      player.ultIncomingDamageMult=1;
    }

    function tryUseUlt(){
      if(!player||gameState!=="playing")return;
      if(player.ultCharge<1||player.ultCooldownTimer>0||player.ultActiveTimer>0)return;
      const def=ULT_DEFS[player.ultId]||ULT_DEFS.jjk_domain;
      activeUltDef=def;
      player.ultCharge=0;
      player.ultCooldownTimer=def.cooldown;
      player.ultActiveTimer=def.duration;
      if(def.isDomain){
        cosmeticStats.totalDomainsCast++;
        saveCosmeticStats();
        checkCosmeticUnlocks();
      }
      if(def.onStart)def.onStart(player);
      addWhiteFlash(0.35);
      addScreenShake(12,0.25);
      showMessage(def.name||"Ultimate!",2.5);
    }

    function endCurrentUlt(){
      if(!player)return;
      if(activeUltDef && activeUltDef.onEnd)activeUltDef.onEnd(player);
      clearUltMultipliers();
      if(domainField.active)domainField.active=false;
      activeUltDef=null;
    }

    function updateDomainField(dt){
      if(!domainField.active||!player)return;
      if(domainField.type==="jjk"||domainField.type==="flame"||domainField.type==="bankai"||domainField.type==="shadow"||domainField.type==="thunder"){
        domainField.x=player.x;
        domainField.y=player.y;
      }
      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        const d=distance(domainField.x,domainField.y,e.x,e.y);
        if(d<domainField.radius+e.radius){
          let dps=0;
          switch(domainField.type){
            case "jjk": dps=90;break;
            case "flame": dps=70;break;
            case "bankai": dps=85;break;
            case "shadow": dps=65;break;
            case "thunder": dps=80;break;
            default: dps=60;break;
          }
          const dmg=dps*dt*(player.ultDamageMult||1);
          e.hp-=dmg;
          if(e.hp<=0){
            const dead=enemies.splice(i,1)[0];
            onEnemyKilled(dead);
          }
        }
      }
    }

    /* PLAYER */

    function damagePlayer(amount){
      if(!player||amount<=0)return;
      let mult=player.incomingDamageMult||1;
      if(player.ultActiveTimer>0)mult*=player.ultIncomingDamageMult||1;
      if(player.isDashing)mult*=0.3;
      amount*=mult;
      player.hp-=amount;
      if(player.hp<=0){
        player.hp=0;
        onPlayerDeath();
      }else{
        addScreenShake(6,0.18);
        addWhiteFlash(0.18);
      }
    }

    function onPlayerDeath(){
      gameState="gameover";
      showMessage("You died – press R to return to menu.",3.5);
    }

    function performShoot(){
      if(!player)return;
      const angleBase=Math.atan2(mousePos.y-player.y,mousePos.x-player.x);
      const bulletsCount=player.bulletsPerShot;
      const spread=player.spread;
      for(let i=0;i<bulletsCount;i++){
        const offset=(i-(bulletsCount-1)/2)*spread;
        const a=angleBase+offset+(Math.random()-0.5)*spread*0.25;
        spawnPlayerBullet(a);
      }
    }

    function spawnPlayerBullet(angle){
      const speed=player.bulletSpeed*(player.ultActiveTimer>0?(player.ultBulletSpeedMult||1):1);
      const damage=player.damage*(player.ultActiveTimer>0?(player.ultDamageMult||1):1);
      const pierce=player.pierce+(player.ultActiveTimer>0?(player.ultPierceBonus||0):0);
      bullets.push({
        x:player.x,
        y:player.y,
        vx:Math.cos(angle)*speed,
        vy:Math.sin(angle)*speed,
        radius:4,
        damage,
        pierceLeft:pierce
      });
      spawnParticles(player.x,player.y,{
        count:2,speedMin:30,speedMax:80,
        lifeMin:0.1,lifeMax:0.2,
        sizeMin:1,sizeMax:2,
        color:"rgba(255,255,255,0.8)"
      });
    }

    function startDash(){
      if(!player||gameState!=="playing")return;
      if(player.dashCooldownTimer>0)return;
      const dx=mousePos.x-player.x;
      const dy=mousePos.y-player.y;
      let dirX=dx,dirY=dy;
      const len=Math.hypot(dirX,dirY)||1;
      dirX/=len;dirY/=len;
      const dashSpeed=720*player.dashDistanceMult;
      if(player.dashMode==="blink"){
        const dist=160*player.dashDistanceMult;
        player.x=clamp(player.x+dirX*dist,player.radius,canvas.width-player.radius);
        player.y=clamp(player.y+dirY*dist,player.radius,canvas.height-player.radius);
        spawnParticles(player.x,player.y,{
          count:14,speedMin:80,speedMax:220,
          lifeMin:0.2,lifeMax:0.4,
          sizeMin:1.8,sizeMax:3.2,
          color:getDashParticleColor()
        });
      }else{
        player.isDashing=true;
        player.dashActiveTimer=player.dashDuration;
        player.dashVelX=dirX*dashSpeed;
        player.dashVelY=dirY*dashSpeed;
      }
      player.dashCooldownTimer=player.dashCooldown;
      cosmeticStats.totalDashes++;
      saveCosmeticStats();
      checkCosmeticUnlocks();

      if(player.dashSplashSlow)spawnSlowField(player.x,player.y);
      if(player.dashLightningTrail){
        dealExplosionDamage(player.x,player.y,80,player.damage*1.4);
      }
      if(player.dashFlameTrail){
        spawnFireBurst(player.x,player.y);
      }
      addScreenShake(7,0.15);
    }

    function tryMeleeAttack(){
      if(!player||gameState!=="playing")return;
      if(player.meleeCooldownTimer>0)return;
      player.meleeCooldownTimer=player.meleeCooldown;
      player.meleeSwingTimer=player.meleeSwingDuration;
      const angle=Math.atan2(mousePos.y-player.y,mousePos.x-player.x);
      player.meleeAngle=angle;

      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        const dx=e.x-player.x,dy=e.y-player.y;
        const dist=Math.hypot(dx,dy)||1;
        if(dist>player.meleeRange+e.radius)continue;
        const angToEnemy=Math.atan2(dy,dx);
        if(Math.abs(angleDiff(angToEnemy,angle))>player.meleeArc/2)continue;

        let dmg=player.meleeDamage*(player.ultActiveTimer>0?(player.ultMeleeDamageMult||1):1);
        if(e.kind==="boss")dmg*=player.bossDamageMult;
        else dmg*=player.normalEnemyDamageMult;
        e.hp-=dmg;
        spawnParticles(e.x,e.y,{
          count:12,speedMin:80,speedMax:220,
          lifeMin:0.2,lifeMax:0.45,
          sizeMin:2,sizeMax:4,
          color:"rgba(255,220,200,1)"
        });
        const healBase=player.meleeOnHitHeal+(player.ultActiveTimer>0?(player.ultMeleeHealBonus||0):0);
        player.hp=Math.min(player.maxHp,player.hp+healBase);
        player.styleMeter=Math.min(player.styleMax,player.styleMeter+6*player.styleGainMult);
        player.ultCharge=Math.min(1,player.ultCharge+0.08);

        if(player.nanamiRatio){
          player.nanamiHits=(player.nanamiHits||0)+1;
          if(player.nanamiHits>=7){
            player.nanamiHits=0;
            e.hp-=dmg*3;
          }
        }

        if(e.hp<=0){
          const dead=enemies.splice(i,1)[0];
          onEnemyKilled(dead);
        }
      }
    }

    function updatePlayer(dt){
      if(!player)return;

      player.shootTimer=Math.max(0,player.shootTimer-dt);
      player.dashCooldownTimer=Math.max(0,player.dashCooldownTimer-dt);
      player.meleeCooldownTimer=Math.max(0,player.meleeCooldownTimer-dt);
      if(player.meleeSwingTimer>0)player.meleeSwingTimer=Math.max(0,player.meleeSwingTimer-dt);

      if(player.ultCooldownTimer>0)player.ultCooldownTimer=Math.max(0,player.ultCooldownTimer-dt);
      if(player.ultActiveTimer>0){
        player.ultActiveTimer-=dt;
        if(player.ultActiveTimer<=0){
          player.ultActiveTimer=0;
          endCurrentUlt();
        }
      }

      if(player.styleMeter>0){
        const decay=player.styleDecayRate||6;
        player.styleMeter=Math.max(0,player.styleMeter-decay*dt);
      }

      let moveX=0,moveY=0;
      if(keys["a"]||keys["arrowleft"])moveX-=1;
      if(keys["d"]||keys["arrowright"])moveX+=1;
      if(keys["w"]||keys["arrowup"])moveY-=1;
      if(keys["s"]||keys["arrowdown"])moveY+=1;
      if(bossGenjutsuTimer>0){
        moveX=-moveX;
        moveY=-moveY;
      }

      const baseSpeed=player.speed*(player.ultActiveTimer>0?(player.ultSpeedMult||1):1);

      if(player.isDashing){
        player.dashActiveTimer-=dt;
        if(player.dashActiveTimer<=0){
          player.isDashing=false;
          if(player.dashMode==="bomb"){
            spawnBomb(player.x,player.y,player.damage*2.4);
          }else if(player.dashMode==="fire"){
            spawnFireBurst(player.x,player.y);
          }
        }
        player.x+=player.dashVelX*dt;
        player.y+=player.dashVelY*dt;
      }else{
        if(moveX!==0||moveY!==0){
          const len=Math.hypot(moveX,moveY)||1;
          moveX/=len;moveY/=len;
          player.x+=moveX*baseSpeed*dt;
          player.y+=moveY*baseSpeed*dt;
        }
      }

      player.x=clamp(player.x,player.radius+4,canvas.width-player.radius-4);
      player.y=clamp(player.y,player.radius+4,canvas.height-player.radius-4);

      if(mouseDown){
        const fr=player.fireRate*(player.ultActiveTimer>0?(player.ultFireRateMult||1):1);
        const interval=1/Math.max(0.1,fr);
        if(player.shootTimer<=0){
          performShoot();
          player.shootTimer=interval;
        }
      }
    }

    /* ENEMIES & BOSS PATTERNS */

    function spawnRadialEnemyShots(b,count,speed){
      for(let i=0;i<count;i++){
        const ang=i*Math.PI*2/count;
        enemyBullets.push({
          x:b.x,y:b.y,
          vx:Math.cos(ang)*speed,
          vy:Math.sin(ang)*speed,
          radius:4,
          damage:16*enemyScale.bulletDamageMult
        });
      }
    }

    function spawnFanEnemyShots(b,count,spread){
      const base=Math.atan2(player.y-b.y,player.x-b.x);
      for(let i=0;i<count;i++){
        const t=i/(count-1||1)-0.5;
        const ang=base+t*spread;
        const speed=230*enemyScale.bulletSpeedMult;
        enemyBullets.push({
          x:b.x,y:b.y,
          vx:Math.cos(ang)*speed,
          vy:Math.sin(ang)*speed,
          radius:4,
          damage:14*enemyScale.bulletDamageMult
        });
      }
    }

    function spawnTrackingShot(b,speed){
      if(!player)return;
      const ang=Math.atan2(player.y-b.y,player.x-b.x);
      enemyBullets.push({
        x:b.x,y:b.y,
        vx:Math.cos(ang)*speed*enemyScale.bulletSpeedMult,
        vy:Math.sin(ang)*speed*enemyScale.bulletSpeedMult,
        radius:5,
        damage:22*enemyScale.bulletDamageMult
      });
    }

    function spawnRushShot(b){
      if(!player)return;
      const ang=Math.atan2(player.y-b.y,player.x-b.x);
      const speed=260*enemyScale.bulletSpeedMult;
      enemyBullets.push({
        x:b.x,y:b.y,
        vx:Math.cos(ang)*speed,
        vy:Math.sin(ang)*speed,
        radius:6,
        damage:20*enemyScale.bulletDamageMult
      });
    }

    function updateBossEnemy(e,dt){
      if(!player)return;
      const dx=player.x-e.x,dy=player.y-e.y;
      const dist=Math.hypot(dx,dy)||1;
      const ang=Math.atan2(dy,dx);
      const hpRatio=e.hp/e.maxHp;

      let desired=240;
      if(e.bossId==="luffy")desired=200;
      let moveDir=0;
      if(dist>desired+50)moveDir=1;
      else if(dist<desired-50)moveDir=-1;

      e.x+=Math.cos(ang)*e.speed*dt*moveDir;
      e.y+=Math.sin(ang)*e.speed*dt*moveDir;

      e.x=clamp(e.x,e.radius,canvas.width-e.radius);
      e.y=clamp(e.y,e.radius,canvas.height-e.radius);

      // special Mahito contact
      if(e.bossId==="mahito"){
        const d=distance(e.x,e.y,player.x,player.y);
        if(d<e.radius+player.radius){
          if(!e.lastTouched){
            player.mahitoTouchStacks=(player.mahitoTouchStacks||0)+1;
            if(player.mahitoTouchStacks>=2){
              damagePlayer(player.maxHp*3);
              showMessage("Mahito touched your soul twice – instant death.",3.4);
            }else{
              damagePlayer(e.contactDamage*0.4);
              showMessage("Mahito touched you ("+player.mahitoTouchStacks+"/2).",2.2);
            }
            e.lastTouched=true;
          }
        }else{
          e.lastTouched=false;
        }
      }

      e.patternTimer+=dt;
      if(e.bossId==="mahito"){
        if(e.patternTimer>2.5){
          spawnRadialEnemyShots(e,10,180);
          e.patternTimer=0;
        }
      }else if(e.bossId==="itachi"){
        if(e.patternTimer>2.1){
          spawnFanEnemyShots(e,5,0.4);
          e.patternTimer=0;
        }
        e.genjutsuTimer=(e.genjutsuTimer||0)-dt;
        if(e.genjutsuTimer<=0 && hpRatio<0.85){
          e.genjutsuTimer=9;
          bossGenjutsuTimer=GENJUTSU_DURATION;
          showMessage("Itachi's Genjutsu – controls reversed for a moment!",3);
          addWhiteFlash(0.3);
        }
      }else if(e.bossId==="gojo"){
        if(e.patternTimer>2.6){
          spawnTrackingShot(e,260);
          e.patternTimer=0;
        }
      }else if(e.bossId==="luffy"){
        if(e.patternTimer>2.3){
          if(hpRatio>0.5){
            spawnRushShot(e);
          }else{
            spawnRadialEnemyShots(e,14,200);
          }
          e.patternTimer=0;
        }
      }

      // contact damage (soft) if not Mahito special
      if(e.bossId!=="mahito"){
        const d=distance(e.x,e.y,player.x,player.y);
        if(d<e.radius+player.radius){
          damagePlayer(e.contactDamage*dt*0.6);
        }
      }
    }

    function updateEnemies(dt){
      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        if(e.kind==="boss"){
          updateBossEnemy(e,dt);
          continue;
        }
        if(!player)continue;
        let dx=player.x-e.x,dy=player.y-e.y;
        const dist=Math.hypot(dx,dy)||1;
        dx/=dist;dy/=dist;

        let slowFactor=1;
        for(const f of slowFields){
          const d=distance(e.x,e.y,f.x,f.y);
          if(d<f.radius+e.radius)slowFactor=Math.min(slowFactor,f.slowMult);
        }

        const speed=e.speed*slowFactor;
        e.x+=dx*speed*dt;
        e.y+=dy*speed*dt;

        if(e.kind==="shooter"){
          e.shootTimer-=dt;
          if(e.shootTimer<=0){
            const a=Math.atan2(player.y-e.y,player.x-e.x);
            const sp=230*enemyScale.bulletSpeedMult;
            enemyBullets.push({
              x:e.x,y:e.y,
              vx:Math.cos(a)*sp,
              vy:Math.sin(a)*sp,
              radius:4,
              damage:14*enemyScale.bulletDamageMult
            });
            e.shootTimer=1.4+Math.random()*0.6;
          }
        }
        if(e.kind==="bomber"){
          if(dist<70){
            dealExplosionDamage(e.x,e.y,90,32*enemyScale.damageMult);
            enemies.splice(i,1);
            onEnemyKilled(e);
            continue;
          }
        }
        const d2=distance(e.x,e.y,player.x,player.y);
        if(d2<e.radius+player.radius){
          damagePlayer(e.contactDamage*dt*0.6);
        }
      }
    }

    function updateBullets(dt){
      for(let i=bullets.length-1;i>=0;i--){
        const b=bullets[i];
        b.x+=b.vx*dt;
        b.y+=b.vy*dt;
        addBulletTrailFX(b);
        if(b.x<-40||b.x>canvas.width+40||b.y<-40||b.y>canvas.height+40){
          bullets.splice(i,1);
          continue;
        }
        for(let j=enemies.length-1;j>=0;j--){
          const e=enemies[j];
          const d=distance(b.x,b.y,e.x,e.y);
          if(d<b.radius+e.radius){
            let dmg=b.damage;
            if(e.kind==="boss")dmg*=player.bossDamageMult;
            else dmg*=player.normalEnemyDamageMult;
            e.hp-=dmg;
            spawnParticles(b.x,b.y,{
              count:5,speedMin:40,speedMax:120,
              lifeMin:0.15,lifeMax:0.35,
              sizeMin:1.5,sizeMax:3,
              color:getBulletTrailParticleColor()||"rgba(245,245,245,1)"
            });
            player.styleMeter=Math.min(player.styleMax,player.styleMeter+2*player.styleGainMult);
            player.ultCharge=Math.min(1,player.ultCharge+0.03);
            b.pierceLeft--;
            if(e.hp<=0){
              const dead=enemies.splice(j,1)[0];
              onEnemyKilled(dead);
            }
            if(b.pierceLeft<0){
              bullets.splice(i,1);
              break;
            }
          }
        }
      }
    }

    function updateEnemyBullets(dt){
      for(let i=enemyBullets.length-1;i>=0;i--){
        const eb=enemyBullets[i];
        eb.x+=eb.vx*dt;
        eb.y+=eb.vy*dt;
        if(eb.x<-60||eb.x>canvas.width+60||eb.y<-60||eb.y>canvas.height+60){
          enemyBullets.splice(i,1);
          continue;
        }
        if(player){
          const d=distance(eb.x,eb.y,player.x,player.y);
          if(d<player.radius+eb.radius){
            damagePlayer(eb.damage);
            enemyBullets.splice(i,1);
          }
        }
      }
    }

    /* DRAWING */

    function drawSlowFields(){
      for(const f of slowFields){
        const t=f.life/f.maxLife;
        ctx.beginPath();
        ctx.arc(f.x,f.y,f.radius,0,Math.PI*2);
        ctx.strokeStyle="rgba(150,190,255,"+(0.3*t)+")";
        ctx.lineWidth=2;
        ctx.stroke();
      }
    }

    function drawDomainField(){
      if(!domainField.active)return;
      const g=ctx.createRadialGradient(
        domainField.x,domainField.y,0,
        domainField.x,domainField.y,domainField.radius
      );
      g.addColorStop(0,domainField.color);
      g.addColorStop(1,"rgba(0,0,0,0)");
      ctx.fillStyle=g;
      ctx.beginPath();
      ctx.arc(domainField.x,domainField.y,domainField.radius,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle=domainField.edgeColor;
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.arc(domainField.x,domainField.y,domainField.radius,0,Math.PI*2);
      ctx.stroke();
    }

    function drawPlayer(){
      if(!player)return;
      const skin=getPlayerSkinTheme();
      ctx.save();
      if(player.isDashing)ctx.globalAlpha=0.9;

      ctx.beginPath();
      ctx.arc(player.x,player.y,player.radius+2,0,Math.PI*2);
      ctx.strokeStyle=skin.outlineColor;
      ctx.lineWidth=2;
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(player.x,player.y,player.radius,0,Math.PI*2);
      ctx.fillStyle=skin.bodyColor;
      ctx.fill();

      ctx.beginPath();
      ctx.arc(player.x,player.y,player.radius+8+Math.sin(bgTime*6)*1.5,0,Math.PI*2);
      ctx.strokeStyle=skin.auraColor;
      ctx.lineWidth=1;
      ctx.stroke();

      const ang=Math.atan2(mousePos.y-player.y,mousePos.x-player.x);
      const wx=player.x+Math.cos(ang)*(player.radius+10);
      const wy=player.y+Math.sin(ang)*(player.radius+10);
      ctx.beginPath();
      ctx.moveTo(player.x,player.y);
      ctx.lineTo(wx,wy);
      ctx.strokeStyle=skin.weaponColor;
      ctx.lineWidth=2;
      ctx.stroke();

      if(player.meleeSwingTimer>0){
        const t=player.meleeSwingTimer/player.meleeSwingDuration;
        const arc=player.meleeArc;
        ctx.beginPath();
        ctx.arc(player.x,player.y,player.meleeRange,player.meleeAngle-arc/2,player.meleeAngle+arc/2);
        ctx.strokeStyle="rgba(255,230,200,"+(0.7*t)+")";
        ctx.lineWidth=3;
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawBullets(){
      const color=getBulletColor();
      ctx.fillStyle=color;
      for(const b of bullets){
        ctx.beginPath();
        ctx.arc(b.x,b.y,b.radius,0,Math.PI*2);
        ctx.fill();
      }
    }

    function drawEnemyBullets(){
      ctx.fillStyle="#ff7a7a";
      for(const eb of enemyBullets){
        ctx.beginPath();
        ctx.arc(eb.x,eb.y,eb.radius,0,Math.PI*2);
        ctx.fill();
      }
    }

    function drawEnemies(){
      for(const e of enemies){
        if(e.kind==="boss"){
          ctx.save();
          ctx.beginPath();
          ctx.arc(e.x,e.y,e.radius,0,Math.PI*2);
          ctx.fillStyle=e.color||"#ff8080";
          ctx.fill();
          ctx.lineWidth=3;
          ctx.strokeStyle="#ffffff";
          ctx.stroke();
          ctx.fillStyle="#ffffff";
          ctx.font="12px system-ui";
          ctx.textAlign="center";
          ctx.fillText(e.name||"Boss",e.x,e.y-e.radius-10);
          const hw=80,hh=6;
          const ratio=e.hp/e.maxHp;
          const bx=e.x-hw/2,by=e.y+e.radius+4;
          ctx.fillStyle="rgba(0,0,0,0.7)";
          ctx.fillRect(bx,by,hw,hh);
          ctx.fillStyle="#ff8080";
          ctx.fillRect(bx,by,hw*ratio,hh);
          ctx.restore();
        }else{
          ctx.save();
          ctx.beginPath();
          ctx.arc(e.x,e.y,e.radius,0,Math.PI*2);
          ctx.fillStyle=e.kind==="shooter"?"#f7d35c":e.kind==="bomber"?"#f06a6a":"#e494ff";
          ctx.fill();
          ctx.restore();
        }
      }
    }

    function drawBombsAndFire(){
      for(const b of playerBombs){
        const t=b.life/b.maxLife;
        ctx.beginPath();
        ctx.arc(b.x,b.y,b.radius*t,0,Math.PI*2);
        ctx.strokeStyle="rgba(255,190,120,"+t+")";
        ctx.lineWidth=2;
        ctx.stroke();
      }
      for(const f of fireBursts){
        const t=f.life/f.maxLife;
        ctx.beginPath();
        ctx.arc(f.x,f.y,f.radius,f.angle-f.spread/2,f.angle+f.spread/2);
        ctx.strokeStyle="rgba(255,150,100,"+t+")";
        ctx.lineWidth=3;
        ctx.stroke();
      }
    }

    function drawScene(){
      ctx.save();
      if(screenShakeTimer>0 && screenShakeDuration>0){
        const t=screenShakeTimer/screenShakeDuration;
        const mag=screenShakeIntensity*t;
        const ox=(Math.random()*2-1)*mag;
        const oy=(Math.random()*2-1)*mag;
        ctx.translate(ox,oy);
      }

      drawBackground();
      if(domainField.active)drawDomainField();
      drawSlowFields();
      drawBombsAndFire();
      drawEnemies();
      drawBullets();
      drawEnemyBullets();
      drawPlayer();
      drawParticles();
      ctx.restore();

      if(whiteFlashAlpha>0){
        ctx.fillStyle="rgba(255,255,255,"+whiteFlashAlpha+")";
        ctx.fillRect(0,0,canvas.width,canvas.height);
      }
    }

    /* MAIN MENU & INIT */

    function resetGame(){
      gameState="menu";
      mainMenu.style.display="flex";
    }

    function initMainMenu(){
      const tabButtons=document.querySelectorAll(".mainTabButton");
      const sections={
        playTab:document.getElementById("playTab"),
        settingsTab:document.getElementById("settingsTab"),
        achievementsTab:document.getElementById("achievementsTab"),
        cosmeticsTab:document.getElementById("cosmeticsTab")
      };
      tabButtons.forEach(btn=>{
        btn.addEventListener("click",()=>{
          const tab=btn.getAttribute("data-tab");
          tabButtons.forEach(b=>b.classList.remove("styleActive"));
          btn.classList.add("styleActive");
          Object.keys(sections).forEach(id=>{
            sections[id].style.display=(id===tab)?"block":"none";
          });
        });
      });

      document.querySelectorAll(".modeButton").forEach(btn=>{
        btn.addEventListener("click",()=>{
          difficulty=btn.getAttribute("data-mode");
          document.querySelectorAll(".modeButton").forEach(b=>b.classList.remove("styleActive"));
          btn.classList.add("styleActive");
        });
      });

      document.querySelectorAll("[data-style]").forEach(btn=>{
        btn.addEventListener("click",()=>{
          combatStyle=btn.getAttribute("data-style");
          document.querySelectorAll("[data-style]").forEach(b=>b.classList.remove("styleActive"));
          btn.classList.add("styleActive");
        });
      });

      document.querySelectorAll(".archButton").forEach(btn=>{
        btn.addEventListener("click",()=>{
          selectedArchetype=btn.getAttribute("data-arch");
          document.querySelectorAll(".archButton").forEach(b=>b.classList.remove("styleActive"));
          btn.classList.add("styleActive");
        });
      });

      document.querySelectorAll(".ultButton").forEach(btn=>{
        btn.addEventListener("click",()=>{
          selectedUltId=btn.getAttribute("data-ult");
          document.querySelectorAll(".ultButton").forEach(b=>b.classList.remove("styleActive"));
          btn.classList.add("styleActive");
        });
      });

      const startBtn=document.getElementById("startRunButton");
      startBtn.addEventListener("click",()=>{startRun();});
    }

    function gameLoop(ts){
      if(!lastTime)lastTime=ts;
      const dt=Math.min((ts-lastTime)/1000,0.033);
      lastTime=ts;

      globalTimersUpdate(dt);

      if(gameState==="playing"){
        updateGame(dt);
      }else{
        updateBackground(dt);
        updateParticles(dt);
        updateSlowFields(dt);
        updateBombVisuals(dt);
        updateFireBursts(dt);
      }

      drawScene();
      requestAnimationFrame(gameLoop);
    }

    // INITIALIZE
    loadSettings();
    setupSettingsUI();
    initCosmeticsSystem();
    initMainMenu();
    refreshAchievementsUI();
    updateHUD();
    updateStatsPanel();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
