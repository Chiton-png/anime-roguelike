<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Anime Roguelike Shooter</title>
  <style>
    * {
      box-sizing: border-box;
      padding: 0;
      margin: 0;
    }
    body {
      background: #050509;
      color: #f5f5f5;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      user-select: none;
    }
    h1 {
      font-size: 22px;
      margin-bottom: 4px;
    }
    p {
      font-size: 12px;
      margin-bottom: 6px;
      opacity: 0.8;
    }

    #container {
      position: relative;
      display: inline-block;
    }

    #game {
      display: block;
      border-radius: 8px;
      border: 2px solid #333;
      background: #000;
    }

    #hud {
      margin-top: 6px;
      font-size: 13px;
      display: flex;
      gap: 16px;
      justify-content: center;
      flex-wrap: wrap;
    }
    #hudHP.low {
      color: #ff7070;
      text-shadow: 0 0 8px rgba(255,90,90,0.9);
    }
    #hudStats.ult-ready {
      color: #e5f6ff;
      text-shadow: 0 0 8px rgba(120,215,255,0.9);
    }

    #overlayMessage {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      padding: 4px 10px;
      background: rgba(0,0,0,0.6);
      border-radius: 999px;
      font-size: 12px;
      pointer-events: none;
    }

    /* Upgrade panel */
    #upgradePanel {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.75);
      z-index: 10;
    }
    #upgradePanelInner {
      background: #101010;
      border-radius: 10px;
      padding: 14px;
      max-width: 620px;
      width: 92%;
      box-shadow: 0 0 24px rgba(0,0,0,0.9);
      font-size: 13px;
    }
    #upgradePanelInner h2 {
      margin-bottom: 6px;
      font-size: 18px;
    }
    #upgradePanelInner p {
      margin-bottom: 8px;
      font-size: 11px;
      opacity: 0.9;
    }
    #upgrades {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 6px;
    }
    .upgradeButton {
      background: #181818;
      border-radius: 6px;
      padding: 7px;
      text-align: left;
      cursor: pointer;
      font-size: 12px;
      border: 1px solid #555;
      color: #f5f5f5;
      transition: background 0.1s, transform 0.05s, box-shadow 0.1s, border-color 0.1s;
    }
    .upgradeButton:hover {
      background: #252525;
      transform: translateY(-1px);
      box-shadow: 0 0 16px rgba(255,255,255,0.16);
    }
    .upgradeTopRow {
      display: flex;
      justify-content: space-between;
      margin-bottom: 2px;
    }
    .upgradeName {
      font-weight: 600;
    }
    .upgradeDesc {
      font-size: 11px;
      opacity: 0.92;
      color: #f0f0f0;
    }

    .rarityBadge {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 999px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-weight: 600;
      border: 1px solid transparent;
    }
    .rarity-common {
      color: #b8f7b8;
      background: rgba(80,160,80,0.18);
      border-color: rgba(120,220,120,0.7);
    }
    .rarity-rare {
      color: #87c7ff;
      background: rgba(80,120,200,0.18);
      border-color: rgba(120,180,255,0.7);
    }
    .rarity-epic {
      color: #e3b3ff;
      background: rgba(150,80,200,0.20);
      border-color: rgba(210,150,255,0.8);
    }
    .rarity-legendary {
      color: #ffe08a;
      background: rgba(200,140,40,0.25);
      border-color: rgba(255,206,120,0.9);
    }

    .card-rarity-common {
      box-shadow: 0 0 6px rgba(130,220,130,0.5);
      border-color: rgba(130,220,130,0.7);
    }
    .card-rarity-rare {
      box-shadow: 0 0 9px rgba(120,180,255,0.7);
      border-color: rgba(120,180,255,0.9);
    }
    .card-rarity-epic {
      box-shadow: 0 0 11px rgba(210,140,255,0.8);
      border-color: rgba(210,140,255,1);
    }
    .card-rarity-legendary {
      box-shadow: 0 0 14px rgba(255,210,100,1);
      border-color: rgba(255,210,100,1);
    }

    #skipButton {
      margin-top: 2px;
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid #777;
      background: #222;
      color: #f5f5f5;
      cursor: pointer;
      font-size: 11px;
      float: right;
    }
    #skipButton:hover {
      background: #333;
    }

    /* Abilities bar */
    #abilitiesBar {
      margin-top: 8px;
      display: flex;
      gap: 20px;
      justify-content: center;
      flex-wrap: wrap;
      max-width: 960px;
      font-size: 11px;
    }
    .abilitiesGroup {
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: flex-start;
    }
    .abilitiesTitle {
      opacity: 0.75;
      font-size: 11px;
    }
    .abilitiesList {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      max-width: 460px;
    }
    .abilitySlot {
      border-radius: 999px;
      padding: 3px 7px;
      border: 1px solid #666;
      background: #151515;
      font-size: 10px;
      cursor: pointer;
      white-space: nowrap;
      display: inline-flex;
      align-items: center;
      transition: background 0.1s, transform 0.05s, box-shadow 0.1s, border-color 0.1s;
    }
    .abilitySlot:hover {
      background: #232323;
      transform: translateY(-1px);
    }

    .abilitySlot.card-rarity-common {
      box-shadow: 0 0 4px rgba(130,220,130,0.5);
      border-color: rgba(130,220,130,0.7);
    }
    .abilitySlot.card-rarity-rare {
      box-shadow: 0 0 6px rgba(120,180,255,0.7);
      border-color: rgba(120,180,255,0.9);
    }
    .abilitySlot.card-rarity-epic {
      box-shadow: 0 0 7px rgba(210,140,255,0.8);
      border-color: rgba(210,140,255,1);
    }
    .abilitySlot.card-rarity-legendary {
      box-shadow: 0 0 9px rgba(255,210,100,1);
      border-color: rgba(255,210,100,1);
    }

    /* Main menu */
    #mainMenu {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.9);
      z-index: 20;
    }
    #mainMenuInner {
      background: #111;
      padding: 16px 20px;
      border-radius: 10px;
      max-width: 520px;
      width: 92%;
      box-shadow: 0 0 24px rgba(0,0,0,0.9);
      text-align: center;
      font-size: 13px;
    }
    #mainMenuInner h2 {
      margin-bottom: 4px;
      font-size: 20px;
    }
    #mainMenuInner p {
      opacity: 0.85;
      margin-bottom: 6px;
      font-size: 11px;
    }
    .menuButtons {
      display: flex;
      gap: 8px;
      justify-content: center;
      flex-wrap: wrap;
      margin: 6px 0;
    }
    .menuButton {
      padding: 7px 12px;
      border-radius: 999px;
      border: 1px solid #666;
      background: #222;
      color: #f5f5f5;
      cursor: pointer;
      font-size: 12px;
      transition: background 0.1s, transform 0.05s, box-shadow 0.1s;
    }
    .menuButton:hover {
      background: #333;
      transform: translateY(-1px);
      box-shadow: 0 0 12px rgba(255,255,255,0.15);
    }
    .menuButton.styleActive {
      background: #203040;
      border-color: #7bd0ff;
      box-shadow: 0 0 12px rgba(123,208,255,0.8);
    }
    .menuHint {
      margin-top: 4px;
      font-size: 11px;
      opacity: 0.75;
    }
  </style>
</head>
<body>
  <h1>Anime Roguelike Shooter</h1>
  <p>WASD / Arrows move • Mouse aim • Left click shoot • Right click or E melee • Space dash • Boss every 5 waves • Upgrades with drawbacks</p>

  <!-- MAIN MENU -->
  <div id="mainMenu">
    <div id="mainMenuInner">
      <h2>Choose Combat Style</h2>
      <p>Start as melee slasher or ranged blaster. Anime power-ups every wave.</p>
      <div class="menuButtons">
        <button class="menuButton" data-style="melee">Melee Focus</button>
        <button class="menuButton" data-style="ranged">Ranged Focus</button>
      </div>
      <p class="menuHint">After you die, press R to restart with the same style.</p>
    </div>
  </div>

  <div id="container">
    <canvas id="game" width="960" height="540"></canvas>
    <div id="overlayMessage"></div>

    <div id="upgradePanel">
      <div id="upgradePanelInner">
        <h2>Choose a Power-Up</h2>
        <p>
          Every wave you get a power with a drawback. Max <b>5 normal</b> powers and <b>2 boss</b> powers.
          Boss waves (5, 10, 15…) can give <b>Legendary</b> and <b>Curses</b> with extreme tradeoffs.
        </p>
        <div id="upgrades"></div>
        <button id="skipButton">Skip – no power this wave</button>
      </div>
    </div>
  </div>

  <div id="hud">
    <div id="hudWave"></div>
    <div id="hudHP"></div>
    <div id="hudStats"></div>
  </div>

  <div id="abilitiesBar">
    <div class="abilitiesGroup">
      <span class="abilitiesTitle">Normal Powers (cap 5, unless Broken Limit):</span>
      <div id="normalAbilitiesList" class="abilitiesList"></div>
    </div>
    <div class="abilitiesGroup">
      <span class="abilitiesTitle">Boss Powers (cap 2):</span>
      <div id="bossAbilitiesList" class="abilitiesList"></div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const overlayMessageEl = document.getElementById("overlayMessage");
    const upgradePanel = document.getElementById("upgradePanel");
    const upgradesContainer = document.getElementById("upgrades");
    const hudWave = document.getElementById("hudWave");
    const hudHP = document.getElementById("hudHP");
    const hudStats = document.getElementById("hudStats");
    const mainMenu = document.getElementById("mainMenu");
    const skipButton = document.getElementById("skipButton");
    const normalAbilitiesListEl = document.getElementById("normalAbilitiesList");
    const bossAbilitiesListEl = document.getElementById("bossAbilitiesList");

    const keys = {};
    let mousePos = { x: canvas.width / 2, y: canvas.height / 2 };
    let mouseDown = false;

    let combatStyle = null; // "melee" or "ranged"
    let gameState = "menu"; // "menu", "playing", "upgrade", "chooseReplace", "gameover"

    let lastTime = 0;
    let messageTimer = 0;

    // Background orbs
    const bgOrbs = [];
    const MAX_BG_ORBS = 40;
    let bgTime = 0;

    // Particles
    const particles = [];

    // Screen shake / white flash
    let screenShakeTimer = 0;
    let screenShakeDuration = 0;
    let screenShakeIntensity = 0;
    let whiteFlashAlpha = 0;

    // Entities
    let player = null;
    let bullets = [];
    let enemies = [];
    let enemyBullets = [];

    // Dashes & melee ex
    let playerBombs = [];
    let fireBursts = [];

    // Waves / abilities
    let wave = 0;
    let normalAbilities = [];
    let bossAbilities = [];
    let curses = [];
    let activeCurses = [];
    let noLimitMode = false;
    let pendingAbility = null;
    let pendingCategory = null;

    // Enemy scaling from curses
    let enemyScale = {
      hpMult: 1,
      speedMult: 1,
      damageMult: 1,
      countMult: 1,
      bulletSpeedMult: 1,
      bulletDamageMult: 1
    };

    /* ==================== INPUT ==================== */

    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      keys[k] = true;

      if (e.code === "Space" && gameState === "playing") {
        startDash();
      }
      if (k === "e" && gameState === "playing") {
        tryMeleeAttack();
      }
      if (k === "r" && gameState === "gameover") {
        resetGame();
      }
    });

    window.addEventListener("keyup", (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      mousePos.x = e.clientX - rect.left;
      mousePos.y = e.clientY - rect.top;
    });

    canvas.addEventListener("mousedown", (e) => {
      if (e.button === 0) mouseDown = true;
      if (e.button === 2 && gameState === "playing") tryMeleeAttack();
    });
    canvas.addEventListener("mouseup", (e) => {
      if (e.button === 0) mouseDown = false;
    });
    canvas.addEventListener("contextmenu", (e) => e.preventDefault());

    /* ==================== UTILS ==================== */

    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }
    function distance(x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      return Math.hypot(dx, dy);
    }
    function shuffled(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }
    function angleDiff(a, b) {
      let d = a - b;
      while (d > Math.PI) d -= 2 * Math.PI;
      while (d < -Math.PI) d += 2 * Math.PI;
      return d;
    }

    function showMessage(msg, t = 2) {
      overlayMessageEl.textContent = msg;
      messageTimer = t;
    }

    function addScreenShake(intensity, duration) {
      screenShakeIntensity = Math.max(screenShakeIntensity, intensity);
      screenShakeDuration = Math.max(screenShakeDuration, duration);
      screenShakeTimer = Math.max(screenShakeTimer, duration);
    }
    function addWhiteFlash(strength) {
      whiteFlashAlpha = Math.min(1, whiteFlashAlpha + strength);
    }

    /* ==================== BACKGROUND & PARTICLES ==================== */

    function initBackground() {
      bgOrbs.length = 0;
      for (let i = 0; i < MAX_BG_ORBS; i++) {
        bgOrbs.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          r: 20 + Math.random() * 60,
          speed: 5 + Math.random() * 15,
          drift: (Math.random() * 0.4 + 0.2) * (Math.random() < 0.5 ? -1 : 1),
          alpha: 0.06 + Math.random() * 0.10
        });
      }
    }

    function updateBackground(dt) {
      bgTime += dt;
      for (const orb of bgOrbs) {
        orb.y += orb.speed * dt;
        orb.x += orb.drift * dt;
        if (orb.y - orb.r > canvas.height) orb.y = -orb.r;
        if (orb.y + orb.r < 0) orb.y = canvas.height + orb.r;
        if (orb.x - orb.r > canvas.width) orb.x = -orb.r;
        if (orb.x + orb.r < 0) orb.x = canvas.width + orb.r;
      }
    }

    function drawBackground() {
      // main gradient
      const g = ctx.createRadialGradient(
        canvas.width * 0.5,
        canvas.height * 0.35,
        0,
        canvas.width * 0.5,
        canvas.height * 0.5,
        canvas.width * 0.9
      );
      g.addColorStop(0, "#22263a");
      g.addColorStop(1, "#050509");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // soft orbs
      for (const orb of bgOrbs) {
        ctx.beginPath();
        ctx.arc(orb.x, orb.y, orb.r, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(150,170,255,${orb.alpha})`;
        ctx.fill();
      }

      // faint grid
      ctx.save();
      ctx.globalAlpha = 0.15;
      ctx.strokeStyle = "#444";
      const step = 40;
      ctx.beginPath();
      for (let x = 0; x < canvas.width; x += step) {
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
      }
      for (let y = 0; y < canvas.height; y += step) {
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
      }
      ctx.stroke();
      ctx.restore();

      // vignette
      const vg = ctx.createRadialGradient(
        canvas.width / 2,
        canvas.height / 2,
        canvas.width * 0.2,
        canvas.width / 2,
        canvas.height / 2,
        canvas.width * 0.7
      );
      vg.addColorStop(0, "rgba(0,0,0,0)");
      vg.addColorStop(1, "rgba(0,0,0,0.7)");
      ctx.fillStyle = vg;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function spawnParticles(x, y, options = {}) {
      const {
        count = 12,
        spread = Math.PI * 2,
        speedMin = 80,
        speedMax = 260,
        lifeMin = 0.25,
        lifeMax = 0.6,
        sizeMin = 2,
        sizeMax = 4,
        color = "rgba(255,255,255,1)"
      } = options;

      for (let i = 0; i < count; i++) {
        const angle = Math.random() * spread;
        const speed = speedMin + Math.random() * (speedMax - speedMin);
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        const life = lifeMin + Math.random() * (lifeMax - lifeMin);
        const size = sizeMin + Math.random() * (sizeMax - sizeMin);

        particles.push({
          x,
          y,
          vx,
          vy,
          life,
          maxLife: life,
          size,
          color,
          renderColor: color
        });
      }
    }

    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= dt;
        if (p.life <= 0) {
          particles.splice(i, 1);
          continue;
        }
        const t = p.life / p.maxLife;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= 0.97;
        p.vy += 20 * dt;

        const match = p.color.match(/rgba\((\d+),(\d+),(\d+),([\d.]+)\)/);
        if (match) {
          const r = match[1], g = match[2], b = match[3];
          p.renderColor = `rgba(${r},${g},${b},${t})`;
        } else {
          p.renderColor = p.color;
        }
      }
    }

    function drawParticles() {
      for (const p of particles) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = p.renderColor || p.color;
        ctx.fill();
      }
    }

    /* ==================== PLAYER & STATS ==================== */

    const BASE_STATS = {
      maxHp: 100,
      damage: 16,
      fireRate: 3,
      speed: 230,
      bulletSpeed: 550,
      bulletsPerShot: 1,
      spread: 0.18,
      pierce: 0,
      onHitHeal: 0,
      healAfterWave: 10,
      dashCooldown: 1.1,
      dashDuration: 0.22,
      meleeDamage: 32,
      meleeRange: 80,
      meleeArc: 1.7,
      meleeCooldown: 0.75,
      meleeOnHitHeal: 0
    };

    function createPlayer() {
      return {
        x: canvas.width / 2,
        y: canvas.height / 2,
        radius: 14,
        hp: BASE_STATS.maxHp,
        maxHp: BASE_STATS.maxHp,
        damage: BASE_STATS.damage,
        fireRate: BASE_STATS.fireRate,
        speed: BASE_STATS.speed,
        bulletSpeed: BASE_STATS.bulletSpeed,
        bulletsPerShot: BASE_STATS.bulletsPerShot,
        spread: BASE_STATS.spread,
        pierce: BASE_STATS.pierce,
        onHitHeal: BASE_STATS.onHitHeal,
        healAfterWave: BASE_STATS.healAfterWave,
        shootTimer: 0,
        dashCooldown: BASE_STATS.dashCooldown,
        dashDuration: BASE_STATS.dashDuration,
        dashCooldownTimer: 0,
        dashActiveTimer: 0,
        isDashing: false,
        dashVelX: 0,
        dashVelY: 0,
        dashMode: "normal",
        meleeDamage: BASE_STATS.meleeDamage,
        meleeRange: BASE_STATS.meleeRange,
        meleeArc: BASE_STATS.meleeArc,
        meleeCooldown: BASE_STATS.meleeCooldown,
        meleeOnHitHeal: BASE_STATS.meleeOnHitHeal,
        meleeCooldownTimer: 0,
        meleeSwingTimer: 0,
        meleeSwingDuration: 0.18,
        meleeAngle: 0,
        incomingDamageMult: 1,
        normalAbilities: [],
        bossAbilities: []
      };
    }

    function getAbilityById(id) {
      return normalAbilities.find(a => a.id === id)
        || bossAbilities.find(a => a.id === id)
        || null;
    }

    function getCurseById(id) {
      return curses.find(c => c.id === id) || null;
    }

    function hasCurse(id) {
      return activeCurses.includes(id);
    }

    function playerHasAbility(id) {
      if (!player) return false;
      return player.normalAbilities.includes(id) || player.bossAbilities.includes(id);
    }

    function hasBrokenLimit() {
      if (!player) return false;
      return player.normalAbilities.includes("broken_limit")
        || player.bossAbilities.includes("broken_limit");
    }

    function recomputeEnemyScale() {
      enemyScale = {
        hpMult: 1,
        speedMult: 1,
        damageMult: 1,
        countMult: 1,
        bulletSpeedMult: 1,
        bulletDamageMult: 1
      };
      for (const id of activeCurses) {
        const c = getCurseById(id);
        if (!c || !c.enemyMods) continue;
        const m = c.enemyMods;
        if (m.enemyHpMult) enemyScale.hpMult *= m.enemyHpMult;
        if (m.enemySpeedMult) enemyScale.speedMult *= m.enemySpeedMult;
        if (m.enemyDamageMult) enemyScale.damageMult *= m.enemyDamageMult;
        if (m.enemyCountMult) enemyScale.countMult *= m.enemyCountMult;
        if (m.enemyBulletSpeedMult) enemyScale.bulletSpeedMult *= m.enemyBulletSpeedMult;
        if (m.enemyBulletDamageMult) enemyScale.bulletDamageMult *= m.enemyBulletDamageMult;
      }
    }

    function recomputePlayerStats(keepHpRatio = true) {
      if (!player) return;
      noLimitMode = hasBrokenLimit();

      const oldMax = player.maxHp || BASE_STATS.maxHp;
      const oldRatio = oldMax > 0 ? player.hp / oldMax : 1;

      const stats = {
        maxHp: BASE_STATS.maxHp,
        damage: BASE_STATS.damage,
        fireRate: BASE_STATS.fireRate,
        speed: BASE_STATS.speed,
        bulletSpeed: BASE_STATS.bulletSpeed,
        bulletsPerShot: BASE_STATS.bulletsPerShot,
        spread: BASE_STATS.spread,
        pierce: BASE_STATS.pierce,
        onHitHeal: BASE_STATS.onHitHeal,
        healAfterWave: BASE_STATS.healAfterWave,
        dashCooldown: BASE_STATS.dashCooldown,
        dashDuration: BASE_STATS.dashDuration,
        meleeDamage: BASE_STATS.meleeDamage,
        meleeRange: BASE_STATS.meleeRange,
        meleeArc: BASE_STATS.meleeArc,
        meleeCooldown: BASE_STATS.meleeCooldown,
        meleeOnHitHeal: BASE_STATS.meleeOnHitHeal
      };

      let incomingDamageMult = 1;

      const allIds = [...player.normalAbilities, ...player.bossAbilities];
      const abilityFactor = noLimitMode ? 0.5 : 1.0;

      function applyMods(m, factor) {
        if (!m) return;
        const f = factor;

        if (m.maxHpMult) stats.maxHp *= 1 + (m.maxHpMult - 1) * f;
        if (m.maxHpAdd) stats.maxHp += m.maxHpAdd * f;
        if (m.damageMult) stats.damage *= 1 + (m.damageMult - 1) * f;
        if (m.damageAdd) stats.damage += m.damageAdd * f;
        if (m.fireRateMult) stats.fireRate *= 1 + (m.fireRateMult - 1) * f;
        if (m.fireRateAdd) stats.fireRate += m.fireRateAdd * f;
        if (m.speedMult) stats.speed *= 1 + (m.speedMult - 1) * f;
        if (m.speedAdd) stats.speed += m.speedAdd * f;
        if (m.bulletSpeedMult) stats.bulletSpeed *= 1 + (m.bulletSpeedMult - 1) * f;
        if (m.bulletSpeedAdd) stats.bulletSpeed += m.bulletSpeedAdd * f;
        if (m.bulletsPerShotAdd) stats.bulletsPerShot += m.bulletsPerShotAdd * f;
        if (m.spreadMult) stats.spread *= 1 + (m.spreadMult - 1) * f;
        if (m.spreadAdd) stats.spread += m.spreadAdd * f;
        if (m.pierceAdd) stats.pierce += m.pierceAdd * f;
        if (m.onHitHealAdd) stats.onHitHeal += m.onHitHealAdd * f;
        if (m.healAfterWaveAdd) stats.healAfterWave += m.healAfterWaveAdd * f;
        if (m.dashCooldownMult) stats.dashCooldown *= 1 + (m.dashCooldownMult - 1) * f;
        if (m.dashCooldownAdd) stats.dashCooldown += m.dashCooldownAdd * f;
        if (m.dashDurationMult) stats.dashDuration *= 1 + (m.dashDurationMult - 1) * f;
        if (m.dashDurationAdd) stats.dashDuration += m.dashDurationAdd * f;

        if (m.meleeDamageMult) stats.meleeDamage *= 1 + (m.meleeDamageMult - 1) * f;
        if (m.meleeDamageAdd) stats.meleeDamage += m.meleeDamageAdd * f;
        if (m.meleeRangeMult) stats.meleeRange *= 1 + (m.meleeRangeMult - 1) * f;
        if (m.meleeRangeAdd) stats.meleeRange += m.meleeRangeAdd * f;
        if (m.meleeArcMult) stats.meleeArc *= 1 + (m.meleeArcMult - 1) * f;
        if (m.meleeArcAdd) stats.meleeArc += m.meleeArcAdd * f;
        if (m.meleeCooldownMult) stats.meleeCooldown *= 1 + (m.meleeCooldownMult - 1) * f;
        if (m.meleeCooldownAdd) stats.meleeCooldown += m.meleeCooldownAdd * f;
        if (m.meleeOnHitHealAdd) stats.meleeOnHitHeal += m.meleeOnHitHealAdd * f;

        if (m.incomingDamageMult) {
          incomingDamageMult *= 1 + (m.incomingDamageMult - 1) * f;
        }
      }

      // abilities
      for (const id of allIds) {
        const ab = getAbilityById(id);
        if (!ab) continue;
        applyMods(ab.mods, abilityFactor);
      }

      // curses (full)
      for (const id of activeCurses) {
        const c = getCurseById(id);
        if (!c) continue;
        applyMods(c.mods, 1);
      }

      stats.maxHp = Math.max(20, stats.maxHp);
      stats.damage = Math.max(1, stats.damage);
      stats.fireRate = Math.max(0.4, stats.fireRate);
      stats.speed = Math.max(60, stats.speed);
      stats.bulletSpeed = Math.max(200, stats.bulletSpeed);
      stats.bulletsPerShot = Math.max(1, Math.round(stats.bulletsPerShot));
      stats.spread = clamp(stats.spread, 0.02, 0.7);
      stats.pierce = Math.max(0, Math.round(stats.pierce));
      stats.onHitHeal = Math.max(0, stats.onHitHeal);
      stats.healAfterWave = Math.max(0, stats.healAfterWave);
      stats.dashCooldown = clamp(stats.dashCooldown, 0.25, 3.0);
      stats.dashDuration = clamp(stats.dashDuration, 0.1, 0.6);
      stats.meleeDamage = Math.max(4, stats.meleeDamage);
      stats.meleeRange = Math.max(30, stats.meleeRange);
      stats.meleeArc = clamp(stats.meleeArc, 0.6, Math.PI * 1.4);
      stats.meleeCooldown = clamp(stats.meleeCooldown, 0.15, 2.0);
      stats.meleeOnHitHeal = Math.max(0, stats.meleeOnHitHeal);

    const newMax = stats.maxHp;
    if (keepHpRatio) {
      player.hp = clamp(oldRatio * newMax, 1, newMax);
    } else {
      player.hp = newMax;
    }

    player.maxHp = newMax;
    player.damage = stats.damage;
    player.fireRate = stats.fireRate;
    player.speed = stats.speed;
    player.bulletSpeed = stats.bulletSpeed;
    player.bulletsPerShot = stats.bulletsPerShot;
    player.spread = stats.spread;
    player.pierce = stats.pierce;
    player.onHitHeal = stats.onHitHeal;
    player.healAfterWave = stats.healAfterWave;
    player.dashCooldown = stats.dashCooldown;
    player.dashDuration = stats.dashDuration;
    player.meleeDamage = stats.meleeDamage;
    player.meleeRange = stats.meleeRange;
    player.meleeArc = stats.meleeArc;
    player.meleeCooldown = stats.meleeCooldown;
    player.meleeOnHitHeal = stats.meleeOnHitHeal;
    player.incomingDamageMult = incomingDamageMult;

    // dash mode from abilities
    let dashMode = "normal";
    const allAbilityIds = [...player.normalAbilities, ...player.bossAbilities];
    if (allAbilityIds.includes("cursed_dash_bomb")) dashMode = "bomb";
    if (allAbilityIds.includes("flame_step")) dashMode = "flame";
    if (allAbilityIds.includes("blink_step")) dashMode = "blink";
    player.dashMode = dashMode;
  }
  /* ==================== ABILITY & CURSE DEFINITIONS ==================== */

  function addNormalAbility(id, name, rarity, description, mods, requires = null, requiresAll = null) {
    normalAbilities.push({ id, name, rarity, description, mods, requires, requiresAll, category: "normal" });
  }
  function addBossAbility(id, name, rarity, description, mods, requires = null, requiresAll = null) {
    bossAbilities.push({ id, name, rarity, description, mods, requires, requiresAll, category: "boss" });
  }
  function addCurse(id, name, rarity, description, mods, enemyMods) {
    curses.push({ id, name, rarity, description, mods, enemyMods, isCurse: true });
  }

  function initAbilities() {
    normalAbilities.length = 0;
    bossAbilities.length = 0;
    curses.length = 0;

    // ===== Normal abilities (all have drawbacks) =====
    addNormalAbility(
      "cursed_overflow",
      "Cursed Overflow",
      "Rare",
      "DMG +25%, on-hit heal +0.7, max HP -15%, wave heal -5.",
      { damageMult: 1.25, onHitHealAdd: 0.7, maxHpMult: 0.85, healAfterWaveAdd: -5 }
    );
    addNormalAbility(
      "quirk_booster",
      "Quirk Booster",
      "Common",
      "Fire rate +25%, speed +10%, DMG -10%, spread +15%.",
      { fireRateMult: 1.25, speedMult: 1.1, damageMult: 0.9, spreadMult: 1.15 }
    );
    addNormalAbility(
      "survey_maneuvers",
      "Survey Maneuvers",
      "Rare",
      "Speed +35%, dash CD -25%, max HP -10%, wave heal -5.",
      { speedMult: 1.35, dashCooldownMult: 0.75, maxHpMult: 0.9, healAfterWaveAdd: -5 }
    );
    addNormalAbility(
      "kaiju_instinct",
      "Kaiju Instinct",
      "Rare",
      "Max HP +50, DMG +15%, fire rate -10%, spread +10%.",
      { maxHpAdd: 50, damageMult: 1.15, fireRateMult: 0.9, spreadMult: 1.1 }
    );
    addNormalAbility(
      "shadow_garden",
      "Shadow Garden Arts",
      "Rare",
      "DMG +20%, spread -20%, fire rate -10%, speed -10%.",
      { damageMult: 1.2, spreadMult: 0.8, fireRateMult: 0.9, speedMult: 0.9 }
    );
    addNormalAbility(
      "edgerunner_core",
      "Edgerunner Overclock",
      "Epic",
      "Fire rate +35%, speed +20%, dash CD -20%, max HP -25%, wave heal -20.",
      { fireRateMult: 1.35, speedMult: 1.2, dashCooldownMult: 0.8, maxHpMult: 0.75, healAfterWaveAdd: -20 }
    );
    addNormalAbility(
      "water_breathing",
      "Water Breathing",
      "Rare",
      "Melee range +25%, melee CD -15%, bullet DMG -10%, wave heal -5.",
      { meleeRangeMult: 1.25, meleeCooldownMult: 0.85, damageMult: 0.9, healAfterWaveAdd: -5 }
    );
    addNormalAbility(
      "blood_edge",
      "Blood-Edge Style",
      "Rare",
      "Melee DMG +45%, melee lifesteal +0.8, melee CD +20%, max HP -10%.",
      { meleeDamageMult: 1.45, meleeOnHitHealAdd: 0.8, meleeCooldownMult: 1.2, maxHpMult: 0.9 }
    );
    addNormalAbility(
      "six_eyes",
      "Six Eyes Focus",
      "Epic",
      "Bullet speed +45%, spread -25%, DMG +20%, max HP -15%, wave heal -15.",
      { bulletSpeedMult: 1.45, spreadMult: 0.75, damageMult: 1.2, maxHpMult: 0.85, healAfterWaveAdd: -15 }
    );
    addNormalAbility(
      "gear_shift",
      "Gear Shift",
      "Epic",
      "Fire rate +20%, DMG +15%, speed -10%, max HP -10%.",
      { fireRateMult: 1.2, damageMult: 1.15, speedMult: 0.9, maxHpMult: 0.9 }
    );

    // dash mods
    addNormalAbility(
      "cursed_dash_bomb",
      "Cursed Dash Bomb",
      "Rare",
      "Dash drops a bomb (big AOE DMG). Dash CD +15%, max HP -10%.",
      { dashCooldownMult: 1.15, maxHpMult: 0.9 }
    );
    addNormalAbility(
      "flame_step",
      "Flame Step",
      "Rare",
      "Dash burns around you, big close damage. Dash duration -10%, wave heal -5.",
      { dashDurationMult: 0.9, healAfterWaveAdd: -5 }
    );
    addNormalAbility(
      "blink_step",
      "Blink Step",
      "Epic",
      "Dash becomes short-range teleport with brief invuln. Dash CD -10%, max HP -10%.",
      { dashCooldownMult: 0.9, maxHpMult: 0.9 }
    );

    // fusions
    addNormalAbility(
      "limit_break",
      "Limit Break State",
      "Epic",
      "FUSION: Cursed Overflow + Quirk Booster. Huge DPS, max HP -25%, spread +25%.",
      { damageMult: 1.35, fireRateMult: 1.25, onHitHealAdd: 1.0, maxHpMult: 0.75, spreadMult: 1.25 },
      null,
      ["cursed_overflow", "quirk_booster"]
    );
    addNormalAbility(
      "sky_ripper",
      "Sky Ripper Maneuvers",
      "Epic",
      "FUSION: Survey + Kaiju. Crazy mobility, max HP -15%, wave heal -15.",
      { speedMult: 1.45, dashCooldownMult: 0.6, bulletSpeedMult: 1.3, maxHpMult: 0.85, healAfterWaveAdd: -15 },
      null,
      ["survey_maneuvers", "kaiju_instinct"]
    );
    addNormalAbility(
      "neon_ghoul",
      "Neon Ghoul",
      "Epic",
      "FUSION: Shadow Garden + Edgerunner. High risk, high sustain.",
      { damageMult: 1.35, fireRateMult: 1.25, onHitHealAdd: 1.2, maxHpMult: 0.8, healAfterWaveAdd: -20 },
      null,
      ["shadow_garden", "edgerunner_core"]
    );

    // Broken limit
    addNormalAbility(
      "broken_limit",
      "Broken Limit",
      "Rare",
      "Removes cap on powers but halves all ability effects. Curses unaffected.",
      {}
    );

    // ===== Boss abilities =====
    addBossAbility(
      "domain_collapse",
      "Domain Collapse",
      "Legendary",
      "DMG x2.0, +2 bullets, fire rate +15%, max HP -40%, spread +50%, wave heal -30.",
      { damageMult: 2.0, bulletsPerShotAdd: 2, fireRateMult: 1.15, maxHpMult: 0.6, spreadMult: 1.5, healAfterWaveAdd: -30 }
    );
    addBossAbility(
      "titan_ascend",
      "Titan Ascendance",
      "Legendary",
      "Max HP +40%, DMG +60%, pierce +2, speed -30%, wave heal -25.",
      { maxHpMult: 1.4, damageMult: 1.6, pierceAdd: 2, speedMult: 0.7, healAfterWaveAdd: -25 }
    );
    addBossAbility(
      "overclocked_quirk",
      "Overclocked Quirk",
      "Legendary",
      "Fire rate x2.0, speed +30%, max HP -50%, wave heal -35.",
      { fireRateMult: 2.0, speedMult: 1.3, maxHpMult: 0.5, healAfterWaveAdd: -35 }
    );
    addBossAbility(
      "cursed_family",
      "Cursed Family – Inverted Spear",
      "Legendary",
      "Melee DMG x2.5, range +60%, melee CD -35%, lifesteal +2, bullets weaker.",
      { meleeDamageMult: 2.5, meleeRangeMult: 1.6, meleeCooldownMult: 0.65, meleeOnHitHealAdd: 2, damageMult: 0.65, bulletsPerShotAdd: -1 }
    );

    // ===== Curses =====
    addCurse(
      "blood_moon",
      "Blood Moon",
      "Legendary",
      "DMG +25%, enemies faster + spawns +15%.",
      { damageMult: 1.25 },
      { enemySpeedMult: 1.2, enemyCountMult: 1.15 }
    );
    addCurse(
      "fragile_rage",
      "Fragile Rage",
      "Legendary",
      "Fire rate +40%, max HP -40%.",
      { fireRateMult: 1.4, maxHpMult: 0.6 },
      {}
    );
    addCurse(
      "predator",
      "Predator's Hunger",
      "Legendary",
      "On-hit heal +2, enemies +25%.",
      { onHitHealAdd: 2 },
      { enemyCountMult: 1.25 }
    );
    addCurse(
      "all_or_nothing",
      "All or Nothing",
      "Legendary",
      "DMG x2.4, max HP -70%.",
      { damageMult: 2.4, maxHpMult: 0.3 },
      {}
    );
  }

  /* ==================== ABILITY UI ==================== */

  function hideUpgradePanel() {
    upgradePanel.style.display = "none";
  }

  function renderAbilitiesBar() {
    normalAbilitiesListEl.innerHTML = "";
    bossAbilitiesListEl.innerHTML = "";

    function addSlot(id, category, parent) {
      const ab = getAbilityById(id);
      if (!ab) return;
      const rarityKey = (ab.rarity || "Common").toLowerCase();
      const slot = document.createElement("button");
      slot.className = `abilitySlot card-rarity-${rarityKey}`;
      slot.textContent = ab.name;
      slot.onclick = () => onAbilitySlotClick(id, category);
      parent.appendChild(slot);
    }

    for (const id of player.normalAbilities) addSlot(id, "normal", normalAbilitiesListEl);
    for (const id of player.bossAbilities) addSlot(id, "boss", bossAbilitiesListEl);
  }

  function equipAbility(ability) {
    if (ability.isCurse) return false;
    const isBoss = ability.category === "boss";
    const list = isBoss ? player.bossAbilities : player.normalAbilities;
    const maxSlots = isBoss ? 2 : 5;
    const unlimited = hasBrokenLimit();

    if (list.includes(ability.id)) {
      showMessage("Already have " + ability.name, 2);
      return false;
    }

    if (unlimited || list.length < maxSlots) {
      list.push(ability.id);
      recomputePlayerStats(true);
      renderAbilitiesBar();

      const rarity = ability.rarity || "Common";
      if (rarity === "Legendary") {
        addScreenShake(9, 0.4);
        addWhiteFlash(0.6);
        spawnParticles(player.x, player.y, {
          count: 32,
          speedMin: 160,
          speedMax: 320,
          sizeMin: 3,
          sizeMax: 6,
          color: "rgba(255,220,120,1)"
        });
      } else if (rarity === "Epic") {
        addScreenShake(6, 0.3);
      } else if (rarity === "Rare") {
        addScreenShake(4, 0.2);
      }

      return true;
    }

    pendingAbility = ability;
    pendingCategory = ability.category;
    gameState = "chooseReplace";
    hideUpgradePanel();
    showMessage("Click a " + (isBoss ? "boss" : "normal") + " power at the bottom to replace", 999);
    return null;
  }

  function onAbilitySlotClick(id, category) {
    if (!pendingAbility) return;
    if (category !== pendingCategory) {
      showMessage("Pick a " + (pendingCategory === "boss" ? "boss" : "normal") + " power to replace", 2);
      return;
    }
    const list = category === "boss" ? player.bossAbilities : player.normalAbilities;
    const idx = list.indexOf(id);
    if (idx === -1) return;
    list.splice(idx, 1);
    list.push(pendingAbility.id);
    recomputePlayerStats(true);
    renderAbilitiesBar();
    showMessage(pendingAbility.name + " equipped", 2);
    pendingAbility = null;
    pendingCategory = null;
    gameState = "playing";
    startNextWave();
  }

  function showUpgradePanel(options) {
    upgradePanel.style.display = "flex";
    upgradesContainer.innerHTML = "";

    for (const opt of options) {
      const isCurse = !!opt.isCurse;
      const rarityKey = (opt.rarity || "Common").toLowerCase();
      const badgeClass = `rarityBadge rarity-${rarityKey}`;
      const cardClass = `upgradeButton card-rarity-${rarityKey}`;
      const badgeText = isCurse ? "CURSE" : opt.rarity || "Common";

      const btn = document.createElement("button");
      btn.className = cardClass;
      btn.innerHTML =
        `<div class="upgradeTopRow">
          <span class="upgradeName">${opt.name}</span>
          <span class="${badgeClass}">${badgeText}</span>
        </div>
        <span class="upgradeDesc">${opt.description}</span>`;

      btn.onclick = () => {
        if (isCurse) {
          const ok = takeCurse(opt);
          if (ok) {
            hideUpgradePanel();
            startNextWave();
          }
        } else {
          const result = equipAbility(opt);
          if (result === true) {
            hideUpgradePanel();
            startNextWave();
          }
        }
      };

      upgradesContainer.appendChild(btn);
    }
  }

  function getAbilityOptions(count, isBossWave) {
    const owned = new Set([...player.normalAbilities, ...player.bossAbilities]);

    const normalAvailable = normalAbilities.filter(a => {
      if (owned.has(a.id)) return false;
      if (a.requires && !owned.has(a.requires)) return false;
      if (a.requiresAll && !a.requiresAll.every(id => owned.has(id))) return false;
      return true;
    });

    const bossAvailable = isBossWave
      ? bossAbilities.filter(a => {
          if (owned.has(a.id)) return false;
          if (a.requires && !owned.has(a.requires)) return false;
          if (a.requiresAll && !a.requiresAll.every(id => owned.has(id))) return false;
          return true;
        })
      : [];

    const options = [];
    const usedIds = new Set();

    if (isBossWave) {
      const pool = bossAvailable.length > 0 ? bossAvailable : bossAbilities;
      const arr = shuffled(pool);
      if (arr[0]) {
        options.push(arr[0]);
        usedIds.add(arr[0].id);
      }
    }

    const needed = count - options.length;
    if (needed > 0) {
      let pool = normalAvailable.length > 0 ? normalAvailable : normalAbilities;
      pool = shuffled(pool);
      for (const a of pool) {
        if (options.length >= count) break;
        if (usedIds.has(a.id)) continue;
        options.push(a);
        usedIds.add(a.id);
      }
    }

    return options;
  }

  function getCurseOptions(count) {
    let available = curses.filter(c => !activeCurses.includes(c.id));
    if (available.length === 0) available = curses.slice();
    const arr = shuffled(available);
    return arr.slice(0, count);
  }

  function takeCurse(curse) {
    if (hasCurse(curse.id)) {
      showMessage("Already cursed by " + curse.name, 2);
      return false;
    }
    activeCurses.push(curse.id);
    recomputeEnemyScale();
    recomputePlayerStats(true);
    addScreenShake(7, 0.35);
    addWhiteFlash(0.45);
    spawnParticles(player.x, player.y, {
      count: 24,
      speedMin: 120,
      speedMax: 260,
      sizeMin: 3,
      sizeMax: 5,
      color: "rgba(200,120,255,1)"
    });
    return true;
  }

  /* ==================== ENEMIES & WAVES ==================== */

  function spawnEnemy(isBoss = false) {
    const margin = 40;
    let x, y;
    do {
      x = Math.random() * (canvas.width - margin * 2) + margin;
      y = Math.random() * (canvas.height - margin * 2) + margin;
    } while (distance(x, y, player.x, player.y) < 160);

    if (isBoss) {
      let hpBase = 400 + wave * 40;
      hpBase *= enemyScale.hpMult;
      const speed = (100 + wave * 5) * enemyScale.speedMult;
      const contactDamage = (45 + wave * 3) * enemyScale.damageMult;

      enemies.push({
        x,
        y,
        radius: 40,
        speed,
        hp: hpBase,
        maxHp: hpBase,
        contactDamage,
        isBoss: true,
        phase: 1,
        ringCooldown: 2.5,
        rushCooldown: 3.0
      });
    } else {
      let hpBase = 35 + wave * 6;
      hpBase *= enemyScale.hpMult;
      let speed = (140 + wave * 8) * enemyScale.speedMult;
      let contactDamage = (12 + wave * 1.5) * enemyScale.damageMult;
      const typeRand = Math.random();
      let type = "runner";
      if (wave >= 3 && typeRand < 0.25) type = "sniper";
      else if (wave >= 5 && typeRand < 0.5) type = "bomber";

      let radius = 16;
      if (type === "sniper") { speed *= 0.8; radius = 17; }
      if (type === "bomber") { speed *= 1.05; contactDamage *= 2; radius = 18; }

      const e = {
        x,
        y,
        radius,
        speed,
        hp: hpBase,
        maxHp: hpBase,
        contactDamage,
        type,
        isBoss: false
      };
      if (type === "sniper") {
        e.shotCooldown = 2.2;
        e.strafeDir = Math.random() < 0.5 ? 1 : -1;
      }
      enemies.push(e);
    }
  }

  function startNextWave() {
    wave += 1;
    enemies = [];
    bullets = [];
    enemyBullets = [];
    playerBombs = [];
    fireBursts = [];
    const isBossWave = wave % 5 === 0;

    let baseCount = 4 + wave * 2;
    baseCount = Math.round(baseCount * enemyScale.countMult);
    baseCount = Math.max(1, baseCount);

    if (isBossWave) {
      spawnEnemy(true);
      const extra = Math.max(2, Math.floor(baseCount / 3));
      for (let i = 0; i < extra; i++) spawnEnemy(false);
      showMessage("Boss Wave " + wave, 3);
      addScreenShake(8, 0.4);
      addWhiteFlash(0.3);
    } else {
      for (let i = 0; i < baseCount; i++) spawnEnemy(false);
      showMessage("Wave " + wave, 2);
    }
  }

  function triggerBomberExplosion(e) {
    const radius = 90;
    const baseDamage = (30 + wave * 2.5) * enemyScale.damageMult;
    const distToPlayer = distance(e.x, e.y, player.x, player.y);
    if (distToPlayer <= radius + player.radius && !player.isDashing) {
      const dmg = baseDamage * (player.incomingDamageMult || 1);
      player.hp -= dmg;
      if (player.hp <= 0) {
        player.hp = 0;
        gameOver();
      }
    }
    fireBursts.push({
      x: e.x,
      y: e.y,
      radius,
      life: 0.25,
      maxLife: 0.25,
      color: "#ff7744"
    });
  }

  function updateEnemies(dt) {
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      if (e.isBoss) {
        updateBoss(e, dt);
        continue;
      }

      const dx = player.x - e.x;
      const dy = player.y - e.y;
      const dist = Math.hypot(dx, dy) || 1;
      const dirX = dx / dist;
      const dirY = dy / dist;

      if (e.type === "sniper") {
        const minDist = 260;
        const maxDist = 360;
        let moveX = 0;
        let moveY = 0;
        if (dist < minDist) { moveX = -dirX; moveY = -dirY; }
        else if (dist > maxDist) { moveX = dirX; moveY = dirY; }
        else {
          moveX = -dirY * e.strafeDir;
          moveY = dirX * e.strafeDir;
        }
        const len = Math.hypot(moveX, moveY) || 1;
        moveX /= len; moveY /= len;
        let nx = e.x + moveX * e.speed * dt;
        let ny = e.y + moveY * e.speed * dt;
        if (nx < e.radius || nx > canvas.width - e.radius) {
          e.strafeDir = -e.strafeDir;
          nx = clamp(nx, e.radius, canvas.width - e.radius);
        }
        if (ny < e.radius || ny > canvas.height - e.radius) {
          e.strafeDir = -e.strafeDir;
          ny = clamp(ny, e.radius, canvas.height - e.radius);
        }
        e.x = nx; e.y = ny;

        e.shotCooldown -= dt;
        if (e.shotCooldown <= 0) {
          spawnEnemyBulletAtPlayer(e, 260 + wave * 3);
          e.shotCooldown = 2.4;
        }
      } else {
        e.x += dirX * e.speed * dt;
        e.y += dirY * e.speed * dt;
      }

      e.x = clamp(e.x, e.radius, canvas.width - e.radius);
      e.y = clamp(e.y, e.radius, canvas.height - e.radius);

      const distToPlayer = distance(e.x, e.y, player.x, player.y);
      const minDist = e.radius + player.radius;
      if (distToPlayer < minDist) {
        const overlap = minDist - distToPlayer;
        const pushX = (player.x - e.x) / (distToPlayer || 1);
        const pushY = (player.y - e.y) / (distToPlayer || 1);
        player.x += pushX * overlap * 0.5;
        player.y += pushY * overlap * 0.5;
        e.x -= pushX * overlap * 0.5;
        e.y -= pushY * overlap * 0.5;

        if (e.type === "bomber") {
          triggerBomberExplosion(e);
          enemies.splice(i, 1);
          continue;
        }

        if (!player.isDashing) {
          const dmg = e.contactDamage * dt * (player.incomingDamageMult || 1);
          player.hp -= dmg;
          if (player.hp <= 0) {
            player.hp = 0;
            gameOver();
            return;
          }
        }
      }
    }
  }

  function spawnEnemyBulletAtPlayer(e, speed) {
    const dx = player.x - e.x;
    const dy = player.y - e.y;
    const dist = Math.hypot(dx, dy) || 1;
    const finalSpeed = speed * enemyScale.bulletSpeedMult;
    const vx = (dx / dist) * finalSpeed;
    const vy = (dy / dist) * finalSpeed;
    const baseDamage = (18 + wave * 1.8) * enemyScale.bulletDamageMult;
    enemyBullets.push({
      x: e.x,
      y: e.y,
      vx,
      vy,
      radius: 4,
      damage: baseDamage
    });
  }

  function spawnBossRing(e, count, speed) {
    const finalSpeed = speed * enemyScale.bulletSpeedMult;
    const baseDamage = (16 + wave * 1.6) * enemyScale.bulletDamageMult;
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count;
      enemyBullets.push({
        x: e.x,
        y: e.y,
        vx: Math.cos(angle) * finalSpeed,
        vy: Math.sin(angle) * finalSpeed,
        radius: 4,
        damage: baseDamage
      });
    }
  }

  function updateBoss(e, dt) {
    const ratio = e.hp / e.maxHp;
    if (e.phase === 1 && ratio <= 0.66) {
      e.phase = 2;
      showMessage("Boss Phase 2!", 2);
      addScreenShake(8, 0.35);
      addWhiteFlash(0.3);
      spawnParticles(e.x, e.y, {
        count: 28,
        speedMin: 150,
        speedMax: 320,
        sizeMin: 3,
        sizeMax: 5,
        color: "rgba(255,220,140,1)"
      });
    } else if (e.phase === 2 && ratio <= 0.33) {
      e.phase = 3;
      showMessage("Boss Final Phase!", 2.5);
      addScreenShake(10, 0.4);
      addWhiteFlash(0.4);
      spawnParticles(e.x, e.y, {
        count: 32,
        speedMin: 170,
        speedMax: 340,
        sizeMin: 3,
        sizeMax: 6,
        color: "rgba(255,150,150,1)"
      });
    }

    const dx = player.x - e.x;
    const dy = player.y - e.y;
    const dist = Math.hypot(dx, dy) || 1;
    const dirX = dx / dist;
    const dirY = dy / dist;

    const moveSpeed = e.speed * (e.phase === 1 ? 0.7 : e.phase === 2 ? 0.85 : 1.0);
    e.x += dirX * moveSpeed * dt;
    e.y += dirY * moveSpeed * dt;

    e.x = clamp(e.x, e.radius, canvas.width - e.radius);
    e.y = clamp(e.y, e.radius, canvas.height - e.radius);

    e.ringCooldown -= dt;
    if (e.ringCooldown <= 0) {
      const baseCount = 10 + Math.min(10, Math.floor(wave / 2));
      const count = e.phase === 1 ? baseCount : e.phase === 2 ? baseCount + 4 : baseCount + 8;
      spawnBossRing(e, count, 230 + wave * 4 + 20 * e.phase);
      e.ringCooldown = e.phase === 1 ? 3.2 : e.phase === 2 ? 2.6 : 2.0;
    }

    e.rushCooldown -= dt;
    if (e.rushCooldown <= 0) {
      spawnEnemyBulletAtPlayer(e, 260 + wave * 4 + 20 * e.phase);
      if (e.phase >= 2) spawnEnemyBulletAtPlayer(e, 260 + wave * 4 + 40 * e.phase);
      e.rushCooldown = e.phase === 1 ? 2.3 : e.phase === 2 ? 1.8 : 1.4;
    }

    const distToPlayer = distance(e.x, e.y, player.x, player.y);
    const minDist = e.radius + player.radius;
    if (distToPlayer < minDist) {
      const overlap = minDist - distToPlayer;
      const pushX = (player.x - e.x) / (distToPlayer || 1);
      const pushY = (player.y - e.y) / (distToPlayer || 1);
      player.x += pushX * overlap * 0.5;
      player.y += pushY * overlap * 0.5;
      e.x -= pushX * overlap * 0.5;
      e.y -= pushY * overlap * 0.5;

      if (!player.isDashing) {
        const dmg = e.contactDamage * dt * 1.3 * (player.incomingDamageMult || 1);
        player.hp -= dmg;
        if (player.hp <= 0) {
          player.hp = 0;
          gameOver();
          return;
        }
      }
    }
  }

  function updateEnemyBullets(dt) {
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
      const b = enemyBullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;

      if (b.x < -50 || b.x > canvas.width + 50 || b.y < -50 || b.y > canvas.height + 50) {
        enemyBullets.splice(i, 1);
        continue;
      }

      const distToPlayer = distance(b.x, b.y, player.x, player.y);
      if (distToPlayer < b.radius + player.radius) {
        if (!player.isDashing) {
          const dmg = b.damage * (player.incomingDamageMult || 1);
          player.hp -= dmg;
          if (player.hp <= 0) {
            player.hp = 0;
            gameOver();
          }
        }
        enemyBullets.splice(i, 1);
      }
    }
  }

  function checkWaveCleared() {
    if (gameState !== "playing") return;
    if (enemies.length === 0) onWaveCleared();
  }

  function onWaveCleared() {
    gameState = "upgrade";
    player.hp = Math.min(player.maxHp, player.hp + player.healAfterWave);
    pendingAbility = null;
    pendingCategory = null;

    const isBossWave = wave % 5 === 0;
    const abilityOptions = getAbilityOptions(2, isBossWave);
    let finalOptions = abilityOptions;
    if (isBossWave) {
      const curseOptions = getCurseOptions(1);
      finalOptions = abilityOptions.concat(curseOptions);
    }
    showUpgradePanel(finalOptions);
  }

  /* ==================== DASH, MELEE, BULLETS ==================== */

  function damageEnemiesInRadius(x, y, radius, damage) {
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      const dist = distance(e.x, e.y, x, y);
      if (dist <= radius + e.radius) {
        e.hp -= damage;
        if (e.hp <= 0) {
          if (e.isBoss) {
            spawnParticles(e.x, e.y, {
              count: 40,
              speedMin: 150,
              speedMax: 350,
              sizeMin: 3,
              sizeMax: 6,
              color: "rgba(255,210,140,1)"
            });
          }
          if (e.type === "bomber") triggerBomberExplosion(e);
          enemies.splice(i, 1);
        }
      }
    }
  }

  function startDash() {
    if (!player || gameState !== "playing") return;
    if (player.dashActiveTimer > 0) return;
    if (player.dashCooldownTimer > 0) return;

    let dirX = 0, dirY = 0;
    if (keys["w"] || keys["arrowup"]) dirY -= 1;
    if (keys["s"] || keys["arrowdown"]) dirY += 1;
    if (keys["a"] || keys["arrowleft"]) dirX -= 1;
    if (keys["d"] || keys["arrowright"]) dirX += 1;
    let len = Math.hypot(dirX, dirY);
    if (len === 0) {
      dirX = mousePos.x - player.x;
      dirY = mousePos.y - player.y;
      len = Math.hypot(dirX, dirY) || 1;
    }
    dirX /= len; dirY /= len;

    let dashSpeed = player.speed * 4.0;

    // dash particles on start
    spawnParticles(player.x, player.y, {
      count: 18,
      speedMin: 90,
      speedMax: 220,
      sizeMin: 2,
      sizeMax: 4,
      color: "rgba(160,220,255,1)"
    });

    if (player.dashMode === "blink") {
      const blinkDist = 180;
      const tx = player.x + dirX * blinkDist;
      const ty = player.y + dirY * blinkDist;
      player.x = clamp(tx, player.radius, canvas.width - player.radius);
      player.y = clamp(ty, player.radius, canvas.height - player.radius);
      player.dashVelX = 0;
      player.dashVelY = 0;
      player.dashActiveTimer = Math.max(0.12, player.dashDuration * 0.6);
      player.dashCooldownTimer = player.dashCooldown;
      player.isDashing = true;
      return;
    }

    if (player.dashMode === "bomb") {
      const radius = 120;
      const dmg = player.damage * 3 + 40 + wave * 4;
      const fuse = 0.55;
      playerBombs.push({
        x: player.x,
        y: player.y,
        radius,
        damage: dmg,
        fuse,
        maxFuse: fuse
      });
    }

    if (player.dashMode === "flame") {
      const r = 130;
      const dmg = player.damage * 2.1 + 30 + wave * 3;
      damageEnemiesInRadius(player.x, player.y, r, dmg);
      fireBursts.push({
        x: player.x,
        y: player.y,
        radius: r,
        life: 0.2,
        maxLife: 0.2,
        color: "#ff7b47"
      });
    }

    player.dashVelX = dirX * dashSpeed;
    player.dashVelY = dirY * dashSpeed;
    player.dashActiveTimer = player.dashDuration;
    player.dashCooldownTimer = player.dashCooldown;
    player.isDashing = true;
  }

  function tryMeleeAttack() {
    if (!player || gameState !== "playing") return;
    if (player.meleeCooldownTimer > 0) return;

    const dx = mousePos.x - player.x;
    const dy = mousePos.y - player.y;
    const baseAngle = Math.atan2(dy, dx);
    player.meleeAngle = baseAngle;
    player.meleeSwingTimer = player.meleeSwingDuration;
    player.meleeCooldownTimer = player.meleeCooldown;

    const range = player.meleeRange;
    const dmgBase = player.meleeDamage;

    // melee slash particles
    spawnParticles(
      player.x + Math.cos(baseAngle) * range * 0.7,
      player.y + Math.sin(baseAngle) * range * 0.7,
      {
        count: 14,
        speedMin: 120,
        speedMax: 260,
        sizeMin: 2,
        sizeMax: 4,
        color: "rgba(255,200,160,1)"
      }
    );

    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      const ex = e.x - player.x;
      const ey = e.y - player.y;
      const dist = Math.hypot(ex, ey);
      if (dist > range + e.radius) continue;
      const ang = Math.atan2(ey, ex);
      const diff = Math.abs(angleDiff(ang, baseAngle));
      if (diff <= player.meleeArc / 2) {
        e.hp -= dmgBase;
        const heal = player.meleeOnHitHeal;
        if (heal > 0) player.hp = Math.min(player.maxHp, player.hp + heal);
        if (e.hp <= 0) {
          if (e.type === "bomber") triggerBomberExplosion(e);
          enemies.splice(i, 1);
        }
      }
    }
  }

  function shoot(dmgMult = 1, extraBullets = 0) {
    const dx = mousePos.x - player.x;
    const dy = mousePos.y - player.y;
    const baseAngle = Math.atan2(dy, dx);
    const count = player.bulletsPerShot + extraBullets;
    const totalSpread = player.spread * (count - 1);
    const dmg = player.damage * dmgMult;

    for (let i = 0; i < count; i++) {
      const angle = baseAngle - totalSpread / 2 + player.spread * i;
      const vx = Math.cos(angle) * player.bulletSpeed;
      const vy = Math.sin(angle) * player.bulletSpeed;
      bullets.push({
        x: player.x,
        y: player.y,
        vx,
        vy,
        radius: 5,
        damage: dmg,
        pierceLeft: player.pierce
      });
    }
  }

  function updatePlayer(dt) {
    // cooldowns
    if (player.dashCooldownTimer > 0) player.dashCooldownTimer = Math.max(0, player.dashCooldownTimer - dt);
    if (player.dashActiveTimer > 0) {
      player.dashActiveTimer -= dt;
      if (player.dashActiveTimer <= 0) {
        player.dashActiveTimer = 0;
        player.isDashing = false;
      }
    }
    if (player.meleeCooldownTimer > 0) player.meleeCooldownTimer = Math.max(0, player.meleeCooldownTimer - dt);
    if (player.meleeSwingTimer > 0) player.meleeSwingTimer = Math.max(0, player.meleeSwingTimer - dt);

    if (player.isDashing) {
      player.x += player.dashVelX * dt;
      player.y += player.dashVelY * dt;
    } else {
      let dirX = 0, dirY = 0;
      if (keys["w"] || keys["arrowup"]) dirY -= 1;
      if (keys["s"] || keys["arrowdown"]) dirY += 1;
      if (keys["a"] || keys["arrowleft"]) dirX -= 1;
      if (keys["d"] || keys["arrowright"]) dirX += 1;
      const len = Math.hypot(dirX, dirY);
      if (len > 0) {
        dirX /= len; dirY /= len;
        player.x += dirX * player.speed * dt;
        player.y += dirY * player.speed * dt;
      }
    }
    player.x = clamp(player.x, player.radius, canvas.width - player.radius);
    player.y = clamp(player.y, player.radius, canvas.height - player.radius);

    // shooting
    player.shootTimer += dt;
    if (mouseDown) {
      const needed = 1 / player.fireRate;
      if (player.shootTimer >= needed) {
        shoot(1, 0);
        player.shootTimer = 0;
      }
    }

    if (player.hp <= 0) {
      player.hp = 0;
      gameOver();
    }
  }

  function updateBullets(dt) {
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;

      if (b.x < -50 || b.x > canvas.width + 50 || b.y < -50 || b.y > canvas.height + 50) {
        bullets.splice(i, 1);
        continue;
      }

      let pierced = false;
      for (let j = enemies.length - 1; j >= 0; j--) {
        const e = enemies[j];
        const dist = distance(b.x, b.y, e.x, e.y);
        if (dist < b.radius + e.radius) {
          e.hp -= b.damage;
          if (player.onHitHeal > 0) {
            player.hp = Math.min(player.maxHp, player.hp + player.onHitHeal);
          }

          // hit particles
          spawnParticles(e.x, e.y, {
            count: 8,
            speedMin: 80,
            speedMax: 180,
            sizeMin: 2,
            sizeMax: 3,
            color: "rgba(255,200,150,1)"
          });

          if (e.hp <= 0) {
            spawnParticles(e.x, e.y, {
              count: 18,
              speedMin: 120,
              speedMax: 260,
              sizeMin: 2,
              sizeMax: 4,
              color: "rgba(255,140,140,1)"
            });
            if (e.isBoss) {
              addScreenShake(11, 0.5);
            }
            if (e.type === "bomber") triggerBomberExplosion(e);
            enemies.splice(j, 1);
          }

          if (b.pierceLeft <= 0) {
            bullets.splice(i, 1);
            pierced = true;
          } else {
            b.pierceLeft -= 1;
          }
          break;
        }
      }
      if (pierced) continue;
    }
  }

  function updateBombs(dt) {
    for (let i = playerBombs.length - 1; i >= 0; i--) {
      const bomb = playerBombs[i];
      bomb.fuse -= dt;
      if (bomb.fuse <= 0) {
        damageEnemiesInRadius(bomb.x, bomb.y, bomb.radius, bomb.damage);
        fireBursts.push({
          x: bomb.x,
          y: bomb.y,
          radius: bomb.radius,
          life: 0.25,
          maxLife: 0.25,
          color: "#ffd56b"
        });
        playerBombs.splice(i, 1);
      }
    }
  }

  function updateFireBursts(dt) {
    for (let i = fireBursts.length - 1; i >= 0; i--) {
      const f = fireBursts[i];
      f.life -= dt;
      if (f.life <= 0) {
        fireBursts.splice(i, 1);
      }
    }
  }

  /* ==================== HUD & GAME STATE ==================== */

  function updateHUD() {
    hudWave.textContent = `Wave ${wave}`;
    hudHP.textContent = `HP: ${Math.round(player.hp)} / ${Math.round(player.maxHp)}`;

    const ratio = player.hp / player.maxHp;
    if (ratio <= 0.3) hudHP.classList.add("low");
    else hudHP.classList.remove("low");

    const dashLabel = player.dashCooldownTimer <= 0 ? "Dash: Ready" : `Dash: ${player.dashCooldownTimer.toFixed(1)}s`;
    const meleeLabel = player.meleeCooldownTimer <= 0 ? "Melee: Ready" : `Melee: ${player.meleeCooldownTimer.toFixed(1)}s`;

    const noLimitText = noLimitMode ? "Slots: ∞ (halved)" : "Slots: 5 normal / 2 boss";

    hudStats.textContent =
      `DMG ${Math.round(player.damage)} | Fire ${player.fireRate.toFixed(1)}/s | Bullets ${player.bulletsPerShot} | ` +
      `Pierce ${player.pierce} | ${meleeLabel} | ${dashLabel} | ${noLimitText}`;
  }

  function gameOver() {
    gameState = "gameover";
    addScreenShake(12, 0.6);
    addWhiteFlash(0.5);
    spawnParticles(player.x, player.y, {
      count: 40,
      speedMin: 150,
      speedMax: 340,
      sizeMin: 3,
      sizeMax: 6,
      color: "rgba(255,120,120,1)"
    });
    showMessage("Game Over – press R to restart", 999);
  }

  /* ==================== UPDATE & DRAW LOOP ==================== */

  function update(dt) {
    if (gameState === "menu") return;

    if (messageTimer > 0) {
      messageTimer -= dt;
      if (messageTimer <= 0) overlayMessageEl.textContent = "";
    }

    // shake timers
    if (screenShakeTimer > 0) {
      screenShakeTimer -= dt;
      if (screenShakeTimer <= 0) {
        screenShakeTimer = 0;
        screenShakeIntensity = 0;
        screenShakeDuration = 0;
      }
    }
    if (whiteFlashAlpha > 0) {
      whiteFlashAlpha -= dt * 1.5;
      if (whiteFlashAlpha < 0) whiteFlashAlpha = 0;
    }

    updateBackground(dt);
    updateParticles(dt);

    if (gameState === "upgrade" || gameState === "chooseReplace" || gameState === "gameover") {
      updateHUD();
      return;
    }

    updatePlayer(dt);
    updateBullets(dt);
    updateEnemies(dt);
    updateEnemyBullets(dt);
    updateBombs(dt);
    updateFireBursts(dt);
    checkWaveCleared();
    updateHUD();
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBackground();

    let shakeX = 0, shakeY = 0;
    if (screenShakeTimer > 0 && screenShakeDuration > 0 && screenShakeIntensity > 0) {
      const t = screenShakeTimer / screenShakeDuration;
      const power = t * t;
      const maxOffset = screenShakeIntensity * power;
      shakeX = (Math.random() * 2 - 1) * maxOffset;
      shakeY = (Math.random() * 2 - 1) * maxOffset;
    }

    ctx.save();
    ctx.translate(shakeX, shakeY);

    // fire bursts
    for (const f of fireBursts) {
      const t = f.life / f.maxLife;
      ctx.save();
      ctx.globalAlpha = 0.5 * t;
      ctx.beginPath();
      ctx.arc(f.x, f.y, f.radius * (1 + (1 - t) * 0.3), 0, Math.PI * 2);
      ctx.fillStyle = f.color;
      ctx.fill();
      ctx.restore();
    }

    // bombs telegraph
    for (const bomb of playerBombs) {
      const t = bomb.fuse / bomb.maxFuse;
      ctx.save();
      ctx.globalAlpha = 0.25 + (1 - t) * 0.3;
      ctx.beginPath();
      ctx.arc(bomb.x, bomb.y, bomb.radius * (0.4 + 0.2 * (1 - t)), 0, Math.PI * 2);
      ctx.fillStyle = "#ffdd55";
      ctx.fill();
      ctx.restore();
    }

    drawParticles();

    // enemy bullets
    for (const b of enemyBullets) {
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
      ctx.fillStyle = "#ff5555";
      ctx.fill();
    }

    // enemies
    for (const e of enemies) {
      if (e.isBoss) {
        // aura
        const auraR = e.phase === 1 ? 130 : e.phase === 2 ? 150 : 180;
        ctx.save();
        ctx.beginPath();
        ctx.arc(e.x, e.y, auraR, 0, Math.PI * 2);
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = "#9a6bff";
        ctx.fill();
        ctx.restore();
      }

      const ratio = e.hp / e.maxHp;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
      ctx.fillStyle = e.isBoss ? "#ff3b3b" : (e.type === "sniper" ? "#87c7ff" : e.type === "bomber" ? "#ffb86c" : "#ffae00");
      ctx.fill();

      const barW = e.radius * 2;
      const barH = 4;
      ctx.fillStyle = "#000";
      ctx.fillRect(e.x - e.radius, e.y - e.radius - 8, barW, barH);
      ctx.fillStyle = "#00ff4b";
      ctx.fillRect(e.x - e.radius, e.y - e.radius - 8, barW * ratio, barH);
    }

    // bullets
    for (const b of bullets) {
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
      ctx.fillStyle = "#f5f5f5";
      ctx.fill();
    }

    // player + melee arc
    if (player) {
      if (player.meleeSwingTimer > 0) {
        const t = player.meleeSwingTimer / player.meleeSwingDuration;
        ctx.save();
        ctx.translate(player.x, player.y);
        ctx.rotate(player.meleeAngle);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.arc(0, 0, player.meleeRange, -player.meleeArc / 2, player.meleeArc / 2);
        ctx.closePath();
        ctx.globalAlpha = 0.2 + 0.2 * t;
        ctx.fillStyle = "#ffcc88";
        ctx.fill();
        ctx.restore();
      }

      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
      ctx.fillStyle = player.isDashing ? "#9ff6ff" : "#39c5ff";
      ctx.fill();

      const dx = mousePos.x - player.x;
      const dy = mousePos.y - player.y;
      const ang = Math.atan2(dy, dx);
      const gunLen = player.radius + 6;
      ctx.beginPath();
      ctx.moveTo(player.x, player.y);
      ctx.lineTo(player.x + Math.cos(ang) * gunLen, player.y + Math.sin(ang) * gunLen);
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    ctx.restore(); // end shake

    // white flash overlay
    if (whiteFlashAlpha > 0) {
      ctx.save();
      ctx.globalAlpha = whiteFlashAlpha;
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
    }
  }

  function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  /* ==================== GAME INIT & MENU ==================== */

  function resetGame() {
    bullets = [];
    enemies = [];
    enemyBullets = [];
    playerBombs = [];
    fireBursts = [];
    particles.length = 0;
    activeCurses = [];
    recomputeEnemyScale();
    wave = 0;
    pendingAbility = null;
    pendingCategory = null;
    gameState = "playing";
    lastTime = 0;
    hideUpgradePanel();
    player = createPlayer();

    // starting ability based on combat style
    if (combatStyle === "melee") {
      player.normalAbilities.push("water_breathing");
    } else {
      player.normalAbilities.push("quirk_booster");
    }

    recomputePlayerStats(false);
    renderAbilitiesBar();
    initBackground();
    startNextWave();
  }

  document.querySelectorAll(".menuButton[data-style]").forEach(btn => {
    btn.addEventListener("click", () => {
      const style = btn.getAttribute("data-style");
      combatStyle = style;
      document.querySelectorAll(".menuButton[data-style]").forEach(b => b.classList.remove("styleActive"));
      btn.classList.add("styleActive");
      if (!player) {
        mainMenu.style.display = "none";
        gameState = "playing";
        initAbilities();
        resetGame();
        requestAnimationFrame(loop);
      } else {
        resetGame();
      }
    });
  });

  skipButton.addEventListener("click", () => {
    if (gameState !== "upgrade") return;
    pendingAbility = null;
    pendingCategory = null;
    hideUpgradePanel();
    gameState = "playing";
    startNextWave();
  });
  </script>
</body>
</html>
